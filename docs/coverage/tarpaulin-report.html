<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","benches","parser_bench.rs"],"content":"fn main() { println\\!(\"Placeholder benchmark\"); }\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","examples","debug.rs"],"content":"use fusabi_interpreter::*;\n\nfn main() {\n    // Test let expression\n    let code1 = \"let x = 42 in x + 1\";\n    println!(\"Code: {}\", code1);\n    match eval(code1) {\n        Ok(result) =\u003e println!(\"Result: {} (expected: 43)\", result),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n\n    // Test nested let\n    let code2 = \"let x = 10 in let y = 20 in x + y\";\n    println!(\"\\nCode: {}\", code2);\n    match eval(code2) {\n        Ok(result) =\u003e println!(\"Result: {} (expected: 30)\", result),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n\n    // Test nested function\n    let code3 = r#\"\n        let outer x =\n            let inner y = x + y\n            inner(10)\n        outer(5)\n    \"#;\n    println!(\"\\nCode: {}\", code3);\n    match eval(code3) {\n        Ok(result) =\u003e println!(\"Result: {} (expected: 15)\", result),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n\n    // Simple test\n    let code4 = \"let x = 42 in x\";\n    println!(\"\\nCode: {}\", code4);\n    match eval(code4) {\n        Ok(result) =\u003e println!(\"Result: {} (expected: 42)\", result),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","ast.rs"],"content":"use std::fmt;\nuse std::collections::HashMap;\n\n/// Runtime values in Fusabi\n#[derive(Debug, Clone, PartialEq)]\npub enum Value {\n    Nil,\n    Bool(bool),\n    Int(i64),\n    Float(f64),\n    String(String),\n    List(Vec\u003cValue\u003e),\n    Map(HashMap\u003cString, Value\u003e),\n    Function(Function),\n    #[cfg(feature = \"bevy-integration\")]\n    Entity(bevy::ecs::entity::Entity),\n}\n\nimpl Value {\n    pub fn type_name(\u0026self) -\u003e \u0026str {\n        match self {\n            Value::Nil =\u003e \"nil\",\n            Value::Bool(_) =\u003e \"bool\",\n            Value::Int(_) =\u003e \"int\",\n            Value::Float(_) =\u003e \"float\",\n            Value::String(_) =\u003e \"string\",\n            Value::List(_) =\u003e \"list\",\n            Value::Map(_) =\u003e \"map\",\n            Value::Function(_) =\u003e \"function\",\n            #[cfg(feature = \"bevy-integration\")]\n            Value::Entity(_) =\u003e \"entity\",\n        }\n    }\n\n    pub fn as_bool(\u0026self) -\u003e crate::error::Result\u003cbool\u003e {\n        match self {\n            Value::Bool(b) =\u003e Ok(*b),\n            _ =\u003e Err(crate::error::FusabiError::type_error(\"bool\", self.type_name())),\n        }\n    }\n\n    pub fn as_int(\u0026self) -\u003e crate::error::Result\u003ci64\u003e {\n        match self {\n            Value::Int(i) =\u003e Ok(*i),\n            _ =\u003e Err(crate::error::FusabiError::type_error(\"int\", self.type_name())),\n        }\n    }\n\n    pub fn as_float(\u0026self) -\u003e crate::error::Result\u003cf64\u003e {\n        match self {\n            Value::Float(f) =\u003e Ok(*f),\n            Value::Int(i) =\u003e Ok(*i as f64),\n            _ =\u003e Err(crate::error::FusabiError::type_error(\"float\", self.type_name())),\n        }\n    }\n\n    pub fn as_string(\u0026self) -\u003e crate::error::Result\u003cString\u003e {\n        match self {\n            Value::String(s) =\u003e Ok(s.clone()),\n            _ =\u003e Err(crate::error::FusabiError::type_error(\"string\", self.type_name())),\n        }\n    }\n\n    pub fn as_list(\u0026self) -\u003e crate::error::Result\u003c\u0026Vec\u003cValue\u003e\u003e {\n        match self {\n            Value::List(l) =\u003e Ok(l),\n            _ =\u003e Err(crate::error::FusabiError::type_error(\"list\", self.type_name())),\n        }\n    }\n\n    pub fn as_map(\u0026self) -\u003e crate::error::Result\u003c\u0026HashMap\u003cString, Value\u003e\u003e {\n        match self {\n            Value::Map(m) =\u003e Ok(m),\n            _ =\u003e Err(crate::error::FusabiError::type_error(\"map\", self.type_name())),\n        }\n    }\n\n    pub fn is_truthy(\u0026self) -\u003e bool {\n        match self {\n            Value::Nil =\u003e false,\n            Value::Bool(b) =\u003e *b,\n            _ =\u003e true,\n        }\n    }\n}\n\nimpl fmt::Display for Value {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Value::Nil =\u003e write!(f, \"nil\"),\n            Value::Bool(b) =\u003e write!(f, \"{}\", b),\n            Value::Int(i) =\u003e write!(f, \"{}\", i),\n            Value::Float(fl) =\u003e write!(f, \"{}\", fl),\n            Value::String(s) =\u003e write!(f, \"{}\", s),\n            Value::List(l) =\u003e {\n                write!(f, \"[\")?;\n                for (i, v) in l.iter().enumerate() {\n                    if i \u003e 0 {\n                        write!(f, \", \")?;\n                    }\n                    write!(f, \"{}\", v)?;\n                }\n                write!(f, \"]\")\n            }\n            Value::Map(m) =\u003e {\n                write!(f, \"{{\")?;\n                for (i, (k, v)) in m.iter().enumerate() {\n                    if i \u003e 0 {\n                        write!(f, \", \")?;\n                    }\n                    write!(f, \"{}: {}\", k, v)?;\n                }\n                write!(f, \"}}\")\n            }\n            Value::Function(func) =\u003e write!(f, \"\u003cfunction {}\u003e\", func.name),\n            #[cfg(feature = \"bevy-integration\")]\n            Value::Entity(e) =\u003e write!(f, \"\u003centity {:?}\u003e\", e),\n        }\n    }\n}\n\n/// Function representation\n#[derive(Debug, Clone, PartialEq)]\npub struct Function {\n    pub name: String,\n    pub params: Vec\u003cString\u003e,\n    pub body: FunctionBody,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum FunctionBody {\n    /// User-defined function with AST body\n    Expr(Box\u003cExpr\u003e),\n    /// Built-in native function\n    Native(NativeFunction),\n}\n\n#[derive(Clone)]\npub struct NativeFunction {\n    pub name: String,\n    pub arity: usize,\n    pub func: fn(\u0026[Value]) -\u003e crate::error::Result\u003cValue\u003e,\n}\n\nimpl fmt::Debug for NativeFunction {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"NativeFunction\")\n            .field(\"name\", \u0026self.name)\n            .field(\"arity\", \u0026self.arity)\n            .finish()\n    }\n}\n\nimpl PartialEq for NativeFunction {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.name == other.name \u0026\u0026 self.arity == other.arity\n    }\n}\n\n/// AST Expression nodes\n#[derive(Debug, Clone, PartialEq)]\npub enum Expr {\n    // Literals\n    Literal(Value),\n    Variable(String),\n\n    // Binary operations\n    BinOp {\n        op: BinOp,\n        left: Box\u003cExpr\u003e,\n        right: Box\u003cExpr\u003e,\n    },\n\n    // Unary operations\n    UnaryOp {\n        op: UnaryOp,\n        expr: Box\u003cExpr\u003e,\n    },\n\n    // Function call\n    Call {\n        func: Box\u003cExpr\u003e,\n        args: Vec\u003cExpr\u003e,\n    },\n\n    // Lambda expression\n    Lambda {\n        params: Vec\u003cString\u003e,\n        body: Box\u003cExpr\u003e,\n    },\n\n    // Let binding\n    Let {\n        name: String,\n        value: Box\u003cExpr\u003e,\n        body: Box\u003cExpr\u003e,\n    },\n\n    // Conditional\n    If {\n        condition: Box\u003cExpr\u003e,\n        then_expr: Box\u003cExpr\u003e,\n        else_expr: Option\u003cBox\u003cExpr\u003e\u003e,\n    },\n\n    // List literal\n    ListLiteral(Vec\u003cExpr\u003e),\n\n    // Map literal\n    MapLiteral(Vec\u003c(String, Expr)\u003e),\n\n    // List/Map access\n    Index {\n        expr: Box\u003cExpr\u003e,\n        index: Box\u003cExpr\u003e,\n    },\n\n    // Field access (for maps)\n    Field {\n        expr: Box\u003cExpr\u003e,\n        field: String,\n    },\n\n    // Block expression (sequence)\n    Block(Vec\u003cStatement\u003e),\n}\n\n/// Binary operators\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum BinOp {\n    // Arithmetic\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Mod,\n\n    // Comparison\n    Eq,\n    Ne,\n    Lt,\n    Le,\n    Gt,\n    Ge,\n\n    // Logical\n    And,\n    Or,\n\n    // String\n    Concat,\n}\n\n/// Unary operators\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum UnaryOp {\n    Neg,\n    Not,\n}\n\n/// Statements\n#[derive(Debug, Clone, PartialEq)]\npub enum Statement {\n    // Expression statement\n    Expr(Expr),\n\n    // Let binding (top-level or in block)\n    Let {\n        name: String,\n        value: Expr,\n    },\n\n    // Function definition\n    Function {\n        name: String,\n        params: Vec\u003cString\u003e,\n        body: Box\u003cExpr\u003e,\n    },\n\n    // Return statement\n    Return(Option\u003cExpr\u003e),\n}\n\n/// Top-level module/script\n#[derive(Debug, Clone, PartialEq)]\npub struct Module {\n    pub statements: Vec\u003cStatement\u003e,\n}\n\nimpl Module {\n    pub fn new(statements: Vec\u003cStatement\u003e) -\u003e Self {\n        Self { statements }\n    }\n\n    pub fn empty() -\u003e Self {\n        Self {\n            statements: Vec::new(),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","bevy_integration.rs"],"content":"#[cfg(feature = \"bevy-integration\")]\nuse bevy::prelude::*;\n\n#[cfg(feature = \"bevy-integration\")]\nuse crate::ast::Value;\n#[cfg(feature = \"bevy-integration\")]\nuse crate::environment::Environment;\n#[cfg(feature = \"bevy-integration\")]\nuse crate::error::Result;\n#[cfg(feature = \"bevy-integration\")]\nuse crate::ast::{Function, FunctionBody, NativeFunction};\n\n#[cfg(feature = \"bevy-integration\")]\n/// Load Bevy-specific functions into the environment\npub fn load_bevy_stdlib(env: \u0026mut Environment) {\n    register_bevy_native(env, \"ui_spawn_button\", 2, ui_spawn_button);\n    register_bevy_native(env, \"ui_spawn_text\", 1, ui_spawn_text);\n    register_bevy_native(env, \"ui_spawn_container\", 0, ui_spawn_container);\n    register_bevy_native(env, \"ui_set_position\", 4, ui_set_position);\n    register_bevy_native(env, \"ui_set_size\", 3, ui_set_size);\n    register_bevy_native(env, \"ui_set_color\", 5, ui_set_color);\n}\n\n#[cfg(feature = \"bevy-integration\")]\nfn register_bevy_native(\n    env: \u0026mut Environment,\n    name: \u0026str,\n    arity: usize,\n    func: fn(\u0026[Value]) -\u003e Result\u003cValue\u003e,\n) {\n    let native = NativeFunction {\n        name: name.to_string(),\n        arity,\n        func,\n    };\n    env.define(\n        name.to_string(),\n        Value::Function(Function {\n            name: name.to_string(),\n            params: (0..arity).map(|i| format!(\"arg{}\", i)).collect(),\n            body: FunctionBody::Native(native),\n        }),\n    );\n}\n\n// UI Functions (these would integrate with the actual Bevy world)\n// For now, they return placeholder entities\n\n#[cfg(feature = \"bevy-integration\")]\nfn ui_spawn_button(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    // In a real implementation, this would:\n    // 1. Get the text from args[0]\n    // 2. Get the callback from args[1]\n    // 3. Spawn a button entity in the Bevy world\n    // 4. Return the entity ID\n\n    // Placeholder implementation\n    use crate::error::FusabiError;\n    Err(FusabiError::runtime_error(\n        \"ui_spawn_button requires integration with Bevy World (not available in this context)\",\n    ))\n}\n\n#[cfg(feature = \"bevy-integration\")]\nfn ui_spawn_text(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    use crate::error::FusabiError;\n    Err(FusabiError::runtime_error(\n        \"ui_spawn_text requires integration with Bevy World (not available in this context)\",\n    ))\n}\n\n#[cfg(feature = \"bevy-integration\")]\nfn ui_spawn_container(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    use crate::error::FusabiError;\n    Err(FusabiError::runtime_error(\n        \"ui_spawn_container requires integration with Bevy World (not available in this context)\",\n    ))\n}\n\n#[cfg(feature = \"bevy-integration\")]\nfn ui_set_position(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    use crate::error::FusabiError;\n    Err(FusabiError::runtime_error(\n        \"ui_set_position requires integration with Bevy World (not available in this context)\",\n    ))\n}\n\n#[cfg(feature = \"bevy-integration\")]\nfn ui_set_size(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    use crate::error::FusabiError;\n    Err(FusabiError::runtime_error(\n        \"ui_set_size requires integration with Bevy World (not available in this context)\",\n    ))\n}\n\n#[cfg(feature = \"bevy-integration\")]\nfn ui_set_color(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    use crate::error::FusabiError;\n    Err(FusabiError::runtime_error(\n        \"ui_set_color requires integration with Bevy World (not available in this context)\",\n    ))\n}\n\n#[cfg(feature = \"bevy-integration\")]\n/// Resource to hold the Fusabi interpreter\n#[derive(Resource)]\npub struct FusabiInterpreter {\n    interpreter: crate::interpreter::Interpreter,\n}\n\n#[cfg(feature = \"bevy-integration\")]\nimpl FusabiInterpreter {\n    pub fn new() -\u003e Self {\n        let mut interpreter = crate::interpreter::Interpreter::new();\n        // Load Bevy-specific standard library\n        load_bevy_stdlib(interpreter.env_mut());\n        Self { interpreter }\n    }\n\n    pub fn eval(\u0026mut self, code: \u0026str) -\u003e Result\u003cValue\u003e {\n        let module = crate::parser::parse_module(code)?;\n        self.interpreter.eval_module(\u0026module)\n    }\n\n    pub fn interpreter(\u0026self) -\u003e \u0026crate::interpreter::Interpreter {\n        \u0026self.interpreter\n    }\n\n    pub fn interpreter_mut(\u0026mut self) -\u003e \u0026mut crate::interpreter::Interpreter {\n        \u0026mut self.interpreter\n    }\n}\n\n#[cfg(feature = \"bevy-integration\")]\nimpl Default for FusabiInterpreter {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(feature = \"bevy-integration\")]\n/// Plugin to integrate Fusabi interpreter with Bevy\npub struct FusabiPlugin;\n\n#[cfg(feature = \"bevy-integration\")]\nimpl Plugin for FusabiPlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        app.insert_resource(FusabiInterpreter::new())\n            .add_systems(Update, hot_reload_system);\n    }\n}\n\n#[cfg(feature = \"bevy-integration\")]\n/// Event for script reloading\n#[derive(Event)]\npub struct ScriptReloadEvent {\n    pub path: std::path::PathBuf,\n    pub content: String,\n}\n\n#[cfg(feature = \"bevy-integration\")]\n/// System to handle hot-reloading of scripts\nfn hot_reload_system(\n    mut events: EventReader\u003cScriptReloadEvent\u003e,\n    mut interpreter: ResMut\u003cFusabiInterpreter\u003e,\n) {\n    for event in events.read() {\n        match interpreter.eval(\u0026event.content) {\n            Ok(value) =\u003e {\n                info!(\"Reloaded script {:?}: {}\", event.path, value);\n            }\n            Err(e) =\u003e {\n                error!(\"Failed to reload script {:?}: {}\", event.path, e);\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","cache.rs"],"content":"use std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::time::SystemTime;\nuse crate::ast::Module;\n\n/// Cache for parsed AST modules to avoid re-parsing unchanged files\n#[derive(Debug)]\npub struct AstCache {\n    cache: HashMap\u003cPathBuf, CacheEntry\u003e,\n}\n\n#[derive(Debug, Clone)]\nstruct CacheEntry {\n    module: Module,\n    modified_time: SystemTime,\n    content_hash: u64,\n}\n\nimpl AstCache {\n    pub fn new() -\u003e Self {\n        Self {\n            cache: HashMap::new(),\n        }\n    }\n\n    /// Get a cached module if it exists and is still valid\n    pub fn get(\u0026self, path: \u0026PathBuf, modified_time: SystemTime, content_hash: u64) -\u003e Option\u003c\u0026Module\u003e {\n        self.cache.get(path).and_then(|entry| {\n            if entry.modified_time == modified_time \u0026\u0026 entry.content_hash == content_hash {\n                Some(\u0026entry.module)\n            } else {\n                None\n            }\n        })\n    }\n\n    /// Insert a parsed module into the cache\n    pub fn insert(\u0026mut self, path: PathBuf, module: Module, modified_time: SystemTime, content_hash: u64) {\n        self.cache.insert(\n            path,\n            CacheEntry {\n                module,\n                modified_time,\n                content_hash,\n            },\n        );\n    }\n\n    /// Remove a cached module\n    pub fn remove(\u0026mut self, path: \u0026PathBuf) -\u003e Option\u003cModule\u003e {\n        self.cache.remove(path).map(|entry| entry.module)\n    }\n\n    /// Clear the entire cache\n    pub fn clear(\u0026mut self) {\n        self.cache.clear();\n    }\n\n    /// Get the number of cached modules\n    pub fn len(\u0026self) -\u003e usize {\n        self.cache.len()\n    }\n\n    /// Check if the cache is empty\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.cache.is_empty()\n    }\n\n    /// Get cache statistics\n    pub fn stats(\u0026self) -\u003e CacheStats {\n        CacheStats {\n            entries: self.cache.len(),\n            paths: self.cache.keys().cloned().collect(),\n        }\n    }\n}\n\nimpl Default for AstCache {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Cache statistics\n#[derive(Debug, Clone)]\npub struct CacheStats {\n    pub entries: usize,\n    pub paths: Vec\u003cPathBuf\u003e,\n}\n\n/// Simple hash function for content\npub fn hash_content(content: \u0026str) -\u003e u64 {\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    let mut hasher = DefaultHasher::new();\n    content.hash(\u0026mut hasher);\n    hasher.finish()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::ast::Module;\n\n    #[test]\n    fn test_cache_basic() {\n        let mut cache = AstCache::new();\n        let path = PathBuf::from(\"test.fsx\");\n        let module = Module::empty();\n        let time = SystemTime::now();\n        let hash = 12345;\n\n        cache.insert(path.clone(), module.clone(), time, hash);\n        assert_eq!(cache.len(), 1);\n\n        let cached = cache.get(\u0026path, time, hash);\n        assert!(cached.is_some());\n\n        // Different hash should miss\n        let cached = cache.get(\u0026path, time, 99999);\n        assert!(cached.is_none());\n    }\n\n    #[test]\n    fn test_hash_content() {\n        let content1 = \"let x = 42\";\n        let content2 = \"let x = 42\";\n        let content3 = \"let y = 99\";\n\n        assert_eq!(hash_content(content1), hash_content(content2));\n        assert_ne!(hash_content(content1), hash_content(content3));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","environment.rs"],"content":"use indexmap::IndexMap;\nuse crate::ast::Value;\nuse crate::error::{FusabiError, Result};\n\n/// Environment for variable bindings (supports lexical scoping)\n#[derive(Debug, Clone)]\npub struct Environment {\n    scopes: Vec\u003cIndexMap\u003cString, Value\u003e\u003e,\n}\n\nimpl Environment {\n    pub fn new() -\u003e Self {\n        Self {\n            scopes: vec![IndexMap::new()],\n        }\n    }\n\n    /// Push a new scope\n    pub fn push_scope(\u0026mut self) {\n        self.scopes.push(IndexMap::new());\n    }\n\n    /// Pop the current scope\n    pub fn pop_scope(\u0026mut self) {\n        if self.scopes.len() \u003e 1 {\n            self.scopes.pop();\n        }\n    }\n\n    /// Define a variable in the current scope\n    pub fn define(\u0026mut self, name: String, value: Value) {\n        if let Some(scope) = self.scopes.last_mut() {\n            scope.insert(name, value);\n        }\n    }\n\n    /// Get a variable's value (searches from innermost to outermost scope)\n    pub fn get(\u0026self, name: \u0026str) -\u003e Result\u003cValue\u003e {\n        for scope in self.scopes.iter().rev() {\n            if let Some(value) = scope.get(name) {\n                return Ok(value.clone());\n            }\n        }\n        Err(FusabiError::UndefinedVariable(name.to_string()))\n    }\n\n    /// Check if a variable exists\n    pub fn contains(\u0026self, name: \u0026str) -\u003e bool {\n        self.scopes.iter().rev().any(|scope| scope.contains_key(name))\n    }\n\n    /// Update an existing variable (searches from innermost to outermost)\n    pub fn set(\u0026mut self, name: \u0026str, value: Value) -\u003e Result\u003c()\u003e {\n        for scope in self.scopes.iter_mut().rev() {\n            if scope.contains_key(name) {\n                scope.insert(name.to_string(), value);\n                return Ok(());\n            }\n        }\n        Err(FusabiError::UndefinedVariable(name.to_string()))\n    }\n}\n\nimpl Default for Environment {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","error.rs"],"content":"use std::fmt;\nuse thiserror::Error;\n\n/// Errors that can occur during parsing, interpretation, or runtime\n#[derive(Debug, Error)]\npub enum FusabiError {\n    #[error(\"Parse error at line {line}, column {col}: {message}\")]\n    ParseError {\n        line: u32,\n        col: u32,\n        message: String,\n    },\n\n    #[error(\"Type error: expected {expected}, got {got}\")]\n    TypeError { expected: String, got: String },\n\n    #[error(\"Runtime error: {0}\")]\n    RuntimeError(String),\n\n    #[error(\"Undefined variable: {0}\")]\n    UndefinedVariable(String),\n\n    #[error(\"Undefined function: {0}\")]\n    UndefinedFunction(String),\n\n    #[error(\"Arity mismatch: expected {expected} arguments, got {got}\")]\n    ArityMismatch { expected: usize, got: usize },\n\n    #[error(\"Division by zero\")]\n    DivisionByZero,\n\n    #[error(\"Index out of bounds: {index} (length: {length})\")]\n    IndexOutOfBounds { index: usize, length: usize },\n\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"File watcher error: {0}\")]\n    WatcherError(String),\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, FusabiError\u003e;\n\nimpl FusabiError {\n    pub fn parse_error(line: u32, col: u32, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::ParseError {\n            line,\n            col,\n            message: message.into(),\n        }\n    }\n\n    pub fn type_error(expected: impl Into\u003cString\u003e, got: impl Into\u003cString\u003e) -\u003e Self {\n        Self::TypeError {\n            expected: expected.into(),\n            got: got.into(),\n        }\n    }\n\n    pub fn runtime_error(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::RuntimeError(message.into())\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","interpreter.rs"],"content":"use std::collections::HashMap;\nuse crate::ast::*;\nuse crate::environment::Environment;\nuse crate::error::{FusabiError, Result};\n\n/// The Fusabi interpreter\npub struct Interpreter {\n    env: Environment,\n}\n\nimpl Interpreter {\n    pub fn new() -\u003e Self {\n        let mut interpreter = Self {\n            env: Environment::new(),\n        };\n\n        // Load standard library\n        crate::stdlib::load_stdlib(\u0026mut interpreter.env);\n\n        interpreter\n    }\n\n    /// Evaluate a module (list of statements)\n    pub fn eval_module(\u0026mut self, module: \u0026Module) -\u003e Result\u003cValue\u003e {\n        let mut last_value = Value::Nil;\n\n        for statement in \u0026module.statements {\n            last_value = self.eval_statement(statement)?;\n        }\n\n        Ok(last_value)\n    }\n\n    /// Evaluate a single statement\n    pub fn eval_statement(\u0026mut self, statement: \u0026Statement) -\u003e Result\u003cValue\u003e {\n        match statement {\n            Statement::Expr(expr) =\u003e self.eval_expr(expr),\n            Statement::Let { name, value } =\u003e {\n                let val = self.eval_expr(value)?;\n                self.env.define(name.clone(), val.clone());\n                Ok(val)\n            }\n            Statement::Function { name, params, body } =\u003e {\n                let func = Value::Function(Function {\n                    name: name.clone(),\n                    params: params.clone(),\n                    body: FunctionBody::Expr(body.clone()),\n                });\n                self.env.define(name.clone(), func.clone());\n                Ok(func)\n            }\n            Statement::Return(expr) =\u003e {\n                if let Some(expr) = expr {\n                    self.eval_expr(expr)\n                } else {\n                    Ok(Value::Nil)\n                }\n            }\n        }\n    }\n\n    /// Evaluate an expression\n    pub fn eval_expr(\u0026mut self, expr: \u0026Expr) -\u003e Result\u003cValue\u003e {\n        match expr {\n            Expr::Literal(value) =\u003e Ok(value.clone()),\n\n            Expr::Variable(name) =\u003e self.env.get(name),\n\n            Expr::BinOp { op, left, right } =\u003e {\n                let left_val = self.eval_expr(left)?;\n                let right_val = self.eval_expr(right)?;\n                self.eval_binop(*op, left_val, right_val)\n            }\n\n            Expr::UnaryOp { op, expr } =\u003e {\n                let val = self.eval_expr(expr)?;\n                self.eval_unaryop(*op, val)\n            }\n\n            Expr::Call { func, args } =\u003e {\n                let func_val = self.eval_expr(func)?;\n                let arg_vals: Result\u003cVec\u003c_\u003e\u003e = args.iter().map(|a| self.eval_expr(a)).collect();\n                let arg_vals = arg_vals?;\n                self.call_function(func_val, arg_vals)\n            }\n\n            Expr::Lambda { params, body } =\u003e {\n                Ok(Value::Function(Function {\n                    name: \"\u003clambda\u003e\".to_string(),\n                    params: params.clone(),\n                    body: FunctionBody::Expr(body.clone()),\n                }))\n            }\n\n            Expr::Let { name, value, body } =\u003e {\n                let val = self.eval_expr(value)?;\n                self.env.push_scope();\n                self.env.define(name.clone(), val);\n                let result = self.eval_expr(body);\n                self.env.pop_scope();\n                result\n            }\n\n            Expr::If { condition, then_expr, else_expr } =\u003e {\n                let cond_val = self.eval_expr(condition)?;\n                if cond_val.is_truthy() {\n                    self.eval_expr(then_expr)\n                } else if let Some(else_expr) = else_expr {\n                    self.eval_expr(else_expr)\n                } else {\n                    Ok(Value::Nil)\n                }\n            }\n\n            Expr::ListLiteral(exprs) =\u003e {\n                let values: Result\u003cVec\u003c_\u003e\u003e = exprs.iter().map(|e| self.eval_expr(e)).collect();\n                Ok(Value::List(values?))\n            }\n\n            Expr::MapLiteral(entries) =\u003e {\n                let mut map = HashMap::new();\n                for (key, expr) in entries {\n                    let value = self.eval_expr(expr)?;\n                    map.insert(key.clone(), value);\n                }\n                Ok(Value::Map(map))\n            }\n\n            Expr::Index { expr, index } =\u003e {\n                let val = self.eval_expr(expr)?;\n                let idx = self.eval_expr(index)?;\n                self.eval_index(val, idx)\n            }\n\n            Expr::Field { expr, field } =\u003e {\n                let val = self.eval_expr(expr)?;\n                match val {\n                    Value::Map(map) =\u003e {\n                        map.get(field)\n                            .cloned()\n                            .ok_or_else(|| FusabiError::runtime_error(format!(\"Field not found: {}\", field)))\n                    }\n                    _ =\u003e Err(FusabiError::type_error(\"map\", val.type_name())),\n                }\n            }\n\n            Expr::Block(statements) =\u003e {\n                self.env.push_scope();\n                let mut last_value = Value::Nil;\n                for statement in statements {\n                    last_value = self.eval_statement(statement)?;\n                }\n                self.env.pop_scope();\n                Ok(last_value)\n            }\n        }\n    }\n\n    fn eval_binop(\u0026mut self, op: BinOp, left: Value, right: Value) -\u003e Result\u003cValue\u003e {\n        use BinOp::*;\n        match (op, \u0026left, \u0026right) {\n            // Arithmetic\n            (Add, Value::Int(l), Value::Int(r)) =\u003e Ok(Value::Int(l + r)),\n            (Add, Value::Float(l), Value::Float(r)) =\u003e Ok(Value::Float(l + r)),\n            (Add, Value::Int(l), Value::Float(r)) =\u003e Ok(Value::Float(*l as f64 + r)),\n            (Add, Value::Float(l), Value::Int(r)) =\u003e Ok(Value::Float(l + *r as f64)),\n            (Add, Value::String(l), Value::String(r)) =\u003e Ok(Value::String(format!(\"{}{}\", l, r))),\n\n            (Sub, Value::Int(l), Value::Int(r)) =\u003e Ok(Value::Int(l - r)),\n            (Sub, Value::Float(l), Value::Float(r)) =\u003e Ok(Value::Float(l - r)),\n            (Sub, Value::Int(l), Value::Float(r)) =\u003e Ok(Value::Float(*l as f64 - r)),\n            (Sub, Value::Float(l), Value::Int(r)) =\u003e Ok(Value::Float(l - *r as f64)),\n\n            (Mul, Value::Int(l), Value::Int(r)) =\u003e Ok(Value::Int(l * r)),\n            (Mul, Value::Float(l), Value::Float(r)) =\u003e Ok(Value::Float(l * r)),\n            (Mul, Value::Int(l), Value::Float(r)) =\u003e Ok(Value::Float(*l as f64 * r)),\n            (Mul, Value::Float(l), Value::Int(r)) =\u003e Ok(Value::Float(l * *r as f64)),\n\n            (Div, Value::Int(l), Value::Int(r)) =\u003e {\n                if *r == 0 {\n                    Err(FusabiError::DivisionByZero)\n                } else {\n                    Ok(Value::Int(l / r))\n                }\n            }\n            (Div, Value::Float(l), Value::Float(r)) =\u003e Ok(Value::Float(l / r)),\n            (Div, Value::Int(l), Value::Float(r)) =\u003e Ok(Value::Float(*l as f64 / r)),\n            (Div, Value::Float(l), Value::Int(r)) =\u003e Ok(Value::Float(l / *r as f64)),\n\n            (Mod, Value::Int(l), Value::Int(r)) =\u003e {\n                if *r == 0 {\n                    Err(FusabiError::DivisionByZero)\n                } else {\n                    Ok(Value::Int(l % r))\n                }\n            }\n\n            // Comparison\n            (Eq, _, _) =\u003e Ok(Value::Bool(left == right)),\n            (Ne, _, _) =\u003e Ok(Value::Bool(left != right)),\n\n            (Lt, Value::Int(l), Value::Int(r)) =\u003e Ok(Value::Bool(l \u003c r)),\n            (Lt, Value::Float(l), Value::Float(r)) =\u003e Ok(Value::Bool(l \u003c r)),\n            (Le, Value::Int(l), Value::Int(r)) =\u003e Ok(Value::Bool(l \u003c= r)),\n            (Le, Value::Float(l), Value::Float(r)) =\u003e Ok(Value::Bool(l \u003c= r)),\n            (Gt, Value::Int(l), Value::Int(r)) =\u003e Ok(Value::Bool(l \u003e r)),\n            (Gt, Value::Float(l), Value::Float(r)) =\u003e Ok(Value::Bool(l \u003e r)),\n            (Ge, Value::Int(l), Value::Int(r)) =\u003e Ok(Value::Bool(l \u003e= r)),\n            (Ge, Value::Float(l), Value::Float(r)) =\u003e Ok(Value::Bool(l \u003e= r)),\n\n            // Logical\n            (And, _, _) =\u003e Ok(Value::Bool(left.is_truthy() \u0026\u0026 right.is_truthy())),\n            (Or, _, _) =\u003e Ok(Value::Bool(left.is_truthy() || right.is_truthy())),\n\n            _ =\u003e Err(FusabiError::runtime_error(format!(\n                \"Invalid binary operation: {:?} {:?} {:?}\",\n                left.type_name(),\n                op,\n                right.type_name()\n            ))),\n        }\n    }\n\n    fn eval_unaryop(\u0026mut self, op: UnaryOp, val: Value) -\u003e Result\u003cValue\u003e {\n        match (op, val) {\n            (UnaryOp::Neg, Value::Int(i)) =\u003e Ok(Value::Int(-i)),\n            (UnaryOp::Neg, Value::Float(f)) =\u003e Ok(Value::Float(-f)),\n            (UnaryOp::Not, v) =\u003e Ok(Value::Bool(!v.is_truthy())),\n            _ =\u003e Err(FusabiError::runtime_error(\"Invalid unary operation\")),\n        }\n    }\n\n    fn eval_index(\u0026mut self, val: Value, idx: Value) -\u003e Result\u003cValue\u003e {\n        match (val, idx) {\n            (Value::List(list), Value::Int(i)) =\u003e {\n                if i \u003c 0 || i as usize \u003e= list.len() {\n                    Err(FusabiError::IndexOutOfBounds {\n                        index: i as usize,\n                        length: list.len(),\n                    })\n                } else {\n                    Ok(list[i as usize].clone())\n                }\n            }\n            (Value::Map(map), Value::String(key)) =\u003e {\n                map.get(\u0026key)\n                    .cloned()\n                    .ok_or_else(|| FusabiError::runtime_error(format!(\"Key not found: {}\", key)))\n            }\n            _ =\u003e Err(FusabiError::runtime_error(\"Invalid index operation\")),\n        }\n    }\n\n    fn call_function(\u0026mut self, func: Value, args: Vec\u003cValue\u003e) -\u003e Result\u003cValue\u003e {\n        match func {\n            Value::Function(Function { name: _, params, body }) =\u003e {\n                // Check arity\n                if params.len() != args.len() {\n                    return Err(FusabiError::ArityMismatch {\n                        expected: params.len(),\n                        got: args.len(),\n                    });\n                }\n\n                match body {\n                    FunctionBody::Expr(expr) =\u003e {\n                        // Create new scope and bind parameters\n                        self.env.push_scope();\n                        for (param, arg) in params.iter().zip(args.iter()) {\n                            self.env.define(param.clone(), arg.clone());\n                        }\n                        let result = self.eval_expr(\u0026expr);\n                        self.env.pop_scope();\n                        result\n                    }\n                    FunctionBody::Native(native) =\u003e {\n                        // Call native function\n                        if native.arity != args.len() {\n                            return Err(FusabiError::ArityMismatch {\n                                expected: native.arity,\n                                got: args.len(),\n                            });\n                        }\n                        (native.func)(\u0026args)\n                    }\n                }\n            }\n            _ =\u003e Err(FusabiError::type_error(\"function\", func.type_name())),\n        }\n    }\n\n    /// Get the environment (for testing/debugging)\n    pub fn env(\u0026self) -\u003e \u0026Environment {\n        \u0026self.env\n    }\n\n    /// Get mutable environment (for stdlib loading)\n    pub fn env_mut(\u0026mut self) -\u003e \u0026mut Environment {\n        \u0026mut self.env\n    }\n}\n\nimpl Default for Interpreter {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::parser::parse_module;\n\n    fn eval(code: \u0026str) -\u003e Result\u003cValue\u003e {\n        let module = parse_module(code)?;\n        let mut interp = Interpreter::new();\n        interp.eval_module(\u0026module)\n    }\n\n    #[test]\n    fn test_arithmetic() {\n        assert_eq!(eval(\"2 + 3\").unwrap(), Value::Int(5));\n        assert_eq!(eval(\"10 - 4\").unwrap(), Value::Int(6));\n        assert_eq!(eval(\"3 * 4\").unwrap(), Value::Int(12));\n        assert_eq!(eval(\"15 / 3\").unwrap(), Value::Int(5));\n    }\n\n    #[test]\n    fn test_comparison() {\n        assert_eq!(eval(\"5 \u003e 3\").unwrap(), Value::Bool(true));\n        assert_eq!(eval(\"5 \u003c 3\").unwrap(), Value::Bool(false));\n        assert_eq!(eval(\"5 == 5\").unwrap(), Value::Bool(true));\n    }\n\n    #[test]\n    fn test_let_binding() {\n        assert_eq!(eval(\"let x = 42 in x\").unwrap(), Value::Int(42));\n        assert_eq!(eval(\"let x = 10 in let y = 20 in x + y\").unwrap(), Value::Int(30));\n    }\n\n    #[test]\n    fn test_if_expr() {\n        assert_eq!(eval(\"if true then 1 else 2\").unwrap(), Value::Int(1));\n        assert_eq!(eval(\"if false then 1 else 2\").unwrap(), Value::Int(2));\n    }\n\n    #[test]\n    fn test_function() {\n        let code = r#\"\n            let add x y = x + y\n            add(10, 20)\n        \"#;\n        assert_eq!(eval(code).unwrap(), Value::Int(30));\n    }\n\n    #[test]\n    fn test_lambda() {\n        let code = \"(fun x -\u003e x + 1)(41)\";\n        assert_eq!(eval(code).unwrap(), Value::Int(42));\n    }\n\n    #[test]\n    fn test_list() {\n        let code = \"[1, 2, 3]\";\n        if let Value::List(list) = eval(code).unwrap() {\n            assert_eq!(list.len(), 3);\n        } else {\n            panic!(\"Expected list\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","lib.rs"],"content":"// fusabi-interpreter: The Script runtime for the Client\n//\n// A hot-reloadable interpreter for .fsx scripts (F# subset) that enables:\n// - Custom UI layouts and themes\n// - Interactive overlays (Vimium-style, Spacemacs-like menus)\n// - Dynamic key bindings\n// - Runtime customization without Rust recompilation\n//\n// Features:\n// - Fast parsing (\u003c10ms for 1000 LOC)\n// - Hot-reload in \u003c100ms\n// - Rich standard library (50+ functions)\n// - Bevy integration for UI entity spawning\n// - File watcher for automatic reloading\n// - AST caching for performance\n\npub mod ast;\npub mod cache;\npub mod environment;\npub mod error;\npub mod interpreter;\npub mod parser;\npub mod stdlib;\npub mod watcher;\n\n#[cfg(feature = \"bevy-integration\")]\npub mod bevy_integration;\n\n// Re-exports for convenience\npub use ast::{Expr, Function, Module, Statement, Value};\npub use cache::AstCache;\npub use environment::Environment;\npub use error::{FusabiError, Result};\npub use interpreter::Interpreter;\npub use parser::parse_module;\npub use watcher::ScriptWatcher;\n\n#[cfg(feature = \"bevy-integration\")]\npub use bevy_integration::{FusabiInterpreter, FusabiPlugin, ScriptReloadEvent};\n\n/// Quick evaluation of a script string\npub fn eval(code: \u0026str) -\u003e Result\u003cValue\u003e {\n    let module = parse_module(code)?;\n    let mut interpreter = Interpreter::new();\n    interpreter.eval_module(\u0026module)\n}\n\n/// Parse and validate a script without executing it\npub fn parse(code: \u0026str) -\u003e Result\u003cModule\u003e {\n    parse_module(code)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_eval_simple() {\n        assert_eq!(eval(\"42\").unwrap(), Value::Int(42));\n        assert_eq!(eval(\"2 + 3\").unwrap(), Value::Int(5));\n        assert_eq!(eval(r#\"\"hello\"\"#).unwrap(), Value::String(\"hello\".to_string()));\n    }\n\n    #[test]\n    fn test_eval_function() {\n        let code = r#\"\n            let add x y = x + y\n            add(10, 20)\n        \"#;\n        assert_eq!(eval(code).unwrap(), Value::Int(30));\n    }\n\n    #[test]\n    fn test_eval_stdlib() {\n        assert_eq!(eval(\"abs(-42)\").unwrap(), Value::Int(42));\n        assert_eq!(eval(r#\"strlen(\"hello\")\"#).unwrap(), Value::Int(5));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","parser.rs"],"content":"use nom::{\n    branch::alt,\n    bytes::complete::{tag, take_until, take_while, take_while1},\n    character::complete::{alpha1, alphanumeric1, char, digit1, multispace0, multispace1, one_of},\n    combinator::{map, map_res, opt, recognize, value},\n    multi::{many0, many1, separated_list0, separated_list1},\n    sequence::{delimited, pair, preceded, terminated, tuple},\n    IResult,\n};\nuse nom_locate::LocatedSpan;\n\nuse crate::ast::*;\nuse crate::error::{FusabiError, Result};\n\npub type Span\u003c'a\u003e = LocatedSpan\u003c\u0026'a str\u003e;\n\n/// Parse a complete module/script\npub fn parse_module(input: \u0026str) -\u003e Result\u003cModule\u003e {\n    let span = Span::new(input);\n    match module(span) {\n        Ok((_, module)) =\u003e Ok(module),\n        Err(nom::Err::Error(e)) | Err(nom::Err::Failure(e)) =\u003e {\n            let line = e.input.location_line();\n            let col = e.input.get_column();\n            Err(FusabiError::parse_error(\n                line,\n                col as u32,\n                format!(\"Failed to parse: {:?}\", e),\n            ))\n        }\n        Err(nom::Err::Incomplete(_)) =\u003e Err(FusabiError::parse_error(0, 0, \"Incomplete input\")),\n    }\n}\n\n// Whitespace and comments\nfn ws\u003c'a, F, O\u003e(inner: F) -\u003e impl FnMut(Span\u003c'a\u003e) -\u003e IResult\u003cSpan\u003c'a\u003e, O\u003e\nwhere\n    F: FnMut(Span\u003c'a\u003e) -\u003e IResult\u003cSpan\u003c'a\u003e, O\u003e,\n{\n    delimited(multispace0, inner, multispace0)\n}\n\nfn comment(input: Span) -\u003e IResult\u003cSpan, ()\u003e {\n    value(\n        (),\n        pair(tag(\"//\"), take_while(|c| c != '\\n')),\n    )(input)\n}\n\nfn ws_or_comment(input: Span) -\u003e IResult\u003cSpan, ()\u003e {\n    value(\n        (),\n        many0(alt((value((), multispace1), comment))),\n    )(input)\n}\n\n// Identifiers (excluding keywords)\nfn identifier(input: Span) -\u003e IResult\u003cSpan, String\u003e {\n    let (input, ident) = map(\n        recognize(pair(\n            alt((alpha1, tag(\"_\"))),\n            many0(alt((alphanumeric1, tag(\"_\")))),\n        )),\n        |s: Span| s.fragment().to_string(),\n    )(input)?;\n\n    // Reject keywords\n    match ident.as_str() {\n        \"let\" | \"in\" | \"if\" | \"then\" | \"else\" | \"fun\" | \"true\" | \"false\" | \"nil\" =\u003e {\n            Err(nom::Err::Error(nom::error::Error::new(\n                input,\n                nom::error::ErrorKind::Tag,\n            )))\n        }\n        _ =\u003e Ok((input, ident)),\n    }\n}\n\n// Literals\nfn int_literal(input: Span) -\u003e IResult\u003cSpan, Value\u003e {\n    map_res(\n        recognize(pair(opt(char('-')), digit1)),\n        |s: Span| s.fragment().parse::\u003ci64\u003e().map(Value::Int),\n    )(input)\n}\n\nfn float_literal(input: Span) -\u003e IResult\u003cSpan, Value\u003e {\n    map_res(\n        recognize(tuple((\n            opt(char('-')),\n            digit1,\n            char('.'),\n            digit1,\n        ))),\n        |s: Span| s.fragment().parse::\u003cf64\u003e().map(Value::Float),\n    )(input)\n}\n\nfn bool_literal(input: Span) -\u003e IResult\u003cSpan, Value\u003e {\n    alt((\n        value(Value::Bool(true), tag(\"true\")),\n        value(Value::Bool(false), tag(\"false\")),\n    ))(input)\n}\n\nfn string_literal(input: Span) -\u003e IResult\u003cSpan, Value\u003e {\n    delimited(\n        char('\"'),\n        map(\n            take_while(|c| c != '\"'),\n            |s: Span| Value::String(s.fragment().to_string()),\n        ),\n        char('\"'),\n    )(input)\n}\n\nfn nil_literal(input: Span) -\u003e IResult\u003cSpan, Value\u003e {\n    value(Value::Nil, tag(\"nil\"))(input)\n}\n\nfn literal(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    map(\n        alt((\n            float_literal,\n            int_literal,\n            bool_literal,\n            string_literal,\n            nil_literal,\n        )),\n        Expr::Literal,\n    )(input)\n}\n\n// List literal\nfn list_literal(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    map(\n        delimited(\n            ws(char('[')),\n            separated_list0(ws(char(',')), expr),\n            ws(char(']')),\n        ),\n        Expr::ListLiteral,\n    )(input)\n}\n\n// Map literal\nfn map_entry(input: Span) -\u003e IResult\u003cSpan, (String, Expr)\u003e {\n    let (input, key) = ws(identifier)(input)?;\n    let (input, _) = ws(char('='))(input)?;\n    let (input, value) = expr(input)?;\n    Ok((input, (key, value)))\n}\n\nfn map_literal(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    map(\n        delimited(\n            ws(char('{')),\n            separated_list0(ws(char(';')), map_entry),\n            ws(char('}')),\n        ),\n        Expr::MapLiteral,\n    )(input)\n}\n\n// Variable\nfn variable(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    map(identifier, Expr::Variable)(input)\n}\n\n// Lambda: fun x y -\u003e expr\nfn lambda(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, _) = ws(tag(\"fun\"))(input)?;\n    let (input, params) = many1(ws(identifier))(input)?;\n    let (input, _) = ws(tag(\"-\u003e\"))(input)?;\n    let (input, body) = expr(input)?;\n    Ok((\n        input,\n        Expr::Lambda {\n            params,\n            body: Box::new(body),\n        },\n    ))\n}\n\n// Let binding: let x = expr in body\nfn let_expr(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, _) = ws(tag(\"let\"))(input)?;\n    let (input, name) = ws(identifier)(input)?;\n    let (input, _) = ws(char('='))(input)?;\n    let (input, value) = ws(expr)(input)?;\n    let (input, _) = ws(tag(\"in\"))(input)?;\n    let (input, body) = expr(input)?;\n    Ok((\n        input,\n        Expr::Let {\n            name,\n            value: Box::new(value),\n            body: Box::new(body),\n        },\n    ))\n}\n\n// If expression: if cond then expr else expr\nfn if_expr(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, _) = ws(tag(\"if\"))(input)?;\n    let (input, condition) = ws(expr)(input)?;\n    let (input, _) = ws(tag(\"then\"))(input)?;\n    let (input, then_expr) = ws(expr)(input)?;\n    let (input, else_expr) = opt(preceded(ws(tag(\"else\")), expr))(input)?;\n    Ok((\n        input,\n        Expr::If {\n            condition: Box::new(condition),\n            then_expr: Box::new(then_expr),\n            else_expr: else_expr.map(Box::new),\n        },\n    ))\n}\n\n// Parenthesized expression\nfn paren_expr(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    delimited(ws(char('(')), expr, ws(char(')')))(input)\n}\n\n// Primary expressions (atoms)\nfn primary(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    alt((\n        literal,\n        lambda,\n        let_expr,\n        if_expr,\n        list_literal,\n        map_literal,\n        paren_expr,\n        variable,\n    ))(input)\n}\n\n// Postfix operations (function call, indexing, field access)\nfn postfix(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, mut result_expr) = primary(input)?;\n\n    let mut remaining = input;\n    loop {\n        // Try function call\n        if let Ok((input2, args)) = delimited(\n            ws(char('(')),\n            separated_list0(ws(char(',')), |i| expr(i)),\n            ws(char(')')),\n        )(remaining)\n        {\n            result_expr = Expr::Call {\n                func: Box::new(result_expr),\n                args,\n            };\n            remaining = input2;\n            continue;\n        }\n\n        // Try indexing\n        if let Ok((input2, index)) = delimited(ws(char('[')), |i| expr(i), ws(char(']')))(remaining) {\n            result_expr = Expr::Index {\n                expr: Box::new(result_expr),\n                index: Box::new(index),\n            };\n            remaining = input2;\n            continue;\n        }\n\n        // Try field access\n        if let Ok((input2, field)) = preceded(ws(char('.')), identifier)(remaining) {\n            result_expr = Expr::Field {\n                expr: Box::new(result_expr),\n                field,\n            };\n            remaining = input2;\n            continue;\n        }\n\n        break;\n    }\n\n    Ok((remaining, result_expr))\n}\n\n// Unary operations\nfn unary(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    alt((\n        map(\n            pair(ws(char('-')), unary),\n            |(_, e)| Expr::UnaryOp {\n                op: UnaryOp::Neg,\n                expr: Box::new(e),\n            },\n        ),\n        map(\n            pair(ws(char('!')), unary),\n            |(_, e)| Expr::UnaryOp {\n                op: UnaryOp::Not,\n                expr: Box::new(e),\n            },\n        ),\n        postfix,\n    ))(input)\n}\n\n// Binary operations (with precedence)\nfn binary_op(op_chars: \u0026str, op: BinOp) -\u003e impl Fn(Span) -\u003e IResult\u003cSpan, BinOp\u003e + '_ {\n    move |input| value(op, ws(tag(op_chars)))(input)\n}\n\nfn multiplicative(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, left) = unary(input)?;\n    let (input, ops_and_exprs) = many0(pair(\n        alt((\n            binary_op(\"*\", BinOp::Mul),\n            binary_op(\"/\", BinOp::Div),\n            binary_op(\"%\", BinOp::Mod),\n        )),\n        unary,\n    ))(input)?;\n\n    Ok((\n        input,\n        ops_and_exprs\n            .into_iter()\n            .fold(left, |acc, (op, right)| Expr::BinOp {\n                op,\n                left: Box::new(acc),\n                right: Box::new(right),\n            }),\n    ))\n}\n\nfn additive(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, left) = multiplicative(input)?;\n    let (input, ops_and_exprs) = many0(pair(\n        alt((\n            binary_op(\"+\", BinOp::Add),\n            binary_op(\"-\", BinOp::Sub),\n        )),\n        multiplicative,\n    ))(input)?;\n\n    Ok((\n        input,\n        ops_and_exprs\n            .into_iter()\n            .fold(left, |acc, (op, right)| Expr::BinOp {\n                op,\n                left: Box::new(acc),\n                right: Box::new(right),\n            }),\n    ))\n}\n\nfn comparison(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, left) = additive(input)?;\n    let (input, op_and_expr) = opt(pair(\n        alt((\n            binary_op(\"==\", BinOp::Eq),\n            binary_op(\"!=\", BinOp::Ne),\n            binary_op(\"\u003c=\", BinOp::Le),\n            binary_op(\"\u003c\", BinOp::Lt),\n            binary_op(\"\u003e=\", BinOp::Ge),\n            binary_op(\"\u003e\", BinOp::Gt),\n        )),\n        additive,\n    ))(input)?;\n\n    Ok((\n        input,\n        if let Some((op, right)) = op_and_expr {\n            Expr::BinOp {\n                op,\n                left: Box::new(left),\n                right: Box::new(right),\n            }\n        } else {\n            left\n        },\n    ))\n}\n\nfn logical_and(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, left) = comparison(input)?;\n    let (input, rights) = many0(preceded(binary_op(\"\u0026\u0026\", BinOp::And), comparison))(input)?;\n\n    Ok((\n        input,\n        rights.into_iter().fold(left, |acc, right| Expr::BinOp {\n            op: BinOp::And,\n            left: Box::new(acc),\n            right: Box::new(right),\n        }),\n    ))\n}\n\nfn logical_or(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    let (input, left) = logical_and(input)?;\n    let (input, rights) = many0(preceded(binary_op(\"||\", BinOp::Or), logical_and))(input)?;\n\n    Ok((\n        input,\n        rights.into_iter().fold(left, |acc, right| Expr::BinOp {\n            op: BinOp::Or,\n            left: Box::new(acc),\n            right: Box::new(right),\n        }),\n    ))\n}\n\n// Top-level expression\nfn expr(input: Span) -\u003e IResult\u003cSpan, Expr\u003e {\n    logical_or(input)\n}\n\n// Statements\nfn let_statement(input: Span) -\u003e IResult\u003cSpan, Statement\u003e {\n    let (input, _) = ws(tag(\"let\"))(input)?;\n    let (input, name) = ws(identifier)(input)?;\n    let (input, _) = ws(char('='))(input)?;\n    let (input, value) = ws(expr)(input)?;\n    Ok((input, Statement::Let { name, value }))\n}\n\nfn function_statement(input: Span) -\u003e IResult\u003cSpan, Statement\u003e {\n    let (input, _) = ws(tag(\"let\"))(input)?;\n    let (input, name) = ws(identifier)(input)?;\n    let (input, params) = many1(ws(identifier))(input)?;\n    let (input, _) = ws(char('='))(input)?;\n    let (input, body) = ws(expr)(input)?;\n    Ok((\n        input,\n        Statement::Function {\n            name,\n            params,\n            body: Box::new(body),\n        },\n    ))\n}\n\nfn expr_statement(input: Span) -\u003e IResult\u003cSpan, Statement\u003e {\n    map(expr, Statement::Expr)(input)\n}\n\nfn statement(input: Span) -\u003e IResult\u003cSpan, Statement\u003e {\n    ws_or_comment(input)?;\n    let result = alt((function_statement, let_statement, expr_statement))(input);\n    result\n}\n\n// Module (top-level)\nfn module(input: Span) -\u003e IResult\u003cSpan, Module\u003e {\n    let (input, _) = ws_or_comment(input)?;\n    let (input, statements) = many0(terminated(statement, ws_or_comment))(input)?;\n    let (input, _) = ws_or_comment(input)?;\n    Ok((input, Module::new(statements)))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_int() {\n        let result = parse_module(\"42\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_string() {\n        let result = parse_module(r#\"\"hello\"\"#);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_let() {\n        let result = parse_module(\"let x = 42\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_function() {\n        let result = parse_module(\"let add x y = x + y\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_if() {\n        let result = parse_module(\"if true then 1 else 2\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_lambda() {\n        let result = parse_module(\"fun x -\u003e x + 1\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_list() {\n        let result = parse_module(\"[1, 2, 3]\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_map() {\n        let result = parse_module(\"{ x = 1; y = 2 }\");\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","stdlib.rs"],"content":"use crate::ast::{Function, FunctionBody, NativeFunction, Value};\nuse crate::environment::Environment;\nuse crate::error::{FusabiError, Result};\n\n/// Load the standard library into the environment\npub fn load_stdlib(env: \u0026mut Environment) {\n    // String functions\n    register_native(env, \"strlen\", 1, string_length);\n    register_native(env, \"substr\", 3, substring);\n    register_native(env, \"concat\", 2, concat);\n    register_native(env, \"to_upper\", 1, to_upper);\n    register_native(env, \"to_lower\", 1, to_lower);\n    register_native(env, \"trim\", 1, trim);\n    register_native(env, \"split\", 2, split);\n    register_native(env, \"join\", 2, join);\n\n    // List functions\n    register_native(env, \"length\", 1, list_length);\n    register_native(env, \"head\", 1, list_head);\n    register_native(env, \"tail\", 1, list_tail);\n    register_native(env, \"cons\", 2, list_cons);\n    register_native(env, \"append\", 2, list_append);\n    register_native(env, \"reverse\", 1, list_reverse);\n    register_native(env, \"nth\", 2, list_nth);\n    register_native(env, \"take\", 2, list_take);\n    register_native(env, \"drop\", 2, list_drop);\n\n    // Map functions\n    register_native(env, \"keys\", 1, map_keys);\n    register_native(env, \"values\", 1, map_values);\n    register_native(env, \"has_key\", 2, map_has_key);\n\n    // Math functions\n    register_native(env, \"abs\", 1, abs);\n    register_native(env, \"min\", 2, min);\n    register_native(env, \"max\", 2, max);\n    register_native(env, \"pow\", 2, pow);\n    register_native(env, \"sqrt\", 1, sqrt);\n    register_native(env, \"floor\", 1, floor);\n    register_native(env, \"ceil\", 1, ceil);\n    register_native(env, \"round\", 1, round);\n\n    // Conversion functions\n    register_native(env, \"to_int\", 1, to_int);\n    register_native(env, \"to_float\", 1, to_float);\n    register_native(env, \"to_string\", 1, to_string);\n\n    // IO functions\n    register_native(env, \"print\", 1, print);\n    register_native(env, \"println\", 1, println);\n\n    // Type checking\n    register_native(env, \"is_nil\", 1, is_nil);\n    register_native(env, \"is_bool\", 1, is_bool);\n    register_native(env, \"is_int\", 1, is_int);\n    register_native(env, \"is_float\", 1, is_float);\n    register_native(env, \"is_string\", 1, is_string);\n    register_native(env, \"is_list\", 1, is_list);\n    register_native(env, \"is_map\", 1, is_map);\n    register_native(env, \"is_function\", 1, is_function);\n\n    // Functional programming\n    register_native(env, \"map\", 2, map_fn);\n    register_native(env, \"filter\", 2, filter_fn);\n    register_native(env, \"fold\", 3, fold_fn);\n}\n\nfn register_native(env: \u0026mut Environment, name: \u0026str, arity: usize, func: fn(\u0026[Value]) -\u003e Result\u003cValue\u003e) {\n    let native = NativeFunction {\n        name: name.to_string(),\n        arity,\n        func,\n    };\n    env.define(\n        name.to_string(),\n        Value::Function(Function {\n            name: name.to_string(),\n            params: (0..arity).map(|i| format!(\"arg{}\", i)).collect(),\n            body: FunctionBody::Native(native),\n        }),\n    );\n}\n\n// String functions\nfn string_length(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let s = args[0].as_string()?;\n    Ok(Value::Int(s.len() as i64))\n}\n\nfn substring(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let s = args[0].as_string()?;\n    let start = args[1].as_int()? as usize;\n    let end = args[2].as_int()? as usize;\n\n    if start \u003e s.len() || end \u003e s.len() || start \u003e end {\n        return Err(FusabiError::runtime_error(\"Invalid substring indices\"));\n    }\n\n    Ok(Value::String(s[start..end].to_string()))\n}\n\nfn concat(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let s1 = args[0].as_string()?;\n    let s2 = args[1].as_string()?;\n    Ok(Value::String(format!(\"{}{}\", s1, s2)))\n}\n\nfn to_upper(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let s = args[0].as_string()?;\n    Ok(Value::String(s.to_uppercase()))\n}\n\nfn to_lower(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let s = args[0].as_string()?;\n    Ok(Value::String(s.to_lowercase()))\n}\n\nfn trim(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let s = args[0].as_string()?;\n    Ok(Value::String(s.trim().to_string()))\n}\n\nfn split(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let s = args[0].as_string()?;\n    let delimiter = args[1].as_string()?;\n    let parts: Vec\u003cValue\u003e = s\n        .split(\u0026delimiter)\n        .map(|p| Value::String(p.to_string()))\n        .collect();\n    Ok(Value::List(parts))\n}\n\nfn join(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let list = args[0].as_list()?;\n    let separator = args[1].as_string()?;\n\n    let strings: Result\u003cVec\u003cString\u003e\u003e = list.iter().map(|v| v.as_string()).collect();\n    let strings = strings?;\n\n    Ok(Value::String(strings.join(\u0026separator)))\n}\n\n// List functions\nfn list_length(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let list = args[0].as_list()?;\n    Ok(Value::Int(list.len() as i64))\n}\n\nfn list_head(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let list = args[0].as_list()?;\n    if list.is_empty() {\n        Err(FusabiError::runtime_error(\"head of empty list\"))\n    } else {\n        Ok(list[0].clone())\n    }\n}\n\nfn list_tail(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let list = args[0].as_list()?;\n    if list.is_empty() {\n        Err(FusabiError::runtime_error(\"tail of empty list\"))\n    } else {\n        Ok(Value::List(list[1..].to_vec()))\n    }\n}\n\nfn list_cons(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let elem = args[0].clone();\n    let list = args[1].as_list()?;\n    let mut new_list = vec![elem];\n    new_list.extend_from_slice(list);\n    Ok(Value::List(new_list))\n}\n\nfn list_append(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let list1 = args[0].as_list()?;\n    let list2 = args[1].as_list()?;\n    let mut new_list = list1.clone();\n    new_list.extend_from_slice(list2);\n    Ok(Value::List(new_list))\n}\n\nfn list_reverse(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let list = args[0].as_list()?;\n    let mut new_list = list.clone();\n    new_list.reverse();\n    Ok(Value::List(new_list))\n}\n\nfn list_nth(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let list = args[0].as_list()?;\n    let n = args[1].as_int()? as usize;\n\n    if n \u003e= list.len() {\n        Err(FusabiError::IndexOutOfBounds {\n            index: n,\n            length: list.len(),\n        })\n    } else {\n        Ok(list[n].clone())\n    }\n}\n\nfn list_take(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let n = args[0].as_int()? as usize;\n    let list = args[1].as_list()?;\n    let n = n.min(list.len());\n    Ok(Value::List(list[..n].to_vec()))\n}\n\nfn list_drop(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let n = args[0].as_int()? as usize;\n    let list = args[1].as_list()?;\n    if n \u003e= list.len() {\n        Ok(Value::List(vec![]))\n    } else {\n        Ok(Value::List(list[n..].to_vec()))\n    }\n}\n\n// Map functions\nfn map_keys(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let map = args[0].as_map()?;\n    let keys: Vec\u003cValue\u003e = map.keys().map(|k| Value::String(k.clone())).collect();\n    Ok(Value::List(keys))\n}\n\nfn map_values(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let map = args[0].as_map()?;\n    let values: Vec\u003cValue\u003e = map.values().cloned().collect();\n    Ok(Value::List(values))\n}\n\nfn map_has_key(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let map = args[0].as_map()?;\n    let key = args[1].as_string()?;\n    Ok(Value::Bool(map.contains_key(\u0026key)))\n}\n\n// Math functions\nfn abs(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    match \u0026args[0] {\n        Value::Int(i) =\u003e Ok(Value::Int(i.abs())),\n        Value::Float(f) =\u003e Ok(Value::Float(f.abs())),\n        _ =\u003e Err(FusabiError::type_error(\"number\", args[0].type_name())),\n    }\n}\n\nfn min(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    match (\u0026args[0], \u0026args[1]) {\n        (Value::Int(a), Value::Int(b)) =\u003e Ok(Value::Int(*a.min(b))),\n        (Value::Float(a), Value::Float(b)) =\u003e Ok(Value::Float(a.min(*b))),\n        _ =\u003e Err(FusabiError::runtime_error(\"min requires two numbers\")),\n    }\n}\n\nfn max(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    match (\u0026args[0], \u0026args[1]) {\n        (Value::Int(a), Value::Int(b)) =\u003e Ok(Value::Int(*a.max(b))),\n        (Value::Float(a), Value::Float(b)) =\u003e Ok(Value::Float(a.max(*b))),\n        _ =\u003e Err(FusabiError::runtime_error(\"max requires two numbers\")),\n    }\n}\n\nfn pow(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let base = args[0].as_float()?;\n    let exp = args[1].as_float()?;\n    Ok(Value::Float(base.powf(exp)))\n}\n\nfn sqrt(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let n = args[0].as_float()?;\n    Ok(Value::Float(n.sqrt()))\n}\n\nfn floor(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let n = args[0].as_float()?;\n    Ok(Value::Int(n.floor() as i64))\n}\n\nfn ceil(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let n = args[0].as_float()?;\n    Ok(Value::Int(n.ceil() as i64))\n}\n\nfn round(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    let n = args[0].as_float()?;\n    Ok(Value::Int(n.round() as i64))\n}\n\n// Conversion functions\nfn to_int(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    match \u0026args[0] {\n        Value::Int(i) =\u003e Ok(Value::Int(*i)),\n        Value::Float(f) =\u003e Ok(Value::Int(*f as i64)),\n        Value::String(s) =\u003e s\n            .parse::\u003ci64\u003e()\n            .map(Value::Int)\n            .map_err(|_| FusabiError::runtime_error(\"Failed to parse int\")),\n        _ =\u003e Err(FusabiError::type_error(\"convertible to int\", args[0].type_name())),\n    }\n}\n\nfn to_float(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    match \u0026args[0] {\n        Value::Int(i) =\u003e Ok(Value::Float(*i as f64)),\n        Value::Float(f) =\u003e Ok(Value::Float(*f)),\n        Value::String(s) =\u003e s\n            .parse::\u003cf64\u003e()\n            .map(Value::Float)\n            .map_err(|_| FusabiError::runtime_error(\"Failed to parse float\")),\n        _ =\u003e Err(FusabiError::type_error(\"convertible to float\", args[0].type_name())),\n    }\n}\n\nfn to_string(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::String(args[0].to_string()))\n}\n\n// IO functions\nfn print(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    print!(\"{}\", args[0]);\n    Ok(Value::Nil)\n}\n\nfn println(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    println!(\"{}\", args[0]);\n    Ok(Value::Nil)\n}\n\n// Type checking\nfn is_nil(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::Bool(matches!(args[0], Value::Nil)))\n}\n\nfn is_bool(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::Bool(matches!(args[0], Value::Bool(_))))\n}\n\nfn is_int(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::Bool(matches!(args[0], Value::Int(_))))\n}\n\nfn is_float(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::Bool(matches!(args[0], Value::Float(_))))\n}\n\nfn is_string(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::Bool(matches!(args[0], Value::String(_))))\n}\n\nfn is_list(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::Bool(matches!(args[0], Value::List(_))))\n}\n\nfn is_map(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::Bool(matches!(args[0], Value::Map(_))))\n}\n\nfn is_function(args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Ok(Value::Bool(matches!(args[0], Value::Function(_))))\n}\n\n// Functional programming (simplified - these would need closure support for full implementation)\nfn map_fn(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Err(FusabiError::runtime_error(\"map not yet implemented\"))\n}\n\nfn filter_fn(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Err(FusabiError::runtime_error(\"filter not yet implemented\"))\n}\n\nfn fold_fn(_args: \u0026[Value]) -\u003e Result\u003cValue\u003e {\n    Err(FusabiError::runtime_error(\"fold not yet implemented\"))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","src","watcher.rs"],"content":"use notify::{Event, RecommendedWatcher, RecursiveMode, Watcher};\nuse std::path::{Path, PathBuf};\nuse std::sync::mpsc::{channel, Receiver, Sender};\nuse std::time::Duration;\nuse crate::error::{FusabiError, Result};\n\n/// File watcher for hot-reloading scripts\npub struct ScriptWatcher {\n    watcher: RecommendedWatcher,\n    receiver: Receiver\u003cnotify::Result\u003cEvent\u003e\u003e,\n    watched_paths: Vec\u003cPathBuf\u003e,\n}\n\nimpl ScriptWatcher {\n    /// Create a new script watcher\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let (tx, rx) = channel();\n\n        let watcher = RecommendedWatcher::new(\n            move |res| {\n                let _ = tx.send(res);\n            },\n            notify::Config::default()\n                .with_poll_interval(Duration::from_millis(100)),\n        )\n        .map_err(|e| FusabiError::WatcherError(e.to_string()))?;\n\n        Ok(Self {\n            watcher,\n            receiver: rx,\n            watched_paths: Vec::new(),\n        })\n    }\n\n    /// Watch a file or directory for changes\n    pub fn watch(\u0026mut self, path: impl AsRef\u003cPath\u003e) -\u003e Result\u003c()\u003e {\n        let path = path.as_ref();\n        self.watcher\n            .watch(path, RecursiveMode::Recursive)\n            .map_err(|e| FusabiError::WatcherError(e.to_string()))?;\n        self.watched_paths.push(path.to_path_buf());\n        Ok(())\n    }\n\n    /// Stop watching a path\n    pub fn unwatch(\u0026mut self, path: impl AsRef\u003cPath\u003e) -\u003e Result\u003c()\u003e {\n        let path = path.as_ref();\n        self.watcher\n            .unwatch(path)\n            .map_err(|e| FusabiError::WatcherError(e.to_string()))?;\n        self.watched_paths.retain(|p| p != path);\n        Ok(())\n    }\n\n    /// Poll for file change events (non-blocking)\n    pub fn poll_events(\u0026self) -\u003e Vec\u003cFileChangeEvent\u003e {\n        let mut events = Vec::new();\n\n        // Drain all pending events\n        while let Ok(result) = self.receiver.try_recv() {\n            match result {\n                Ok(event) =\u003e {\n                    // Filter for .fsx files\n                    let paths: Vec\u003c_\u003e = event\n                        .paths\n                        .into_iter()\n                        .filter(|p| {\n                            p.extension()\n                                .and_then(|e| e.to_str())\n                                .map(|e| e == \"fsx\")\n                                .unwrap_or(false)\n                        })\n                        .collect();\n\n                    if !paths.is_empty() {\n                        events.push(FileChangeEvent {\n                            kind: event.kind,\n                            paths,\n                        });\n                    }\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"File watcher error: {:?}\", e);\n                }\n            }\n        }\n\n        events\n    }\n\n    /// Get list of watched paths\n    pub fn watched_paths(\u0026self) -\u003e \u0026[PathBuf] {\n        \u0026self.watched_paths\n    }\n}\n\n/// File change event\n#[derive(Debug, Clone)]\npub struct FileChangeEvent {\n    pub kind: notify::EventKind,\n    pub paths: Vec\u003cPathBuf\u003e,\n}\n\nimpl FileChangeEvent {\n    /// Check if this is a modification event\n    pub fn is_modify(\u0026self) -\u003e bool {\n        matches!(self.kind, notify::EventKind::Modify(_))\n    }\n\n    /// Check if this is a create event\n    pub fn is_create(\u0026self) -\u003e bool {\n        matches!(self.kind, notify::EventKind::Create(_))\n    }\n\n    /// Check if this is a remove event\n    pub fn is_remove(\u0026self) -\u003e bool {\n        matches!(self.kind, notify::EventKind::Remove(_))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use std::io::Write;\n\n    #[test]\n    #[ignore] // Requires filesystem access\n    fn test_watcher_basic() {\n        let temp_dir = std::env::temp_dir().join(\"fusabi_test\");\n        fs::create_dir_all(\u0026temp_dir).unwrap();\n\n        let mut watcher = ScriptWatcher::new().unwrap();\n        watcher.watch(\u0026temp_dir).unwrap();\n\n        // Create a test file\n        let test_file = temp_dir.join(\"test.fsx\");\n        let mut file = fs::File::create(\u0026test_file).unwrap();\n        file.write_all(b\"let x = 42\").unwrap();\n\n        // Give the watcher time to detect the change\n        std::thread::sleep(Duration::from_millis(200));\n\n        let events = watcher.poll_events();\n        assert!(!events.is_empty());\n\n        // Cleanup\n        fs::remove_dir_all(\u0026temp_dir).unwrap();\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-interpreter","tests","integration_tests.rs"],"content":"use fusabi_interpreter::*;\n\n#[test]\nfn test_basic_arithmetic() {\n    assert_eq!(eval(\"2 + 3\").unwrap(), Value::Int(5));\n    assert_eq!(eval(\"10 - 4\").unwrap(), Value::Int(6));\n    assert_eq!(eval(\"3 * 4\").unwrap(), Value::Int(12));\n    assert_eq!(eval(\"15 / 3\").unwrap(), Value::Int(5));\n    assert_eq!(eval(\"17 % 5\").unwrap(), Value::Int(2));\n}\n\n#[test]\nfn test_float_arithmetic() {\n    assert_eq!(eval(\"2.5 + 1.5\").unwrap(), Value::Float(4.0));\n    assert_eq!(eval(\"5.0 - 2.0\").unwrap(), Value::Float(3.0));\n    assert_eq!(eval(\"2.0 * 3.0\").unwrap(), Value::Float(6.0));\n    assert_eq!(eval(\"9.0 / 3.0\").unwrap(), Value::Float(3.0));\n}\n\n#[test]\nfn test_comparison() {\n    assert_eq!(eval(\"5 \u003e 3\").unwrap(), Value::Bool(true));\n    assert_eq!(eval(\"5 \u003c 3\").unwrap(), Value::Bool(false));\n    assert_eq!(eval(\"5 \u003e= 5\").unwrap(), Value::Bool(true));\n    assert_eq!(eval(\"5 \u003c= 5\").unwrap(), Value::Bool(true));\n    assert_eq!(eval(\"5 == 5\").unwrap(), Value::Bool(true));\n    assert_eq!(eval(\"5 != 3\").unwrap(), Value::Bool(true));\n}\n\n#[test]\nfn test_logical_operators() {\n    assert_eq!(eval(\"true \u0026\u0026 true\").unwrap(), Value::Bool(true));\n    assert_eq!(eval(\"true \u0026\u0026 false\").unwrap(), Value::Bool(false));\n    assert_eq!(eval(\"false || true\").unwrap(), Value::Bool(true));\n    assert_eq!(eval(\"false || false\").unwrap(), Value::Bool(false));\n    assert_eq!(eval(\"!true\").unwrap(), Value::Bool(false));\n    assert_eq!(eval(\"!false\").unwrap(), Value::Bool(true));\n}\n\n#[test]\nfn test_let_binding() {\n    let code = r#\"\n        let x = 42\n        x\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(42));\n\n    let code = r#\"\n        let x = 10\n        let y = 20\n        x + y\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(30));\n}\n\n#[test]\nfn test_let_expression() {\n    let code = \"let x = 42 in x + 1\";\n    assert_eq!(eval(code).unwrap(), Value::Int(43));\n\n    let code = \"let x = 10 in let y = 20 in x + y\";\n    assert_eq!(eval(code).unwrap(), Value::Int(30));\n}\n\n#[test]\nfn test_if_expression() {\n    assert_eq!(eval(\"if true then 1 else 2\").unwrap(), Value::Int(1));\n    assert_eq!(eval(\"if false then 1 else 2\").unwrap(), Value::Int(2));\n    assert_eq!(eval(\"if 5 \u003e 3 then 100 else 200\").unwrap(), Value::Int(100));\n}\n\n#[test]\nfn test_function_definition() {\n    let code = r#\"\n        let add x y = x + y\n        add(10, 20)\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(30));\n\n    let code = r#\"\n        let double x = x * 2\n        double(21)\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(42));\n}\n\n#[test]\nfn test_lambda() {\n    let code = \"(fun x -\u003e x + 1)(41)\";\n    assert_eq!(eval(code).unwrap(), Value::Int(42));\n\n    let code = \"(fun x y -\u003e x * y)(6, 7)\";\n    assert_eq!(eval(code).unwrap(), Value::Int(42));\n}\n\n#[test]\nfn test_higher_order_functions() {\n    let code = r#\"\n        let apply f x = f(x)\n        let inc x = x + 1\n        apply(inc, 41)\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(42));\n}\n\n#[test]\nfn test_list_literal() {\n    let code = \"[1, 2, 3]\";\n    if let Value::List(list) = eval(code).unwrap() {\n        assert_eq!(list.len(), 3);\n        assert_eq!(list[0], Value::Int(1));\n        assert_eq!(list[1], Value::Int(2));\n        assert_eq!(list[2], Value::Int(3));\n    } else {\n        panic!(\"Expected list\");\n    }\n}\n\n#[test]\nfn test_list_indexing() {\n    let code = \"[1, 2, 3][0]\";\n    assert_eq!(eval(code).unwrap(), Value::Int(1));\n\n    let code = \"[10, 20, 30][2]\";\n    assert_eq!(eval(code).unwrap(), Value::Int(30));\n}\n\n#[test]\nfn test_map_literal() {\n    let code = \"{ x = 1; y = 2 }\";\n    if let Value::Map(map) = eval(code).unwrap() {\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(\"x\"), Some(\u0026Value::Int(1)));\n        assert_eq!(map.get(\"y\"), Some(\u0026Value::Int(2)));\n    } else {\n        panic!(\"Expected map\");\n    }\n}\n\n#[test]\nfn test_map_field_access() {\n    let code = \"{ x = 42 }.x\";\n    assert_eq!(eval(code).unwrap(), Value::Int(42));\n}\n\n#[test]\nfn test_string_operations() {\n    assert_eq!(\n        eval(r#\"\"hello\" + \" \" + \"world\"\"#).unwrap(),\n        Value::String(\"hello world\".to_string())\n    );\n}\n\n#[test]\nfn test_stdlib_string_functions() {\n    assert_eq!(eval(r#\"strlen(\"hello\")\"#).unwrap(), Value::Int(5));\n    assert_eq!(\n        eval(r#\"to_upper(\"hello\")\"#).unwrap(),\n        Value::String(\"HELLO\".to_string())\n    );\n    assert_eq!(\n        eval(r#\"to_lower(\"WORLD\")\"#).unwrap(),\n        Value::String(\"world\".to_string())\n    );\n}\n\n#[test]\nfn test_stdlib_list_functions() {\n    assert_eq!(eval(\"length([1, 2, 3])\").unwrap(), Value::Int(3));\n    assert_eq!(eval(\"head([1, 2, 3])\").unwrap(), Value::Int(1));\n\n    let code = \"reverse([1, 2, 3])\";\n    if let Value::List(list) = eval(code).unwrap() {\n        assert_eq!(list, vec![Value::Int(3), Value::Int(2), Value::Int(1)]);\n    } else {\n        panic!(\"Expected list\");\n    }\n}\n\n#[test]\nfn test_stdlib_math_functions() {\n    assert_eq!(eval(\"abs(-42)\").unwrap(), Value::Int(42));\n    assert_eq!(eval(\"min(5, 10)\").unwrap(), Value::Int(5));\n    assert_eq!(eval(\"max(5, 10)\").unwrap(), Value::Int(10));\n    assert_eq!(eval(\"floor(3.7)\").unwrap(), Value::Int(3));\n    assert_eq!(eval(\"ceil(3.2)\").unwrap(), Value::Int(4));\n}\n\n#[test]\nfn test_type_checking_functions() {\n    assert_eq!(eval(\"is_int(42)\").unwrap(), Value::Bool(true));\n    assert_eq!(eval(\"is_int(3.14)\").unwrap(), Value::Bool(false));\n    assert_eq!(eval(r#\"is_string(\"hello\")\"#).unwrap(), Value::Bool(true));\n    assert_eq!(eval(\"is_list([1, 2, 3])\").unwrap(), Value::Bool(true));\n}\n\n#[test]\nfn test_recursion() {\n    let code = r#\"\n        let factorial n =\n            if n \u003c= 1 then\n                1\n            else\n                n * factorial(n - 1)\n        factorial(5)\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(120));\n}\n\n#[test]\nfn test_nested_functions() {\n    let code = r#\"\n        let outer x =\n            let inner y = x + y\n            inner(10)\n        outer(5)\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(15));\n}\n\n#[test]\nfn test_comments() {\n    let code = r#\"\n        // This is a comment\n        let x = 42 // Another comment\n        x\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(42));\n}\n\n#[test]\nfn test_complex_expression() {\n    let code = r#\"\n        let square x = x * x\n        let sum_of_squares x y = square(x) + square(y)\n        sum_of_squares(3, 4)\n    \"#;\n    assert_eq!(eval(code).unwrap(), Value::Int(25));\n}\n\n#[test]\nfn test_error_division_by_zero() {\n    let result = eval(\"10 / 0\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_error_undefined_variable() {\n    let result = eval(\"undefined_var\");\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_error_type_mismatch() {\n    let result = eval(r#\"42 + \"string\"\"#);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_error_arity_mismatch() {\n    let code = r#\"\n        let add x y = x + y\n        add(10)\n    \"#;\n    let result = eval(code);\n    assert!(result.is_err());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-vm","benches","vm_benchmark.rs"],"content":"//! Performance benchmarks for Fusabi VM\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};\nuse fusabi_vm::*;\n\nfn benchmark_opcode_execution(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"opcodes\");\n\n    // Benchmark simple arithmetic\n    group.bench_function(\"add_i32\", |b| {\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(0).encode());\n        code.extend(Opcode::Push(1).encode());\n        code.extend(Opcode::Add.encode());\n        code.extend(Opcode::Ret.encode());\n\n        let mut bytecode = FusabiBytecode::new(0);\n        bytecode.constants = vec![Value::I32(10), Value::I32(5)];\n        bytecode.functions.push(Function {\n            name: \"test\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        });\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        b.iter(|| {\n            let mut vm = FusabiVM::new();\n            black_box(vm.execute(archived).unwrap());\n        });\n    });\n\n    // Benchmark complex expression\n    group.bench_function(\"complex_expression\", |b| {\n        // (10 + 5) * 2 - 3\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(0).encode());\n        code.extend(Opcode::Push(1).encode());\n        code.extend(Opcode::Add.encode());\n        code.extend(Opcode::Push(2).encode());\n        code.extend(Opcode::Mul.encode());\n        code.extend(Opcode::Push(3).encode());\n        code.extend(Opcode::Sub.encode());\n        code.extend(Opcode::Ret.encode());\n\n        let mut bytecode = FusabiBytecode::new(0);\n        bytecode.constants = vec![\n            Value::I32(10),\n            Value::I32(5),\n            Value::I32(2),\n            Value::I32(3),\n        ];\n        bytecode.functions.push(Function {\n            name: \"test\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        });\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        b.iter(|| {\n            let mut vm = FusabiVM::new();\n            black_box(vm.execute(archived).unwrap());\n        });\n    });\n\n    // Benchmark stack operations\n    group.bench_function(\"stack_ops\", |b| {\n        let mut code = Vec::new();\n        for _ in 0..100 {\n            code.extend(Opcode::Push(0).encode());\n            code.extend(Opcode::Pop.encode());\n        }\n        code.extend(Opcode::Push(0).encode());\n        code.extend(Opcode::Ret.encode());\n\n        let mut bytecode = FusabiBytecode::new(0);\n        bytecode.constants = vec![Value::I32(42)];\n        bytecode.functions.push(Function {\n            name: \"test\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        });\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        b.iter(|| {\n            let mut vm = FusabiVM::new();\n            black_box(vm.execute(archived).unwrap());\n        });\n    });\n\n    group.finish();\n}\n\nfn benchmark_bytecode_loading(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"bytecode\");\n\n    // Create a moderately sized bytecode\n    let mut bytecode = FusabiBytecode::new(0);\n    for i in 0..1000 {\n        bytecode.constants.push(Value::I32(i));\n    }\n\n    let mut code = Vec::new();\n    code.extend(Opcode::Push(0).encode());\n    code.extend(Opcode::Ret.encode());\n\n    for i in 0..100 {\n        bytecode.functions.push(Function {\n            name: format!(\"func_{}\", i),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code.clone(),\n        });\n    }\n\n    let bytes = bytecode.to_bytes().unwrap();\n\n    group.bench_function(\"deserialize\", |b| {\n        b.iter(|| {\n            black_box(FusabiBytecode::from_bytes(\u0026bytes).unwrap());\n        });\n    });\n\n    group.finish();\n}\n\nfn benchmark_ffi_calls(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"ffi\");\n\n    // Register FFI function\n    let mut vm = FusabiVM::new();\n    vm.register_ffi(\"add\", |args| {\n        let a = args[0].as_i32().unwrap();\n        let b = args[1].as_i32().unwrap();\n        Ok(Value::I32(a + b))\n    });\n\n    // Create bytecode that calls FFI\n    let mut bytecode = FusabiBytecode::new(0);\n    bytecode.constants = vec![Value::I32(10), Value::I32(5)];\n    bytecode.ffi_imports = vec![\"add\".to_string()];\n\n    let mut code = Vec::new();\n    code.extend(Opcode::Push(0).encode());\n    code.extend(Opcode::Push(1).encode());\n    code.extend(Opcode::CallFFI(0).encode());\n    code.extend(Opcode::Ret.encode());\n\n    bytecode.functions.push(Function {\n        name: \"test\".to_string(),\n        params: vec![],\n        return_type: Type::I32,\n        locals: 0,\n        bytecode: code,\n    });\n\n    let bytes = bytecode.to_bytes().unwrap();\n    let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n    group.bench_function(\"single_call\", |b| {\n        b.iter(|| {\n            black_box(vm.execute(archived).unwrap());\n        });\n    });\n\n    group.finish();\n}\n\nfn benchmark_throughput(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"throughput\");\n\n    // Benchmark instruction throughput\n    for size in [100, 1000, 10000].iter() {\n        group.bench_with_input(\n            BenchmarkId::new(\"instructions\", size),\n            size,\n            |b, \u0026size| {\n                let mut code = Vec::new();\n                for _ in 0..size {\n                    code.extend(Opcode::Push(0).encode());\n                    code.extend(Opcode::Push(1).encode());\n                    code.extend(Opcode::Add.encode());\n                    code.extend(Opcode::Pop.encode());\n                }\n                code.extend(Opcode::Push(0).encode());\n                code.extend(Opcode::Ret.encode());\n\n                let mut bytecode = FusabiBytecode::new(0);\n                bytecode.constants = vec![Value::I32(1), Value::I32(2)];\n                bytecode.functions.push(Function {\n                    name: \"test\".to_string(),\n                    params: vec![],\n                    return_type: Type::I32,\n                    locals: 0,\n                    bytecode: code,\n                });\n\n                let bytes = bytecode.to_bytes().unwrap();\n                let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n                b.iter(|| {\n                    let mut vm = FusabiVM::new();\n                    black_box(vm.execute(archived).unwrap());\n                });\n            },\n        );\n    }\n\n    group.finish();\n}\n\nfn benchmark_fibonacci(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"fibonacci\");\n\n    // Iterative fibonacci\n    let mut code = Vec::new();\n    // locals: 0=n, 1=a, 2=b, 3=temp\n\n    // a = 0\n    code.extend(Opcode::Push(0).encode());\n    code.extend(Opcode::Store(1).encode());\n\n    // b = 1\n    code.extend(Opcode::Push(1).encode());\n    code.extend(Opcode::Store(2).encode());\n\n    // n = 10\n    code.extend(Opcode::Push(2).encode());\n    code.extend(Opcode::Store(0).encode());\n\n    // Loop start (pc = current position)\n    let loop_start = code.len();\n\n    // if n == 0: break\n    code.extend(Opcode::Load(0).encode());\n    code.extend(Opcode::Push(0).encode());\n    code.extend(Opcode::Eq.encode());\n\n    // Calculate jump offset to after loop (will be patched)\n    let jump_patch_pos = code.len();\n    code.extend(Opcode::JumpIf(0).encode()); // Will patch this\n\n    // temp = a + b\n    code.extend(Opcode::Load(1).encode());\n    code.extend(Opcode::Load(2).encode());\n    code.extend(Opcode::Add.encode());\n    code.extend(Opcode::Store(3).encode());\n\n    // a = b\n    code.extend(Opcode::Load(2).encode());\n    code.extend(Opcode::Store(1).encode());\n\n    // b = temp\n    code.extend(Opcode::Load(3).encode());\n    code.extend(Opcode::Store(2).encode());\n\n    // n = n - 1\n    code.extend(Opcode::Load(0).encode());\n    code.extend(Opcode::Push(1).encode());\n    code.extend(Opcode::Sub.encode());\n    code.extend(Opcode::Store(0).encode());\n\n    // Jump back to loop start\n    let loop_end = code.len();\n    let back_jump = (loop_start as i32) - (loop_end as i32);\n    code.extend(Opcode::Jump(back_jump).encode());\n\n    // Patch forward jump\n    let after_loop = code.len();\n    let forward_jump = (after_loop as i32) - ((jump_patch_pos + 5) as i32);\n    let jump_bytes = Opcode::JumpIf(forward_jump).encode();\n    code[jump_patch_pos..jump_patch_pos + 5].copy_from_slice(\u0026jump_bytes);\n\n    // Return b\n    code.extend(Opcode::Load(2).encode());\n    code.extend(Opcode::Ret.encode());\n\n    let mut bytecode = FusabiBytecode::new(0);\n    bytecode.constants = vec![Value::I32(0), Value::I32(1), Value::I32(10)];\n    bytecode.functions.push(Function {\n        name: \"fib\".to_string(),\n        params: vec![],\n        return_type: Type::I32,\n        locals: 4,\n        bytecode: code,\n    });\n\n    let bytes = bytecode.to_bytes().unwrap();\n    let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n    group.bench_function(\"fib_10\", |b| {\n        b.iter(|| {\n            let mut vm = FusabiVM::new();\n            black_box(vm.execute(archived).unwrap());\n        });\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    benchmark_opcode_execution,\n    benchmark_bytecode_loading,\n    benchmark_ffi_calls,\n    benchmark_throughput,\n    benchmark_fibonacci,\n);\n\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-vm","examples","simple_plugin.rs"],"content":"//! Example: Simple Fusabi Plugin\n//!\n//! Demonstrates creating and executing a simple .fzb plugin\n\nuse fusabi_vm::*;\n\nfn main() {\n    println!(\"=== Fusabi VM Example: Simple Plugin ===\\n\");\n\n    // Example 1: Basic arithmetic\n    println!(\"Example 1: Computing (10 + 5) * 2\");\n    {\n        let (builder, c1) = BytecodeBuilder::new().add_constant(Value::I32(10));\n        let (builder, c2) = builder.add_constant(Value::I32(5));\n        let (builder, c3) = builder.add_constant(Value::I32(2));\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(c1).encode());\n        code.extend(Opcode::Push(c2).encode());\n        code.extend(Opcode::Add.encode());\n        code.extend(Opcode::Push(c3).encode());\n        code.extend(Opcode::Mul.encode());\n        code.extend(Opcode::Ret.encode());\n\n        let func = Function {\n            name: \"arithmetic\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        };\n\n        let (builder, func_idx) = builder.add_function(func);\n        let bytecode = builder.entry_point(func_idx).build().unwrap();\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        let mut vm = FusabiVM::new();\n        let result = vm.execute(archived).unwrap();\n\n        println!(\"Result: {}\", result);\n        println!(\"Instructions executed: {}\\n\", vm.stats().instructions_executed);\n    }\n\n    // Example 2: Using FFI functions\n    println!(\"Example 2: String operations with FFI\");\n    {\n        let (builder, c1) = BytecodeBuilder::new()\n            .add_constant(Value::String(\"Hello, \".to_string()));\n        let (builder, c2) = builder.add_constant(Value::String(\"Fusabi!\".to_string()));\n        let (builder, ffi_idx) = builder.add_ffi_import(\"string_concat\");\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(c1).encode());\n        code.extend(Opcode::Push(c2).encode());\n        code.extend(Opcode::CallFFI(ffi_idx).encode());\n        code.extend(Opcode::Ret.encode());\n\n        let func = Function {\n            name: \"concat\".to_string(),\n            params: vec![],\n            return_type: Type::String,\n            locals: 0,\n            bytecode: code,\n        };\n\n        let (builder, func_idx) = builder.add_function(func);\n        let bytecode = builder.entry_point(func_idx).build().unwrap();\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        let mut vm = VmBuilder::new().with_stdlib(true).build();\n        let result = vm.execute(archived).unwrap();\n\n        println!(\"Result: {}\", result);\n        println!(\"FFI calls: {}\\n\", vm.stats().ffi_calls);\n    }\n\n    // Example 3: Conditional logic\n    println!(\"Example 3: Conditional execution\");\n    {\n        let (builder, c_val) = BytecodeBuilder::new().add_constant(Value::I32(5));\n        let (builder, c_threshold) = builder.add_constant(Value::I32(10));\n        let (builder, c_low) = builder.add_constant(Value::String(\"Low\".to_string()));\n        let (builder, c_high) = builder.add_constant(Value::String(\"High\".to_string()));\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(c_val).encode());\n        code.extend(Opcode::Push(c_threshold).encode());\n        code.extend(Opcode::Lt.encode()); // val \u003c 10?\n\n        // If true, jump to push \"Low\"\n        code.extend(Opcode::JumpIfNot(5).encode());\n        code.extend(Opcode::Push(c_low).encode());\n        code.extend(Opcode::Jump(5).encode());\n\n        // Else push \"High\"\n        code.extend(Opcode::Push(c_high).encode());\n\n        code.extend(Opcode::Ret.encode());\n\n        let func = Function {\n            name: \"conditional\".to_string(),\n            params: vec![],\n            return_type: Type::String,\n            locals: 0,\n            bytecode: code,\n        };\n\n        let (builder, func_idx) = builder.add_function(func);\n        let bytecode = builder.entry_point(func_idx).build().unwrap();\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        let mut vm = FusabiVM::new();\n        let result = vm.execute(archived).unwrap();\n\n        println!(\"Result: {}\\n\", result);\n    }\n\n    // Example 4: Computing factorial-like operation\n    println!(\"Example 4: Computing 5 * 4 * 3\");\n    {\n        let (builder, c1) = BytecodeBuilder::new().add_constant(Value::I32(5));\n        let (builder, c2) = builder.add_constant(Value::I32(4));\n        let (builder, c3) = builder.add_constant(Value::I32(3));\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(c1).encode());\n        code.extend(Opcode::Push(c2).encode());\n        code.extend(Opcode::Mul.encode());\n        code.extend(Opcode::Push(c3).encode());\n        code.extend(Opcode::Mul.encode());\n        code.extend(Opcode::Ret.encode());\n\n        let func = Function {\n            name: \"multiply\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        };\n\n        let (builder, func_idx) = builder.add_function(func);\n        let bytecode = builder.entry_point(func_idx).build().unwrap();\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        let mut vm = FusabiVM::new();\n        let result = vm.execute(archived).unwrap();\n\n        println!(\"Result: {}\", result);\n        println!(\"Max stack depth: {}\\n\", vm.stats().max_stack_depth);\n    }\n\n    // Example 5: Save bytecode to file\n    println!(\"Example 5: Saving bytecode to file\");\n    {\n        let (builder, const_idx) = BytecodeBuilder::new()\n            .add_constant(Value::I32(42));\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(const_idx).encode());\n        code.extend(Opcode::Ret.encode());\n\n        let func = Function {\n            name: \"main\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        };\n\n        let (builder, func_idx) = builder.add_function(func);\n        let bytecode = builder.entry_point(func_idx).build().unwrap();\n\n        let bytes = bytecode.to_bytes().unwrap();\n\n        // In a real application, you would write to a .fzb file:\n        // std::fs::write(\"plugin.fzb\", \u0026bytes).unwrap();\n\n        println!(\"Bytecode size: {} bytes\", bytes.len());\n        println!(\"Functions: {}\", bytecode.functions.len());\n        println!(\"Constants: {}\", bytecode.constants.len());\n    }\n\n    println!(\"\\n=== All examples completed successfully! ===\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-vm","src","bytecode.rs"],"content":"//! Fusabi Bytecode Format (.fzb)\n//!\n//! This module defines the binary format for compiled Fusabi plugins.\n//! Uses rkyv for zero-copy deserialization.\n\nuse rkyv::{Archive, Deserialize, Serialize};\nuse std::fmt;\n\n/// Magic number for .fzb files: \"FZB\\0\"\npub const MAGIC: [u8; 4] = *b\"FZB\\0\";\n\n/// Current bytecode version\npub const VERSION: u32 = 1;\n\n/// Maximum function name length (bytes)\npub const MAX_NAME_LEN: usize = 256;\n\n/// Maximum number of constants per module\npub const MAX_CONSTANTS: usize = 65536;\n\n/// Maximum number of functions per module\npub const MAX_FUNCTIONS: usize = 4096;\n\n/// Maximum bytecode size per function (bytes)\npub const MAX_FUNCTION_SIZE: usize = 1024 * 1024; // 1MB\n\n/// Complete bytecode module\n#[derive(Archive, Deserialize, Serialize, Debug, Clone)]\n#[archive(check_bytes)]\npub struct FusabiBytecode {\n    /// Magic identifier\n    pub magic: [u8; 4],\n\n    /// Bytecode format version\n    pub version: u32,\n\n    /// Constant pool\n    pub constants: Vec\u003cValue\u003e,\n\n    /// Function definitions\n    pub functions: Vec\u003cFunction\u003e,\n\n    /// Entry point function index\n    pub entry_point: u32,\n\n    /// FFI function names (external calls)\n    pub ffi_imports: Vec\u003cString\u003e,\n}\n\nimpl FusabiBytecode {\n    /// Create a new bytecode module\n    pub fn new(entry_point: u32) -\u003e Self {\n        Self {\n            magic: MAGIC,\n            version: VERSION,\n            constants: Vec::new(),\n            functions: Vec::new(),\n            entry_point,\n            ffi_imports: Vec::new(),\n        }\n    }\n\n    /// Validate bytecode integrity\n    pub fn validate(\u0026self) -\u003e Result\u003c(), BytecodeError\u003e {\n        // Check magic number\n        if self.magic != MAGIC {\n            return Err(BytecodeError::InvalidMagic);\n        }\n\n        // Check version\n        if self.version != VERSION {\n            return Err(BytecodeError::UnsupportedVersion(self.version));\n        }\n\n        // Check constants limit\n        if self.constants.len() \u003e MAX_CONSTANTS {\n            return Err(BytecodeError::TooManyConstants);\n        }\n\n        // Check functions limit\n        if self.functions.len() \u003e MAX_FUNCTIONS {\n            return Err(BytecodeError::TooManyFunctions);\n        }\n\n        // Check entry point\n        if self.entry_point as usize \u003e= self.functions.len() {\n            return Err(BytecodeError::InvalidEntryPoint);\n        }\n\n        // Validate each function\n        for (idx, func) in self.functions.iter().enumerate() {\n            func.validate(idx)?;\n        }\n\n        Ok(())\n    }\n\n    /// Serialize to bytes using rkyv (zero-copy)\n    pub fn to_bytes(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, BytecodeError\u003e {\n        let aligned = rkyv::to_bytes::\u003c_, 256\u003e(self)\n            .map_err(|e| BytecodeError::SerializationError(e.to_string()))?;\n        Ok(aligned.to_vec())\n    }\n\n    /// Deserialize from bytes (zero-copy)\n    pub fn from_bytes(bytes: \u0026[u8]) -\u003e Result\u003c\u0026ArchivedFusabiBytecode, BytecodeError\u003e {\n        rkyv::check_archived_root::\u003cFusabiBytecode\u003e(bytes)\n            .map_err(|e| BytecodeError::DeserializationError(e.to_string()))\n    }\n}\n\n/// Function definition\n#[derive(Archive, Deserialize, Serialize, Debug, Clone)]\n#[archive(check_bytes)]\npub struct Function {\n    /// Function name (for debugging)\n    pub name: String,\n\n    /// Parameter types\n    pub params: Vec\u003cType\u003e,\n\n    /// Return type\n    pub return_type: Type,\n\n    /// Number of local variables\n    pub locals: u32,\n\n    /// Bytecode instructions\n    pub bytecode: Vec\u003cu8\u003e,\n}\n\nimpl Function {\n    /// Validate function\n    pub fn validate(\u0026self, idx: usize) -\u003e Result\u003c(), BytecodeError\u003e {\n        // Check name length\n        if self.name.len() \u003e MAX_NAME_LEN {\n            return Err(BytecodeError::NameTooLong(idx));\n        }\n\n        // Check bytecode size\n        if self.bytecode.len() \u003e MAX_FUNCTION_SIZE {\n            return Err(BytecodeError::FunctionTooLarge(idx));\n        }\n\n        // Validate bytecode opcodes\n        self.validate_opcodes(idx)?;\n\n        Ok(())\n    }\n\n    fn validate_opcodes(\u0026self, fn_idx: usize) -\u003e Result\u003c(), BytecodeError\u003e {\n        let mut pc = 0;\n        while pc \u003c self.bytecode.len() {\n            let op = Opcode::decode(\u0026self.bytecode[pc..])?;\n            pc += op.size();\n\n            // Validate opcode-specific constraints\n            match op {\n                Opcode::Load(local) | Opcode::Store(local) =\u003e {\n                    if local \u003e= self.locals {\n                        return Err(BytecodeError::InvalidLocal(fn_idx, local));\n                    }\n                }\n                _ =\u003e {}\n            }\n        }\n        Ok(())\n    }\n}\n\n/// VM Value types\n#[derive(Archive, Deserialize, Serialize, Debug, Clone, PartialEq)]\n#[archive(check_bytes)]\npub enum Value {\n    Unit,\n    Bool(bool),\n    I32(i32),\n    I64(i64),\n    F32(f32),\n    F64(f64),\n    Char(char),\n    String(String),\n}\n\nimpl fmt::Display for Value {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Value::Unit =\u003e write!(f, \"()\"),\n            Value::Bool(b) =\u003e write!(f, \"{}\", b),\n            Value::I32(i) =\u003e write!(f, \"{}\", i),\n            Value::I64(i) =\u003e write!(f, \"{}\", i),\n            Value::F32(fl) =\u003e write!(f, \"{}\", fl),\n            Value::F64(fl) =\u003e write!(f, \"{}\", fl),\n            Value::Char(c) =\u003e write!(f, \"'{}'\", c),\n            Value::String(s) =\u003e write!(f, \"\\\"{}\\\"\", s),\n        }\n    }\n}\n\nimpl Value {\n    pub fn as_bool(\u0026self) -\u003e Result\u003cbool, BytecodeError\u003e {\n        match self {\n            Value::Bool(b) =\u003e Ok(*b),\n            _ =\u003e Err(BytecodeError::TypeError {\n                expected: \"Bool\",\n                got: self.type_name(),\n            }),\n        }\n    }\n\n    pub fn as_i32(\u0026self) -\u003e Result\u003ci32, BytecodeError\u003e {\n        match self {\n            Value::I32(i) =\u003e Ok(*i),\n            _ =\u003e Err(BytecodeError::TypeError {\n                expected: \"I32\",\n                got: self.type_name(),\n            }),\n        }\n    }\n\n    pub fn as_char(\u0026self) -\u003e Result\u003cchar, BytecodeError\u003e {\n        match self {\n            Value::Char(c) =\u003e Ok(*c),\n            _ =\u003e Err(BytecodeError::TypeError {\n                expected: \"Char\",\n                got: self.type_name(),\n            }),\n        }\n    }\n\n    pub fn type_name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Value::Unit =\u003e \"Unit\",\n            Value::Bool(_) =\u003e \"Bool\",\n            Value::I32(_) =\u003e \"I32\",\n            Value::I64(_) =\u003e \"I64\",\n            Value::F32(_) =\u003e \"F32\",\n            Value::F64(_) =\u003e \"F64\",\n            Value::Char(_) =\u003e \"Char\",\n            Value::String(_) =\u003e \"String\",\n        }\n    }\n}\n\n/// Type system\n#[derive(Archive, Deserialize, Serialize, Debug, Clone, PartialEq)]\n#[archive(check_bytes)]\npub enum Type {\n    Unit,\n    Bool,\n    I32,\n    I64,\n    F32,\n    F64,\n    Char,\n    String,\n}\n\n/// VM Opcodes\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum Opcode {\n    // Stack operations\n    Push(u32),      // Push constant from pool\n    Pop,            // Pop top of stack\n    Dup,            // Duplicate top of stack\n\n    // Local variables\n    Load(u32),      // Load local variable\n    Store(u32),     // Store to local variable\n\n    // Control flow\n    Call(u32),      // Call function by index\n    CallFFI(u32),   // Call FFI function by index\n    Ret,            // Return from function\n    Jump(i32),      // Unconditional jump\n    JumpIf(i32),    // Jump if top of stack is true\n    JumpIfNot(i32), // Jump if top of stack is false\n\n    // Arithmetic\n    Add,            // Pop b, a; push a + b\n    Sub,            // Pop b, a; push a - b\n    Mul,            // Pop b, a; push a * b\n    Div,            // Pop b, a; push a / b\n    Mod,            // Pop b, a; push a % b\n    Neg,            // Pop a; push -a\n\n    // Comparison\n    Eq,             // Pop b, a; push a == b\n    Ne,             // Pop b, a; push a != b\n    Lt,             // Pop b, a; push a \u003c b\n    Le,             // Pop b, a; push a \u003c= b\n    Gt,             // Pop b, a; push a \u003e b\n    Ge,             // Pop b, a; push a \u003e= b\n\n    // Logical\n    And,            // Pop b, a; push a \u0026\u0026 b\n    Or,             // Pop b, a; push a || b\n    Not,            // Pop a; push !a\n\n    // Special\n    Nop,            // No operation\n    Halt,           // Stop execution\n}\n\nimpl Opcode {\n    /// Decode opcode from bytecode stream\n    pub fn decode(bytes: \u0026[u8]) -\u003e Result\u003cSelf, BytecodeError\u003e {\n        if bytes.is_empty() {\n            return Err(BytecodeError::UnexpectedEndOfBytecode);\n        }\n\n        let op = match bytes[0] {\n            0x00 =\u003e Opcode::Nop,\n            0x01 =\u003e {\n                if bytes.len() \u003c 5 {\n                    return Err(BytecodeError::UnexpectedEndOfBytecode);\n                }\n                let idx = u32::from_le_bytes([bytes[1], bytes[2], bytes[3], bytes[4]]);\n                Opcode::Push(idx)\n            }\n            0x02 =\u003e Opcode::Pop,\n            0x03 =\u003e Opcode::Dup,\n            0x04 =\u003e {\n                if bytes.len() \u003c 5 {\n                    return Err(BytecodeError::UnexpectedEndOfBytecode);\n                }\n                let idx = u32::from_le_bytes([bytes[1], bytes[2], bytes[3], bytes[4]]);\n                Opcode::Load(idx)\n            }\n            0x05 =\u003e {\n                if bytes.len() \u003c 5 {\n                    return Err(BytecodeError::UnexpectedEndOfBytecode);\n                }\n                let idx = u32::from_le_bytes([bytes[1], bytes[2], bytes[3], bytes[4]]);\n                Opcode::Store(idx)\n            }\n            0x10 =\u003e {\n                if bytes.len() \u003c 5 {\n                    return Err(BytecodeError::UnexpectedEndOfBytecode);\n                }\n                let idx = u32::from_le_bytes([bytes[1], bytes[2], bytes[3], bytes[4]]);\n                Opcode::Call(idx)\n            }\n            0x11 =\u003e {\n                if bytes.len() \u003c 5 {\n                    return Err(BytecodeError::UnexpectedEndOfBytecode);\n                }\n                let idx = u32::from_le_bytes([bytes[1], bytes[2], bytes[3], bytes[4]]);\n                Opcode::CallFFI(idx)\n            }\n            0x12 =\u003e Opcode::Ret,\n            0x13 =\u003e {\n                if bytes.len() \u003c 5 {\n                    return Err(BytecodeError::UnexpectedEndOfBytecode);\n                }\n                let offset = i32::from_le_bytes([bytes[1], bytes[2], bytes[3], bytes[4]]);\n                Opcode::Jump(offset)\n            }\n            0x14 =\u003e {\n                if bytes.len() \u003c 5 {\n                    return Err(BytecodeError::UnexpectedEndOfBytecode);\n                }\n                let offset = i32::from_le_bytes([bytes[1], bytes[2], bytes[3], bytes[4]]);\n                Opcode::JumpIf(offset)\n            }\n            0x15 =\u003e {\n                if bytes.len() \u003c 5 {\n                    return Err(BytecodeError::UnexpectedEndOfBytecode);\n                }\n                let offset = i32::from_le_bytes([bytes[1], bytes[2], bytes[3], bytes[4]]);\n                Opcode::JumpIfNot(offset)\n            }\n            0x20 =\u003e Opcode::Add,\n            0x21 =\u003e Opcode::Sub,\n            0x22 =\u003e Opcode::Mul,\n            0x23 =\u003e Opcode::Div,\n            0x24 =\u003e Opcode::Mod,\n            0x25 =\u003e Opcode::Neg,\n            0x30 =\u003e Opcode::Eq,\n            0x31 =\u003e Opcode::Ne,\n            0x32 =\u003e Opcode::Lt,\n            0x33 =\u003e Opcode::Le,\n            0x34 =\u003e Opcode::Gt,\n            0x35 =\u003e Opcode::Ge,\n            0x40 =\u003e Opcode::And,\n            0x41 =\u003e Opcode::Or,\n            0x42 =\u003e Opcode::Not,\n            0xFF =\u003e Opcode::Halt,\n            _ =\u003e return Err(BytecodeError::InvalidOpcode(bytes[0])),\n        };\n\n        Ok(op)\n    }\n\n    /// Encode opcode to bytes\n    pub fn encode(\u0026self) -\u003e Vec\u003cu8\u003e {\n        match self {\n            Opcode::Nop =\u003e vec![0x00],\n            Opcode::Push(idx) =\u003e {\n                let mut bytes = vec![0x01];\n                bytes.extend_from_slice(\u0026idx.to_le_bytes());\n                bytes\n            }\n            Opcode::Pop =\u003e vec![0x02],\n            Opcode::Dup =\u003e vec![0x03],\n            Opcode::Load(idx) =\u003e {\n                let mut bytes = vec![0x04];\n                bytes.extend_from_slice(\u0026idx.to_le_bytes());\n                bytes\n            }\n            Opcode::Store(idx) =\u003e {\n                let mut bytes = vec![0x05];\n                bytes.extend_from_slice(\u0026idx.to_le_bytes());\n                bytes\n            }\n            Opcode::Call(idx) =\u003e {\n                let mut bytes = vec![0x10];\n                bytes.extend_from_slice(\u0026idx.to_le_bytes());\n                bytes\n            }\n            Opcode::CallFFI(idx) =\u003e {\n                let mut bytes = vec![0x11];\n                bytes.extend_from_slice(\u0026idx.to_le_bytes());\n                bytes\n            }\n            Opcode::Ret =\u003e vec![0x12],\n            Opcode::Jump(offset) =\u003e {\n                let mut bytes = vec![0x13];\n                bytes.extend_from_slice(\u0026offset.to_le_bytes());\n                bytes\n            }\n            Opcode::JumpIf(offset) =\u003e {\n                let mut bytes = vec![0x14];\n                bytes.extend_from_slice(\u0026offset.to_le_bytes());\n                bytes\n            }\n            Opcode::JumpIfNot(offset) =\u003e {\n                let mut bytes = vec![0x15];\n                bytes.extend_from_slice(\u0026offset.to_le_bytes());\n                bytes\n            }\n            Opcode::Add =\u003e vec![0x20],\n            Opcode::Sub =\u003e vec![0x21],\n            Opcode::Mul =\u003e vec![0x22],\n            Opcode::Div =\u003e vec![0x23],\n            Opcode::Mod =\u003e vec![0x24],\n            Opcode::Neg =\u003e vec![0x25],\n            Opcode::Eq =\u003e vec![0x30],\n            Opcode::Ne =\u003e vec![0x31],\n            Opcode::Lt =\u003e vec![0x32],\n            Opcode::Le =\u003e vec![0x33],\n            Opcode::Gt =\u003e vec![0x34],\n            Opcode::Ge =\u003e vec![0x35],\n            Opcode::And =\u003e vec![0x40],\n            Opcode::Or =\u003e vec![0x41],\n            Opcode::Not =\u003e vec![0x42],\n            Opcode::Halt =\u003e vec![0xFF],\n        }\n    }\n\n    /// Get size in bytes\n    pub fn size(\u0026self) -\u003e usize {\n        match self {\n            Opcode::Push(_) | Opcode::Load(_) | Opcode::Store(_) |\n            Opcode::Call(_) | Opcode::CallFFI(_) |\n            Opcode::Jump(_) | Opcode::JumpIf(_) | Opcode::JumpIfNot(_) =\u003e 5,\n            _ =\u003e 1,\n        }\n    }\n}\n\n/// Bytecode errors\n#[derive(Debug, thiserror::Error)]\npub enum BytecodeError {\n    #[error(\"Invalid magic number\")]\n    InvalidMagic,\n\n    #[error(\"Unsupported bytecode version: {0}\")]\n    UnsupportedVersion(u32),\n\n    #[error(\"Too many constants (max {MAX_CONSTANTS})\")]\n    TooManyConstants,\n\n    #[error(\"Too many functions (max {MAX_FUNCTIONS})\")]\n    TooManyFunctions,\n\n    #[error(\"Invalid entry point\")]\n    InvalidEntryPoint,\n\n    #[error(\"Function name too long at index {0}\")]\n    NameTooLong(usize),\n\n    #[error(\"Function too large at index {0}\")]\n    FunctionTooLarge(usize),\n\n    #[error(\"Invalid local variable {1} in function {0}\")]\n    InvalidLocal(usize, u32),\n\n    #[error(\"Invalid opcode: 0x{0:02X}\")]\n    InvalidOpcode(u8),\n\n    #[error(\"Unexpected end of bytecode\")]\n    UnexpectedEndOfBytecode,\n\n    #[error(\"Type error: expected {expected}, got {got}\")]\n    TypeError {\n        expected: \u0026'static str,\n        got: \u0026'static str,\n    },\n\n    #[error(\"Serialization error: {0}\")]\n    SerializationError(String),\n\n    #[error(\"Deserialization error: {0}\")]\n    DeserializationError(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_magic_constant() {\n        assert_eq!(MAGIC, *b\"FZB\\0\");\n    }\n\n    #[test]\n    fn test_opcode_encoding() {\n        let op = Opcode::Push(42);\n        let bytes = op.encode();\n        assert_eq!(bytes.len(), 5);\n        assert_eq!(bytes[0], 0x01);\n\n        let decoded = Opcode::decode(\u0026bytes).unwrap();\n        assert_eq!(decoded, op);\n    }\n\n    #[test]\n    fn test_bytecode_serialization() {\n        let mut bytecode = FusabiBytecode::new(0);\n        bytecode.constants.push(Value::I32(42));\n        bytecode.functions.push(Function {\n            name: \"main\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: Opcode::Push(0).encode(),\n        });\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        assert_eq!(archived.magic, MAGIC);\n        assert_eq!(archived.version, VERSION);\n    }\n\n    #[test]\n    fn test_value_conversions() {\n        let v = Value::I32(42);\n        assert_eq!(v.as_i32().unwrap(), 42);\n        assert!(v.as_bool().is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-vm","src","ffi.rs"],"content":"//! FFI Bridge for Rust function calls\n//!\n//! Allows bytecode to call native Rust functions safely\n\nuse crate::bytecode::Value;\nuse std::collections::HashMap;\n\n/// FFI function signature\npub type FfiFunction = fn(\u0026[Value]) -\u003e Result\u003cValue, FfiError\u003e;\n\n/// FFI function registry\npub struct FfiRegistry {\n    functions: HashMap\u003cString, FfiFunction\u003e,\n}\n\nimpl FfiRegistry {\n    /// Create a new registry\n    pub fn new() -\u003e Self {\n        Self {\n            functions: HashMap::new(),\n        }\n    }\n\n    /// Register an FFI function\n    pub fn register(\u0026mut self, name: \u0026str, func: FfiFunction) {\n        self.functions.insert(name.to_string(), func);\n    }\n\n    /// Get an FFI function by name\n    pub fn get(\u0026self, name: \u0026str) -\u003e Option\u003cFfiFunction\u003e {\n        self.functions.get(name).copied()\n    }\n\n    /// Check if a function is registered\n    pub fn contains(\u0026self, name: \u0026str) -\u003e bool {\n        self.functions.contains_key(name)\n    }\n\n    /// List all registered functions\n    pub fn list(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.functions.keys().cloned().collect()\n    }\n}\n\nimpl Default for FfiRegistry {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// FFI Errors\n#[derive(Debug, thiserror::Error)]\npub enum FfiError {\n    #[error(\"Invalid argument count: expected {expected}, got {got}\")]\n    InvalidArgCount { expected: usize, got: usize },\n\n    #[error(\"Invalid argument type at index {index}: expected {expected}\")]\n    InvalidArgType { index: usize, expected: String },\n\n    #[error(\"Function execution failed: {0}\")]\n    ExecutionError(String),\n\n    #[error(\"Permission denied: {0}\")]\n    PermissionDenied(String),\n}\n\n// Standard library FFI functions\n\n/// Print to stdout\npub fn ffi_print(args: \u0026[Value]) -\u003e Result\u003cValue, FfiError\u003e {\n    if args.len() != 1 {\n        return Err(FfiError::InvalidArgCount {\n            expected: 1,\n            got: args.len(),\n        });\n    }\n\n    println!(\"{}\", args[0]);\n    Ok(Value::Unit)\n}\n\n/// String concatenation\npub fn ffi_string_concat(args: \u0026[Value]) -\u003e Result\u003cValue, FfiError\u003e {\n    if args.len() != 2 {\n        return Err(FfiError::InvalidArgCount {\n            expected: 2,\n            got: args.len(),\n        });\n    }\n\n    let s1 = match \u0026args[0] {\n        Value::String(s) =\u003e s,\n        _ =\u003e {\n            return Err(FfiError::InvalidArgType {\n                index: 0,\n                expected: \"String\".to_string(),\n            })\n        }\n    };\n\n    let s2 = match \u0026args[1] {\n        Value::String(s) =\u003e s,\n        _ =\u003e {\n            return Err(FfiError::InvalidArgType {\n                index: 1,\n                expected: \"String\".to_string(),\n            })\n        }\n    };\n\n    Ok(Value::String(format!(\"{}{}\", s1, s2)))\n}\n\n/// String contains substring\npub fn ffi_string_contains(args: \u0026[Value]) -\u003e Result\u003cValue, FfiError\u003e {\n    if args.len() != 2 {\n        return Err(FfiError::InvalidArgCount {\n            expected: 2,\n            got: args.len(),\n        });\n    }\n\n    let haystack = match \u0026args[0] {\n        Value::String(s) =\u003e s,\n        _ =\u003e {\n            return Err(FfiError::InvalidArgType {\n                index: 0,\n                expected: \"String\".to_string(),\n            })\n        }\n    };\n\n    let needle = match \u0026args[1] {\n        Value::String(s) =\u003e s,\n        _ =\u003e {\n            return Err(FfiError::InvalidArgType {\n                index: 1,\n                expected: \"String\".to_string(),\n            })\n        }\n    };\n\n    Ok(Value::Bool(haystack.contains(needle.as_str())))\n}\n\n/// String length\npub fn ffi_string_len(args: \u0026[Value]) -\u003e Result\u003cValue, FfiError\u003e {\n    if args.len() != 1 {\n        return Err(FfiError::InvalidArgCount {\n            expected: 1,\n            got: args.len(),\n        });\n    }\n\n    let s = match \u0026args[0] {\n        Value::String(s) =\u003e s,\n        _ =\u003e {\n            return Err(FfiError::InvalidArgType {\n                index: 0,\n                expected: \"String\".to_string(),\n            })\n        }\n    };\n\n    Ok(Value::I32(s.len() as i32))\n}\n\n/// Integer to string\npub fn ffi_i32_to_string(args: \u0026[Value]) -\u003e Result\u003cValue, FfiError\u003e {\n    if args.len() != 1 {\n        return Err(FfiError::InvalidArgCount {\n            expected: 1,\n            got: args.len(),\n        });\n    }\n\n    let i = match \u0026args[0] {\n        Value::I32(i) =\u003e i,\n        _ =\u003e {\n            return Err(FfiError::InvalidArgType {\n                index: 0,\n                expected: \"I32\".to_string(),\n            })\n        }\n    };\n\n    Ok(Value::String(i.to_string()))\n}\n\n/// Math: absolute value\npub fn ffi_abs(args: \u0026[Value]) -\u003e Result\u003cValue, FfiError\u003e {\n    if args.len() != 1 {\n        return Err(FfiError::InvalidArgCount {\n            expected: 1,\n            got: args.len(),\n        });\n    }\n\n    match \u0026args[0] {\n        Value::I32(i) =\u003e Ok(Value::I32(i.abs())),\n        Value::I64(i) =\u003e Ok(Value::I64(i.abs())),\n        Value::F32(f) =\u003e Ok(Value::F32(f.abs())),\n        Value::F64(f) =\u003e Ok(Value::F64(f.abs())),\n        _ =\u003e Err(FfiError::InvalidArgType {\n            index: 0,\n            expected: \"Number\".to_string(),\n        }),\n    }\n}\n\n/// Math: square root\npub fn ffi_sqrt(args: \u0026[Value]) -\u003e Result\u003cValue, FfiError\u003e {\n    if args.len() != 1 {\n        return Err(FfiError::InvalidArgCount {\n            expected: 1,\n            got: args.len(),\n        });\n    }\n\n    match \u0026args[0] {\n        Value::F32(f) =\u003e Ok(Value::F32(f.sqrt())),\n        Value::F64(f) =\u003e Ok(Value::F64(f.sqrt())),\n        _ =\u003e Err(FfiError::InvalidArgType {\n            index: 0,\n            expected: \"Float\".to_string(),\n        }),\n    }\n}\n\n/// Create a standard library registry\npub fn create_stdlib() -\u003e FfiRegistry {\n    let mut registry = FfiRegistry::new();\n\n    // I/O functions\n    registry.register(\"print\", ffi_print);\n\n    // String functions\n    registry.register(\"string_concat\", ffi_string_concat);\n    registry.register(\"string_contains\", ffi_string_contains);\n    registry.register(\"string_len\", ffi_string_len);\n\n    // Conversion functions\n    registry.register(\"i32_to_string\", ffi_i32_to_string);\n\n    // Math functions\n    registry.register(\"abs\", ffi_abs);\n    registry.register(\"sqrt\", ffi_sqrt);\n\n    registry\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ffi_print() {\n        let result = ffi_print(\u0026[Value::String(\"Hello\".to_string())]);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Value::Unit);\n    }\n\n    #[test]\n    fn test_string_concat() {\n        let result = ffi_string_concat(\u0026[\n            Value::String(\"Hello, \".to_string()),\n            Value::String(\"World!\".to_string()),\n        ]);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Value::String(\"Hello, World!\".to_string()));\n    }\n\n    #[test]\n    fn test_string_contains() {\n        let result = ffi_string_contains(\u0026[\n            Value::String(\"Hello World\".to_string()),\n            Value::String(\"World\".to_string()),\n        ]);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Value::Bool(true));\n    }\n\n    #[test]\n    fn test_string_len() {\n        let result = ffi_string_len(\u0026[Value::String(\"Hello\".to_string())]);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Value::I32(5));\n    }\n\n    #[test]\n    fn test_abs() {\n        let result = ffi_abs(\u0026[Value::I32(-42)]);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Value::I32(42));\n    }\n\n    #[test]\n    fn test_invalid_arg_count() {\n        let result = ffi_print(\u0026[]);\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            FfiError::InvalidArgCount { expected, got } =\u003e {\n                assert_eq!(expected, 1);\n                assert_eq!(got, 0);\n            }\n            _ =\u003e panic!(\"Expected InvalidArgCount error\"),\n        }\n    }\n\n    #[test]\n    fn test_registry() {\n        let mut registry = FfiRegistry::new();\n        registry.register(\"test\", ffi_print);\n\n        assert!(registry.contains(\"test\"));\n        assert!(!registry.contains(\"nonexistent\"));\n\n        let func = registry.get(\"test\");\n        assert!(func.is_some());\n    }\n\n    #[test]\n    fn test_stdlib_creation() {\n        let stdlib = create_stdlib();\n        assert!(stdlib.contains(\"print\"));\n        assert!(stdlib.contains(\"string_concat\"));\n        assert!(stdlib.contains(\"abs\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-vm","src","lib.rs"],"content":"//! Fusabi VM - AOT Runtime for Scarab Terminal\n//!\n//! A high-performance bytecode VM for executing compiled Fusabi plugins (.fzb)\n//! with \u003c1ms overhead.\n//!\n//! # Features\n//!\n//! - Zero-copy bytecode loading via rkyv\n//! - Stack-based VM with efficient opcode dispatch\n//! - FFI bridge to Rust functions\n//! - Memory sandbox with 1GB limit\n//! - Security enforcement (no syscalls)\n//!\n//! # Example\n//!\n//! ```no_run\n//! use fusabi_vm::{FusabiVM, FusabiBytecode, Value};\n//!\n//! // Load bytecode\n//! let bytecode_bytes = std::fs::read(\"plugin.fzb\").unwrap();\n//! let bytecode = FusabiBytecode::from_bytes(\u0026bytecode_bytes).unwrap();\n//!\n//! // Create VM and register FFI functions\n//! let mut vm = FusabiVM::new();\n//! vm.register_ffi(\"print\", |args| {\n//!     println!(\"{}\", args[0]);\n//!     Ok(Value::Unit)\n//! });\n//!\n//! // Execute\n//! let result = vm.execute(bytecode).unwrap();\n//! ```\n\npub mod bytecode;\npub mod ffi;\npub mod sandbox;\npub mod vm;\n\n// Re-exports\npub use bytecode::{\n    FusabiBytecode, Function, Opcode, Type, Value,\n    BytecodeError, MAGIC, VERSION,\n};\npub use ffi::{FfiFunction, FfiRegistry, FfiError, create_stdlib};\npub use sandbox::{Sandbox, SandboxError, SecurityPolicy, DEFAULT_MEMORY_LIMIT};\npub use vm::{FusabiVM, VmError, ExecutionStats};\n\n/// VM builder for convenient configuration\npub struct VmBuilder {\n    memory_limit: usize,\n    stdlib: bool,\n}\n\nimpl VmBuilder {\n    /// Create a new VM builder\n    pub fn new() -\u003e Self {\n        Self {\n            memory_limit: DEFAULT_MEMORY_LIMIT,\n            stdlib: true,\n        }\n    }\n\n    /// Set memory limit\n    pub fn memory_limit(mut self, limit: usize) -\u003e Self {\n        self.memory_limit = limit;\n        self\n    }\n\n    /// Include/exclude standard library\n    pub fn with_stdlib(mut self, enable: bool) -\u003e Self {\n        self.stdlib = enable;\n        self\n    }\n\n    /// Build the VM\n    pub fn build(self) -\u003e FusabiVM {\n        let mut vm = FusabiVM::new();\n\n        if self.stdlib {\n            let stdlib = create_stdlib();\n            for name in stdlib.list() {\n                if let Some(func) = stdlib.get(\u0026name) {\n                    vm.register_ffi(\u0026name, func);\n                }\n            }\n        }\n\n        vm\n    }\n}\n\nimpl Default for VmBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Bytecode builder for convenient creation\npub struct BytecodeBuilder {\n    bytecode: FusabiBytecode,\n}\n\nimpl BytecodeBuilder {\n    /// Create a new bytecode builder\n    pub fn new() -\u003e Self {\n        Self {\n            bytecode: FusabiBytecode::new(0),\n        }\n    }\n\n    /// Add a constant\n    pub fn add_constant(mut self, value: Value) -\u003e (Self, u32) {\n        let idx = self.bytecode.constants.len() as u32;\n        self.bytecode.constants.push(value);\n        (self, idx)\n    }\n\n    /// Add a function\n    pub fn add_function(mut self, func: Function) -\u003e (Self, u32) {\n        let idx = self.bytecode.functions.len() as u32;\n        self.bytecode.functions.push(func);\n        (self, idx)\n    }\n\n    /// Add an FFI import\n    pub fn add_ffi_import(mut self, name: \u0026str) -\u003e (Self, u32) {\n        let idx = self.bytecode.ffi_imports.len() as u32;\n        self.bytecode.ffi_imports.push(name.to_string());\n        (self, idx)\n    }\n\n    /// Set entry point\n    pub fn entry_point(mut self, idx: u32) -\u003e Self {\n        self.bytecode.entry_point = idx;\n        self\n    }\n\n    /// Build the bytecode\n    pub fn build(self) -\u003e Result\u003cFusabiBytecode, BytecodeError\u003e {\n        self.bytecode.validate()?;\n        Ok(self.bytecode)\n    }\n}\n\nimpl Default for BytecodeBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vm_builder() {\n        let vm = VmBuilder::new()\n            .memory_limit(512 * 1024 * 1024)\n            .with_stdlib(true)\n            .build();\n\n        // VM should be created successfully\n        assert_eq!(vm.stats().instructions_executed, 0);\n    }\n\n    #[test]\n    fn test_bytecode_builder() {\n        let (builder, const_idx) = BytecodeBuilder::new()\n            .add_constant(Value::I32(42));\n\n        let (builder, _ffi_idx) = builder.add_ffi_import(\"print\");\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(const_idx).encode());\n        code.extend(Opcode::Ret.encode());\n\n        let func = Function {\n            name: \"main\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        };\n\n        let (builder, func_idx) = builder.add_function(func);\n        let bytecode = builder.entry_point(func_idx).build();\n\n        assert!(bytecode.is_ok());\n    }\n\n    #[test]\n    fn test_integration() {\n        // Build bytecode\n        let (builder, const_idx) = BytecodeBuilder::new()\n            .add_constant(Value::I32(10));\n        let (builder, const_idx2) = builder.add_constant(Value::I32(5));\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(const_idx).encode());\n        code.extend(Opcode::Push(const_idx2).encode());\n        code.extend(Opcode::Add.encode());\n        code.extend(Opcode::Ret.encode());\n\n        let func = Function {\n            name: \"main\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        };\n\n        let (builder, func_idx) = builder.add_function(func);\n        let bytecode = builder.entry_point(func_idx).build().unwrap();\n\n        // Serialize\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        // Execute\n        let mut vm = VmBuilder::new().build();\n        let result = vm.execute(archived).unwrap();\n\n        assert_eq!(result, Value::I32(15));\n        assert!(vm.stats().instructions_executed \u003e 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-vm","src","sandbox.rs"],"content":"//! Memory Sandbox for VM Security\n//!\n//! Enforces memory limits and prevents unsafe operations\n\nuse std::alloc::{alloc, dealloc, Layout};\nuse std::ptr::NonNull;\n\n/// Default memory limit: 1GB\npub const DEFAULT_MEMORY_LIMIT: usize = 1024 * 1024 * 1024;\n\n/// Maximum allocation size\npub const MAX_ALLOCATION_SIZE: usize = 100 * 1024 * 1024; // 100MB\n\n/// Memory sandbox\npub struct Sandbox {\n    /// Total memory limit\n    memory_limit: usize,\n\n    /// Current memory usage\n    memory_used: usize,\n\n    /// Allocated blocks\n    allocations: Vec\u003cAllocationInfo\u003e,\n}\n\n#[derive(Debug, Clone)]\nstruct AllocationInfo {\n    ptr: usize,\n    size: usize,\n    layout: Layout,\n}\n\nimpl Sandbox {\n    /// Create a new sandbox with default limits\n    pub fn new() -\u003e Self {\n        Self::with_limit(DEFAULT_MEMORY_LIMIT)\n    }\n\n    /// Create a sandbox with custom memory limit\n    pub fn with_limit(limit: usize) -\u003e Self {\n        Self {\n            memory_limit: limit,\n            memory_used: 0,\n            allocations: Vec::new(),\n        }\n    }\n\n    /// Allocate memory within sandbox\n    pub fn allocate(\u0026mut self, size: usize) -\u003e Result\u003cNonNull\u003cu8\u003e, SandboxError\u003e {\n        // Check size limit\n        if size \u003e MAX_ALLOCATION_SIZE {\n            return Err(SandboxError::AllocationTooLarge(size));\n        }\n\n        // Check if allocation would exceed limit\n        if self.memory_used + size \u003e self.memory_limit {\n            return Err(SandboxError::MemoryLimitExceeded {\n                requested: size,\n                available: self.memory_limit - self.memory_used,\n            });\n        }\n\n        // Create layout\n        let layout = Layout::from_size_align(size, 8)\n            .map_err(|_| SandboxError::InvalidLayout)?;\n\n        // Allocate\n        let ptr = unsafe { alloc(layout) };\n        if ptr.is_null() {\n            return Err(SandboxError::AllocationFailed);\n        }\n\n        let ptr = NonNull::new(ptr).expect(\"Allocated pointer should not be null\");\n\n        // Track allocation\n        self.allocations.push(AllocationInfo {\n            ptr: ptr.as_ptr() as usize,\n            size,\n            layout,\n        });\n\n        self.memory_used += size;\n\n        Ok(ptr)\n    }\n\n    /// Deallocate memory\n    pub fn deallocate(\u0026mut self, ptr: NonNull\u003cu8\u003e) -\u003e Result\u003c(), SandboxError\u003e {\n        let ptr_addr = ptr.as_ptr() as usize;\n\n        // Find allocation\n        let idx = self\n            .allocations\n            .iter()\n            .position(|a| a.ptr == ptr_addr)\n            .ok_or(SandboxError::InvalidPointer)?;\n\n        let info = self.allocations.remove(idx);\n\n        // Deallocate\n        unsafe {\n            dealloc(ptr.as_ptr(), info.layout);\n        }\n\n        self.memory_used -= info.size;\n\n        Ok(())\n    }\n\n    /// Check if a memory access is valid\n    pub fn validate_access(\u0026self, ptr: usize, size: usize) -\u003e Result\u003c(), SandboxError\u003e {\n        // Find containing allocation\n        let _allocation = self\n            .allocations\n            .iter()\n            .find(|a| ptr \u003e= a.ptr \u0026\u0026 ptr + size \u003c= a.ptr + a.size)\n            .ok_or(SandboxError::InvalidMemoryAccess { ptr, size })?;\n\n        Ok(())\n    }\n\n    /// Get current memory usage\n    pub fn memory_used(\u0026self) -\u003e usize {\n        self.memory_used\n    }\n\n    /// Get memory limit\n    pub fn memory_limit(\u0026self) -\u003e usize {\n        self.memory_limit\n    }\n\n    /// Get number of allocations\n    pub fn allocation_count(\u0026self) -\u003e usize {\n        self.allocations.len()\n    }\n\n    /// Reset sandbox (deallocate all memory)\n    pub fn reset(\u0026mut self) {\n        // Deallocate all blocks\n        for info in self.allocations.drain(..) {\n            unsafe {\n                dealloc(info.ptr as *mut u8, info.layout);\n            }\n        }\n\n        self.memory_used = 0;\n    }\n\n    /// Check if sandbox is within limits\n    pub fn check_limits(\u0026self) -\u003e Result\u003c(), SandboxError\u003e {\n        if self.memory_used \u003e self.memory_limit {\n            return Err(SandboxError::MemoryLimitExceeded {\n                requested: 0,\n                available: 0,\n            });\n        }\n\n        Ok(())\n    }\n}\n\nimpl Drop for Sandbox {\n    fn drop(\u0026mut self) {\n        self.reset();\n    }\n}\n\nimpl Default for Sandbox {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Sandbox Errors\n#[derive(Debug, thiserror::Error)]\npub enum SandboxError {\n    #[error(\"Memory limit exceeded: requested {requested}, available {available}\")]\n    MemoryLimitExceeded { requested: usize, available: usize },\n\n    #[error(\"Allocation too large: {0} bytes (max {MAX_ALLOCATION_SIZE})\")]\n    AllocationTooLarge(usize),\n\n    #[error(\"Allocation failed\")]\n    AllocationFailed,\n\n    #[error(\"Invalid memory layout\")]\n    InvalidLayout,\n\n    #[error(\"Invalid pointer\")]\n    InvalidPointer,\n\n    #[error(\"Invalid memory access at 0x{ptr:x}, size {size}\")]\n    InvalidMemoryAccess { ptr: usize, size: usize },\n\n    #[error(\"Syscall not allowed: {0}\")]\n    SyscallDenied(String),\n}\n\n/// Security policy\npub struct SecurityPolicy {\n    /// Allow file I/O\n    pub allow_file_io: bool,\n\n    /// Allow network access\n    pub allow_network: bool,\n\n    /// Allow spawning processes\n    pub allow_process_spawn: bool,\n\n    /// Allow environment variable access\n    pub allow_env_access: bool,\n}\n\nimpl SecurityPolicy {\n    /// Create a restrictive policy (no permissions)\n    pub fn restrictive() -\u003e Self {\n        Self {\n            allow_file_io: false,\n            allow_network: false,\n            allow_process_spawn: false,\n            allow_env_access: false,\n        }\n    }\n\n    /// Create a permissive policy (all permissions)\n    pub fn permissive() -\u003e Self {\n        Self {\n            allow_file_io: true,\n            allow_network: true,\n            allow_process_spawn: true,\n            allow_env_access: true,\n        }\n    }\n\n    /// Check if an operation is allowed\n    pub fn check_permission(\u0026self, operation: \u0026str) -\u003e Result\u003c(), SandboxError\u003e {\n        let allowed = match operation {\n            \"file_read\" | \"file_write\" =\u003e self.allow_file_io,\n            \"network_connect\" | \"network_bind\" =\u003e self.allow_network,\n            \"process_spawn\" =\u003e self.allow_process_spawn,\n            \"env_read\" | \"env_write\" =\u003e self.allow_env_access,\n            _ =\u003e false,\n        };\n\n        if !allowed {\n            return Err(SandboxError::SyscallDenied(operation.to_string()));\n        }\n\n        Ok(())\n    }\n}\n\nimpl Default for SecurityPolicy {\n    fn default() -\u003e Self {\n        Self::restrictive()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sandbox_creation() {\n        let sandbox = Sandbox::new();\n        assert_eq!(sandbox.memory_used(), 0);\n        assert_eq!(sandbox.memory_limit(), DEFAULT_MEMORY_LIMIT);\n    }\n\n    #[test]\n    fn test_allocation() {\n        let mut sandbox = Sandbox::new();\n        let ptr = sandbox.allocate(1024).unwrap();\n        assert_eq!(sandbox.memory_used(), 1024);\n        assert_eq!(sandbox.allocation_count(), 1);\n\n        sandbox.deallocate(ptr).unwrap();\n        assert_eq!(sandbox.memory_used(), 0);\n        assert_eq!(sandbox.allocation_count(), 0);\n    }\n\n    #[test]\n    fn test_memory_limit() {\n        let mut sandbox = Sandbox::with_limit(1024);\n        let result = sandbox.allocate(2048);\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            SandboxError::MemoryLimitExceeded { .. } =\u003e {}\n            _ =\u003e panic!(\"Expected MemoryLimitExceeded error\"),\n        }\n    }\n\n    #[test]\n    fn test_allocation_too_large() {\n        let mut sandbox = Sandbox::new();\n        let result = sandbox.allocate(MAX_ALLOCATION_SIZE + 1);\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            SandboxError::AllocationTooLarge(_) =\u003e {}\n            _ =\u003e panic!(\"Expected AllocationTooLarge error\"),\n        }\n    }\n\n    #[test]\n    fn test_reset() {\n        let mut sandbox = Sandbox::new();\n        sandbox.allocate(1024).unwrap();\n        sandbox.allocate(2048).unwrap();\n\n        assert_eq!(sandbox.memory_used(), 3072);\n        assert_eq!(sandbox.allocation_count(), 2);\n\n        sandbox.reset();\n\n        assert_eq!(sandbox.memory_used(), 0);\n        assert_eq!(sandbox.allocation_count(), 0);\n    }\n\n    #[test]\n    fn test_security_policy() {\n        let policy = SecurityPolicy::restrictive();\n        assert!(policy.check_permission(\"file_read\").is_err());\n        assert!(policy.check_permission(\"network_connect\").is_err());\n\n        let policy = SecurityPolicy::permissive();\n        assert!(policy.check_permission(\"file_read\").is_ok());\n        assert!(policy.check_permission(\"network_connect\").is_ok());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","fusabi-vm","src","vm.rs"],"content":"//! Fusabi Virtual Machine\n//!\n//! Stack-based VM with FFI support and security sandbox\n\nuse crate::bytecode::{ArchivedFusabiBytecode, Opcode, Value};\nuse crate::ffi::{FfiFunction, FfiRegistry};\nuse crate::sandbox::Sandbox;\n\n/// Maximum stack depth\nconst MAX_STACK_SIZE: usize = 10_000;\n\n/// Maximum call stack depth\nconst MAX_CALL_DEPTH: usize = 1_000;\n\n/// Execution frame\n#[derive(Debug, Clone)]\nstruct Frame {\n    /// Function index\n    function_idx: u32,\n\n    /// Program counter\n    pc: usize,\n\n    /// Base pointer for locals\n    base_ptr: usize,\n\n    /// Number of locals\n    num_locals: u32,\n}\n\n/// Virtual Machine state\npub struct FusabiVM {\n    /// Value stack\n    stack: Vec\u003cValue\u003e,\n\n    /// Call stack\n    call_stack: Vec\u003cFrame\u003e,\n\n    /// FFI function registry\n    ffi_registry: FfiRegistry,\n\n    /// Memory sandbox\n    sandbox: Sandbox,\n\n    /// Execution statistics\n    stats: ExecutionStats,\n}\n\n/// Execution statistics\n#[derive(Debug, Default)]\npub struct ExecutionStats {\n    pub instructions_executed: u64,\n    pub ffi_calls: u64,\n    pub max_stack_depth: usize,\n    pub max_call_depth: usize,\n}\n\nimpl FusabiVM {\n    /// Create a new VM with default settings\n    pub fn new() -\u003e Self {\n        Self {\n            stack: Vec::with_capacity(1024),\n            call_stack: Vec::with_capacity(64),\n            ffi_registry: FfiRegistry::new(),\n            sandbox: Sandbox::new(),\n            stats: ExecutionStats::default(),\n        }\n    }\n\n    /// Register an FFI function\n    pub fn register_ffi(\u0026mut self, name: \u0026str, func: FfiFunction) {\n        self.ffi_registry.register(name, func);\n    }\n\n    /// Execute bytecode from archived format (zero-copy)\n    pub fn execute(\u0026mut self, bytecode: \u0026ArchivedFusabiBytecode) -\u003e Result\u003cValue, VmError\u003e {\n        // Validate bytecode\n        if bytecode.magic != crate::bytecode::MAGIC {\n            return Err(VmError::InvalidBytecode(\"Bad magic number\".into()));\n        }\n\n        // Get entry point\n        let entry_idx = bytecode.entry_point as usize;\n        if entry_idx \u003e= bytecode.functions.len() {\n            return Err(VmError::InvalidBytecode(\"Invalid entry point\".into()));\n        }\n\n        // Initialize execution\n        self.reset();\n        self.push_frame(entry_idx, 0)?;\n\n        // Main execution loop\n        while !self.call_stack.is_empty() {\n            self.step(bytecode)?;\n        }\n\n        // Return final stack value or Unit\n        Ok(self.stack.pop().unwrap_or(Value::Unit))\n    }\n\n    /// Reset VM state\n    fn reset(\u0026mut self) {\n        self.stack.clear();\n        self.call_stack.clear();\n        self.sandbox.reset();\n        self.stats = ExecutionStats::default();\n    }\n\n    /// Push a new call frame\n    fn push_frame(\u0026mut self, function_idx: usize, num_locals: u32) -\u003e Result\u003c(), VmError\u003e {\n        if self.call_stack.len() \u003e= MAX_CALL_DEPTH {\n            return Err(VmError::StackOverflow);\n        }\n\n        let base_ptr = self.stack.len();\n\n        // Reserve space for locals\n        for _ in 0..num_locals {\n            self.stack.push(Value::Unit);\n        }\n\n        self.call_stack.push(Frame {\n            function_idx: function_idx as u32,\n            pc: 0,\n            base_ptr,\n            num_locals,\n        });\n\n        self.stats.max_call_depth = self.stats.max_call_depth.max(self.call_stack.len());\n\n        Ok(())\n    }\n\n    /// Pop current call frame\n    fn pop_frame(\u0026mut self) -\u003e Result\u003c(), VmError\u003e {\n        let frame = self.call_stack.pop().ok_or(VmError::StackUnderflow)?;\n\n        // Save return value if present\n        let return_value = if self.stack.len() \u003e frame.base_ptr {\n            Some(self.stack.pop().unwrap())\n        } else {\n            None\n        };\n\n        // Remove locals from stack\n        self.stack.truncate(frame.base_ptr);\n\n        // Push return value back\n        if let Some(value) = return_value {\n            self.stack.push(value);\n        }\n\n        Ok(())\n    }\n\n    /// Execute one instruction\n    fn step(\u0026mut self, bytecode: \u0026ArchivedFusabiBytecode) -\u003e Result\u003c(), VmError\u003e {\n        let frame = self.call_stack.last_mut().ok_or(VmError::StackUnderflow)?;\n        let function = \u0026bytecode.functions[frame.function_idx as usize];\n        let bytecode_slice = \u0026function.bytecode[frame.pc..];\n\n        if bytecode_slice.is_empty() {\n            return Err(VmError::UnexpectedEndOfBytecode);\n        }\n\n        let opcode = Opcode::decode(bytecode_slice)\n            .map_err(|e| VmError::InvalidBytecode(e.to_string()))?;\n\n        // Update program counter\n        let pc_increment = opcode.size();\n        frame.pc += pc_increment;\n\n        // Execute opcode\n        self.execute_opcode(opcode, bytecode)?;\n\n        self.stats.instructions_executed += 1;\n        self.stats.max_stack_depth = self.stats.max_stack_depth.max(self.stack.len());\n\n        Ok(())\n    }\n\n    /// Execute a single opcode\n    fn execute_opcode(\n        \u0026mut self,\n        opcode: Opcode,\n        bytecode: \u0026ArchivedFusabiBytecode,\n    ) -\u003e Result\u003c(), VmError\u003e {\n        match opcode {\n            // Stack operations\n            Opcode::Nop =\u003e {}\n\n            Opcode::Push(idx) =\u003e {\n                let value = bytecode.constants.get(idx as usize)\n                    .ok_or(VmError::InvalidConstant(idx))?;\n                self.push(self.archive_value_to_value(value))?;\n            }\n\n            Opcode::Pop =\u003e {\n                self.pop()?;\n            }\n\n            Opcode::Dup =\u003e {\n                let value = self.peek()?.clone();\n                self.push(value)?;\n            }\n\n            // Local variables\n            Opcode::Load(local_idx) =\u003e {\n                let frame = self.call_stack.last().ok_or(VmError::StackUnderflow)?;\n                if local_idx \u003e= frame.num_locals {\n                    return Err(VmError::InvalidLocal(local_idx));\n                }\n                let value = self.stack[frame.base_ptr + local_idx as usize].clone();\n                self.push(value)?;\n            }\n\n            Opcode::Store(local_idx) =\u003e {\n                let base_ptr = {\n                    let frame = self.call_stack.last().ok_or(VmError::StackUnderflow)?;\n                    if local_idx \u003e= frame.num_locals {\n                        return Err(VmError::InvalidLocal(local_idx));\n                    }\n                    frame.base_ptr\n                };\n                let value = self.pop()?;\n                self.stack[base_ptr + local_idx as usize] = value;\n            }\n\n            // Control flow\n            Opcode::Call(func_idx) =\u003e {\n                let function = bytecode.functions.get(func_idx as usize)\n                    .ok_or(VmError::InvalidFunction(func_idx))?;\n                self.push_frame(func_idx as usize, function.locals)?;\n            }\n\n            Opcode::CallFFI(ffi_idx) =\u003e {\n                let ffi_name = bytecode.ffi_imports.get(ffi_idx as usize)\n                    .ok_or(VmError::InvalidFfiImport(ffi_idx))?;\n\n                let function = self.ffi_registry.get(\u0026ffi_name.to_string())\n                    .ok_or_else(|| VmError::FfiNotFound(ffi_name.to_string()))?;\n\n                let result = function(\u0026self.stack)\n                    .map_err(|e| VmError::FfiError(e.to_string()))?;\n\n                self.push(result)?;\n                self.stats.ffi_calls += 1;\n            }\n\n            Opcode::Ret =\u003e {\n                self.pop_frame()?;\n            }\n\n            Opcode::Jump(offset) =\u003e {\n                let frame = self.call_stack.last_mut().ok_or(VmError::StackUnderflow)?;\n                let new_pc = (frame.pc as i32 + offset) as usize;\n                frame.pc = new_pc;\n            }\n\n            Opcode::JumpIf(offset) =\u003e {\n                let cond = self.pop()?.as_bool()\n                    .map_err(|e| VmError::InvalidBytecode(e.to_string()))?;\n                if cond {\n                    let frame = self.call_stack.last_mut().ok_or(VmError::StackUnderflow)?;\n                    let new_pc = (frame.pc as i32 + offset) as usize;\n                    frame.pc = new_pc;\n                }\n            }\n\n            Opcode::JumpIfNot(offset) =\u003e {\n                let cond = self.pop()?.as_bool()\n                    .map_err(|e| VmError::InvalidBytecode(e.to_string()))?;\n                if !cond {\n                    let frame = self.call_stack.last_mut().ok_or(VmError::StackUnderflow)?;\n                    let new_pc = (frame.pc as i32 + offset) as usize;\n                    frame.pc = new_pc;\n                }\n            }\n\n            // Arithmetic\n            Opcode::Add =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e Ok(Value::I32(x + y)),\n                (Value::I64(x), Value::I64(y)) =\u003e Ok(Value::I64(x + y)),\n                (Value::F32(x), Value::F32(y)) =\u003e Ok(Value::F32(x + y)),\n                (Value::F64(x), Value::F64(y)) =\u003e Ok(Value::F64(x + y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Sub =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e Ok(Value::I32(x - y)),\n                (Value::I64(x), Value::I64(y)) =\u003e Ok(Value::I64(x - y)),\n                (Value::F32(x), Value::F32(y)) =\u003e Ok(Value::F32(x - y)),\n                (Value::F64(x), Value::F64(y)) =\u003e Ok(Value::F64(x - y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Mul =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e Ok(Value::I32(x * y)),\n                (Value::I64(x), Value::I64(y)) =\u003e Ok(Value::I64(x * y)),\n                (Value::F32(x), Value::F32(y)) =\u003e Ok(Value::F32(x * y)),\n                (Value::F64(x), Value::F64(y)) =\u003e Ok(Value::F64(x * y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Div =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e {\n                    if *y == 0 {\n                        Err(VmError::DivisionByZero)\n                    } else {\n                        Ok(Value::I32(x / y))\n                    }\n                }\n                (Value::I64(x), Value::I64(y)) =\u003e {\n                    if *y == 0 {\n                        Err(VmError::DivisionByZero)\n                    } else {\n                        Ok(Value::I64(x / y))\n                    }\n                }\n                (Value::F32(x), Value::F32(y)) =\u003e Ok(Value::F32(x / y)),\n                (Value::F64(x), Value::F64(y)) =\u003e Ok(Value::F64(x / y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Mod =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e {\n                    if *y == 0 {\n                        Err(VmError::DivisionByZero)\n                    } else {\n                        Ok(Value::I32(x % y))\n                    }\n                }\n                (Value::I64(x), Value::I64(y)) =\u003e {\n                    if *y == 0 {\n                        Err(VmError::DivisionByZero)\n                    } else {\n                        Ok(Value::I64(x % y))\n                    }\n                }\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Neg =\u003e {\n                let val = self.pop()?;\n                let result = match val {\n                    Value::I32(x) =\u003e Value::I32(-x),\n                    Value::I64(x) =\u003e Value::I64(-x),\n                    Value::F32(x) =\u003e Value::F32(-x),\n                    Value::F64(x) =\u003e Value::F64(-x),\n                    _ =\u003e return Err(VmError::TypeMismatch),\n                };\n                self.push(result)?;\n            }\n\n            // Comparison\n            Opcode::Eq =\u003e self.binary_op(|a, b| Ok(Value::Bool(a == b)))?,\n            Opcode::Ne =\u003e self.binary_op(|a, b| Ok(Value::Bool(a != b)))?,\n\n            Opcode::Lt =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e Ok(Value::Bool(x \u003c y)),\n                (Value::I64(x), Value::I64(y)) =\u003e Ok(Value::Bool(x \u003c y)),\n                (Value::F32(x), Value::F32(y)) =\u003e Ok(Value::Bool(x \u003c y)),\n                (Value::F64(x), Value::F64(y)) =\u003e Ok(Value::Bool(x \u003c y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Le =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e Ok(Value::Bool(x \u003c= y)),\n                (Value::I64(x), Value::I64(y)) =\u003e Ok(Value::Bool(x \u003c= y)),\n                (Value::F32(x), Value::F32(y)) =\u003e Ok(Value::Bool(x \u003c= y)),\n                (Value::F64(x), Value::F64(y)) =\u003e Ok(Value::Bool(x \u003c= y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Gt =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e Ok(Value::Bool(x \u003e y)),\n                (Value::I64(x), Value::I64(y)) =\u003e Ok(Value::Bool(x \u003e y)),\n                (Value::F32(x), Value::F32(y)) =\u003e Ok(Value::Bool(x \u003e y)),\n                (Value::F64(x), Value::F64(y)) =\u003e Ok(Value::Bool(x \u003e y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Ge =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::I32(x), Value::I32(y)) =\u003e Ok(Value::Bool(x \u003e= y)),\n                (Value::I64(x), Value::I64(y)) =\u003e Ok(Value::Bool(x \u003e= y)),\n                (Value::F32(x), Value::F32(y)) =\u003e Ok(Value::Bool(x \u003e= y)),\n                (Value::F64(x), Value::F64(y)) =\u003e Ok(Value::Bool(x \u003e= y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            // Logical\n            Opcode::And =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::Bool(x), Value::Bool(y)) =\u003e Ok(Value::Bool(*x \u0026\u0026 *y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Or =\u003e self.binary_op(|a, b| match (a, b) {\n                (Value::Bool(x), Value::Bool(y)) =\u003e Ok(Value::Bool(*x || *y)),\n                _ =\u003e Err(VmError::TypeMismatch),\n            })?,\n\n            Opcode::Not =\u003e {\n                let val = self.pop()?;\n                match val {\n                    Value::Bool(b) =\u003e self.push(Value::Bool(!b))?,\n                    _ =\u003e return Err(VmError::TypeMismatch),\n                }\n            }\n\n            Opcode::Halt =\u003e {\n                self.call_stack.clear();\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Helper for binary operations\n    fn binary_op\u003cF\u003e(\u0026mut self, op: F) -\u003e Result\u003c(), VmError\u003e\n    where\n        F: FnOnce(\u0026Value, \u0026Value) -\u003e Result\u003cValue, VmError\u003e,\n    {\n        let b = self.pop()?;\n        let a = self.pop()?;\n        let result = op(\u0026a, \u0026b)?;\n        self.push(result)?;\n        Ok(())\n    }\n\n    /// Push value to stack\n    fn push(\u0026mut self, value: Value) -\u003e Result\u003c(), VmError\u003e {\n        if self.stack.len() \u003e= MAX_STACK_SIZE {\n            return Err(VmError::StackOverflow);\n        }\n        self.stack.push(value);\n        Ok(())\n    }\n\n    /// Pop value from stack\n    fn pop(\u0026mut self) -\u003e Result\u003cValue, VmError\u003e {\n        self.stack.pop().ok_or(VmError::StackUnderflow)\n    }\n\n    /// Peek top of stack\n    fn peek(\u0026self) -\u003e Result\u003c\u0026Value, VmError\u003e {\n        self.stack.last().ok_or(VmError::StackUnderflow)\n    }\n\n    /// Convert archived value to runtime value\n    fn archive_value_to_value(\u0026self, archived: \u0026crate::bytecode::ArchivedValue) -\u003e Value {\n        // This is a simplified conversion - in production we'd use proper rkyv deserialization\n        match archived {\n            crate::bytecode::ArchivedValue::Unit =\u003e Value::Unit,\n            crate::bytecode::ArchivedValue::Bool(b) =\u003e Value::Bool(*b),\n            crate::bytecode::ArchivedValue::I32(i) =\u003e Value::I32(*i),\n            crate::bytecode::ArchivedValue::I64(i) =\u003e Value::I64(*i),\n            crate::bytecode::ArchivedValue::F32(f) =\u003e Value::F32(*f),\n            crate::bytecode::ArchivedValue::F64(f) =\u003e Value::F64(*f),\n            crate::bytecode::ArchivedValue::Char(c) =\u003e Value::Char(*c),\n            crate::bytecode::ArchivedValue::String(s) =\u003e Value::String(s.to_string()),\n        }\n    }\n\n    /// Get execution statistics\n    pub fn stats(\u0026self) -\u003e \u0026ExecutionStats {\n        \u0026self.stats\n    }\n}\n\nimpl Default for FusabiVM {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// VM Errors\n#[derive(Debug, thiserror::Error)]\npub enum VmError {\n    #[error(\"Stack overflow\")]\n    StackOverflow,\n\n    #[error(\"Stack underflow\")]\n    StackUnderflow,\n\n    #[error(\"Invalid bytecode: {0}\")]\n    InvalidBytecode(String),\n\n    #[error(\"Invalid constant index: {0}\")]\n    InvalidConstant(u32),\n\n    #[error(\"Invalid function index: {0}\")]\n    InvalidFunction(u32),\n\n    #[error(\"Invalid local variable: {0}\")]\n    InvalidLocal(u32),\n\n    #[error(\"Invalid FFI import: {0}\")]\n    InvalidFfiImport(u32),\n\n    #[error(\"FFI function not found: {0}\")]\n    FfiNotFound(String),\n\n    #[error(\"FFI error: {0}\")]\n    FfiError(String),\n\n    #[error(\"Type mismatch\")]\n    TypeMismatch,\n\n    #[error(\"Division by zero\")]\n    DivisionByZero,\n\n    #[error(\"Unexpected end of bytecode\")]\n    UnexpectedEndOfBytecode,\n\n    #[error(\"Memory violation: {0}\")]\n    MemoryViolation(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::bytecode::{FusabiBytecode, Function, Type};\n\n    #[test]\n    fn test_vm_creation() {\n        let vm = FusabiVM::new();\n        assert_eq!(vm.stack.len(), 0);\n        assert_eq!(vm.call_stack.len(), 0);\n    }\n\n    #[test]\n    fn test_simple_push_execution() {\n        let mut bytecode = FusabiBytecode::new(0);\n        bytecode.constants.push(Value::I32(42));\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(0).encode());\n        code.extend(Opcode::Ret.encode());\n\n        bytecode.functions.push(Function {\n            name: \"main\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        });\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        let mut vm = FusabiVM::new();\n        let result = vm.execute(archived).unwrap();\n\n        assert_eq!(result, Value::I32(42));\n    }\n\n    #[test]\n    fn test_arithmetic() {\n        let mut bytecode = FusabiBytecode::new(0);\n        bytecode.constants.push(Value::I32(10));\n        bytecode.constants.push(Value::I32(5));\n\n        let mut code = Vec::new();\n        code.extend(Opcode::Push(0).encode()); // 10\n        code.extend(Opcode::Push(1).encode()); // 5\n        code.extend(Opcode::Add.encode());     // 10 + 5\n        code.extend(Opcode::Ret.encode());\n\n        bytecode.functions.push(Function {\n            name: \"main\".to_string(),\n            params: vec![],\n            return_type: Type::I32,\n            locals: 0,\n            bytecode: code,\n        });\n\n        let bytes = bytecode.to_bytes().unwrap();\n        let archived = FusabiBytecode::from_bytes(\u0026bytes).unwrap();\n\n        let mut vm = FusabiVM::new();\n        let result = vm.execute(archived).unwrap();\n\n        assert_eq!(result, Value::I32(15));\n    }\n}\n","traces":[{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","ipc.rs"],"content":"use anyhow::{Context, Result};\nuse bevy::prelude::*;\nuse scarab_protocol::{\n    ControlMessage, SOCKET_PATH, MAX_MESSAGE_SIZE,\n    RECONNECT_DELAY_MS, MAX_RECONNECT_ATTEMPTS\n};\nuse std::sync::Arc;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::UnixStream;\nuse tokio::sync::RwLock;\nuse tokio::time::{sleep, Duration};\n\n/// Bevy resource for IPC communication\n#[derive(Resource)]\npub struct IpcChannel {\n    inner: Arc\u003cRwLock\u003cOption\u003cIpcConnection\u003e\u003e\u003e,\n    runtime: tokio::runtime::Runtime,\n}\n\nstruct IpcConnection {\n    stream: UnixStream,\n    connected: bool,\n}\n\nimpl IpcChannel {\n    /// Create new IPC channel with automatic connection\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let runtime = tokio::runtime::Builder::new_multi_thread()\n            .enable_all()\n            .worker_threads(2)\n            .thread_name(\"ipc-worker\")\n            .build()\n            .context(\"Failed to create Tokio runtime\")?;\n\n        let inner = Arc::new(RwLock::new(None));\n\n        // Spawn connection task\n        let inner_clone = inner.clone();\n        runtime.spawn(async move {\n            if let Err(e) = establish_connection(inner_clone).await {\n                eprintln!(\"Failed to establish initial connection: {}\", e);\n            }\n        });\n\n        Ok(Self { inner, runtime })\n    }\n\n    /// Send a control message to the daemon\n    pub fn send(\u0026self, msg: ControlMessage) {\n        let inner = self.inner.clone();\n        self.runtime.spawn(async move {\n            if let Err(e) = send_message(inner, msg).await {\n                eprintln!(\"Failed to send message: {}\", e);\n            }\n        });\n    }\n\n    /// Check if connected\n    pub fn is_connected(\u0026self) -\u003e bool {\n        self.runtime.block_on(async {\n            let conn = self.inner.read().await;\n            conn.as_ref().map_or(false, |c| c.connected)\n        })\n    }\n\n    /// Force reconnection\n    pub fn reconnect(\u0026self) {\n        let inner = self.inner.clone();\n        self.runtime.spawn(async move {\n            println!(\"Forcing reconnection...\");\n            if let Err(e) = establish_connection(inner).await {\n                eprintln!(\"Reconnection failed: {}\", e);\n            }\n        });\n    }\n}\n\n/// Establish connection with exponential backoff\nasync fn establish_connection(inner: Arc\u003cRwLock\u003cOption\u003cIpcConnection\u003e\u003e\u003e) -\u003e Result\u003c()\u003e {\n    let mut attempts = 0;\n    let mut delay_ms = RECONNECT_DELAY_MS;\n\n    loop {\n        match UnixStream::connect(SOCKET_PATH).await {\n            Ok(stream) =\u003e {\n                println!(\"Connected to daemon at {}\", SOCKET_PATH);\n                let mut conn = inner.write().await;\n                *conn = Some(IpcConnection {\n                    stream,\n                    connected: true,\n                });\n                return Ok(());\n            }\n            Err(e) =\u003e {\n                attempts += 1;\n                if attempts \u003e= MAX_RECONNECT_ATTEMPTS {\n                    return Err(e).context(format!(\n                        \"Failed to connect after {} attempts\",\n                        MAX_RECONNECT_ATTEMPTS\n                    ));\n                }\n\n                eprintln!(\n                    \"Connection attempt {} failed: {}. Retrying in {}ms...\",\n                    attempts, e, delay_ms\n                );\n\n                sleep(Duration::from_millis(delay_ms)).await;\n\n                // Exponential backoff with cap at 5 seconds\n                delay_ms = (delay_ms * 2).min(5000);\n            }\n        }\n    }\n}\n\n/// Send message with automatic reconnection on failure\nasync fn send_message(\n    inner: Arc\u003cRwLock\u003cOption\u003cIpcConnection\u003e\u003e\u003e,\n    msg: ControlMessage,\n) -\u003e Result\u003c()\u003e {\n    // Serialize message\n    let bytes = rkyv::to_bytes::\u003c_, MAX_MESSAGE_SIZE\u003e(\u0026msg)\n        .context(\"Failed to serialize message\")?;\n\n    let len = bytes.len();\n    if len \u003e MAX_MESSAGE_SIZE {\n        anyhow::bail!(\"Message too large: {} bytes\", len);\n    }\n\n    // Try to send\n    let mut retry_count = 0;\n    loop {\n        {\n            let mut conn_lock = inner.write().await;\n            if let Some(ref mut conn) = *conn_lock {\n                // Write length prefix + data\n                match conn.stream.write_u32(len as u32).await {\n                    Ok(_) =\u003e match conn.stream.write_all(\u0026bytes).await {\n                        Ok(_) =\u003e {\n                            conn.stream.flush().await\n                                .context(\"Failed to flush stream\")?;\n                            return Ok(());\n                        }\n                        Err(e) =\u003e {\n                            eprintln!(\"Write failed: {}\", e);\n                            conn.connected = false;\n                            *conn_lock = None; // Drop connection\n                        }\n                    },\n                    Err(e) =\u003e {\n                        eprintln!(\"Write length failed: {}\", e);\n                        conn.connected = false;\n                        *conn_lock = None; // Drop connection\n                    }\n                }\n            }\n        }\n\n        // Connection failed, try to reconnect\n        retry_count += 1;\n        if retry_count \u003e= 3 {\n            anyhow::bail!(\"Failed to send after 3 reconnection attempts\");\n        }\n\n        println!(\"Attempting reconnection ({}/3)...\", retry_count);\n        establish_connection(inner.clone()).await?;\n    }\n}\n\n/// Bevy system to handle keyboard input\npub fn handle_keyboard_input(\n    keys: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    ipc: Res\u003cIpcChannel\u003e,\n) {\n    for key in keys.get_just_pressed() {\n        let bytes = key_to_bytes(*key);\n        if let Some(bytes) = bytes {\n            ipc.send(ControlMessage::Input { data: bytes });\n        }\n    }\n}\n\n/// Convert KeyCode to terminal bytes\nfn key_to_bytes(key: KeyCode) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    match key {\n        KeyCode::Enter =\u003e Some(vec![b'\\r']),\n        KeyCode::Backspace =\u003e Some(vec![0x7F]),\n        KeyCode::Tab =\u003e Some(vec![b'\\t']),\n        KeyCode::Escape =\u003e Some(vec![0x1B]),\n        KeyCode::Space =\u003e Some(vec![b' ']),\n        KeyCode::ArrowUp =\u003e Some(vec![0x1B, b'[', b'A']),\n        KeyCode::ArrowDown =\u003e Some(vec![0x1B, b'[', b'B']),\n        KeyCode::ArrowRight =\u003e Some(vec![0x1B, b'[', b'C']),\n        KeyCode::ArrowLeft =\u003e Some(vec![0x1B, b'[', b'D']),\n        KeyCode::Home =\u003e Some(vec![0x1B, b'[', b'H']),\n        KeyCode::End =\u003e Some(vec![0x1B, b'[', b'F']),\n        KeyCode::PageUp =\u003e Some(vec![0x1B, b'[', b'5', b'~']),\n        KeyCode::PageDown =\u003e Some(vec![0x1B, b'[', b'6', b'~']),\n        KeyCode::Delete =\u003e Some(vec![0x1B, b'[', b'3', b'~']),\n        KeyCode::Insert =\u003e Some(vec![0x1B, b'[', b'2', b'~']),\n        // Function keys\n        KeyCode::F1 =\u003e Some(vec![0x1B, b'O', b'P']),\n        KeyCode::F2 =\u003e Some(vec![0x1B, b'O', b'Q']),\n        KeyCode::F3 =\u003e Some(vec![0x1B, b'O', b'R']),\n        KeyCode::F4 =\u003e Some(vec![0x1B, b'O', b'S']),\n        KeyCode::F5 =\u003e Some(vec![0x1B, b'[', b'1', b'5', b'~']),\n        KeyCode::F6 =\u003e Some(vec![0x1B, b'[', b'1', b'7', b'~']),\n        KeyCode::F7 =\u003e Some(vec![0x1B, b'[', b'1', b'8', b'~']),\n        KeyCode::F8 =\u003e Some(vec![0x1B, b'[', b'1', b'9', b'~']),\n        KeyCode::F9 =\u003e Some(vec![0x1B, b'[', b'2', b'0', b'~']),\n        KeyCode::F10 =\u003e Some(vec![0x1B, b'[', b'2', b'1', b'~']),\n        KeyCode::F11 =\u003e Some(vec![0x1B, b'[', b'2', b'3', b'~']),\n        KeyCode::F12 =\u003e Some(vec![0x1B, b'[', b'2', b'4', b'~']),\n        // Regular characters - handle via character input event instead\n        _ =\u003e None,\n    }\n}\n\n/// Bevy system to handle character input (for printable characters)\npub fn handle_character_input(\n    mut char_events: EventReader\u003cbevy::input::keyboard::KeyboardInput\u003e,\n    ipc: Res\u003cIpcChannel\u003e,\n) {\n    for event in char_events.read() {\n        // Only handle key presses (not releases)\n        if !event.state.is_pressed() {\n            continue;\n        }\n\n        // Handle text input via logical_key\n        if let bevy::input::keyboard::Key::Character(ref s) = event.logical_key {\n            let bytes = s.as_str().as_bytes().to_vec();\n            ipc.send(ControlMessage::Input { data: bytes });\n        }\n    }\n}\n\n/// Bevy system to handle window resize\npub fn handle_window_resize(\n    mut resize_events: EventReader\u003cbevy::window::WindowResized\u003e,\n    ipc: Res\u003cIpcChannel\u003e,\n) {\n    for event in resize_events.read() {\n        // Calculate terminal rows/cols from window size\n        // Assuming 8x16 character cell size (this should be configurable)\n        let cols = (event.width / 8.0) as u16;\n        let rows = (event.height / 16.0) as u16;\n\n        println!(\"Window resized: {}x{} -\u003e {}x{} chars\",\n                 event.width, event.height, cols, rows);\n\n        ipc.send(ControlMessage::Resize { cols, rows });\n    }\n}\n\n/// Bevy plugin for IPC functionality\npub struct IpcPlugin;\n\nimpl Plugin for IpcPlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        // Initialize IPC channel\n        match IpcChannel::new() {\n            Ok(channel) =\u003e {\n                println!(\"IPC channel initialized\");\n                app.insert_resource(channel);\n\n                // Register input handling systems\n                app.add_systems(Update, (\n                    handle_keyboard_input,\n                    handle_character_input,\n                    handle_window_resize,\n                ));\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Failed to initialize IPC: {}\", e);\n                eprintln!(\"Client will run without IPC support\");\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","lib.rs"],"content":"// Scarab terminal emulator client library\n// Re-exports UI and rendering modules for use in binary and tests\n\npub mod ui;\npub mod rendering;\n\npub use ui::*;\npub use rendering::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","main.rs"],"content":"use bevy::prelude::*;\nuse scarab_protocol::{SharedState, SHMEM_PATH};\nuse shared_memory::ShmemConf;\nuse std::sync::Arc;\nuse scarab_client::ui::AdvancedUIPlugin;\n\nmod ipc;\nuse ipc::IpcPlugin;\n\n// Marker for the grid entity\n#[derive(Component)]\nstruct TerminalGrid;\n\n// Wrapper to make shared memory Send + Sync\nstruct SharedMemWrapper(Arc\u003cshared_memory::Shmem\u003e);\n\nunsafe impl Send for SharedMemWrapper {}\nunsafe impl Sync for SharedMemWrapper {}\n\n// Resource to hold shared memory state\n#[derive(Resource)]\nstruct SharedMemoryReader {\n    shmem: SharedMemWrapper,\n    last_sequence: u64,\n}\n\nfn main() {\n    // Initialize shared memory before Bevy app starts\n    let shmem = match ShmemConf::new()\n        .size(std::mem::size_of::\u003cSharedState\u003e())\n        .os_id(SHMEM_PATH)\n        .open()\n    {\n        Ok(m) =\u003e {\n            println!(\"Connected to shared memory at: {}\", SHMEM_PATH);\n            Arc::new(m)\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Failed to open shared memory: {}. Is the daemon running?\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let reader = SharedMemoryReader {\n        shmem: SharedMemWrapper(shmem),\n        last_sequence: 0,\n    };\n\n    App::new()\n       .add_plugins(DefaultPlugins.set(WindowPlugin {\n            primary_window: Some(Window {\n                title: \"Scarab Terminal\".into(),\n                resolution: (1024.0, 768.0).into(),\n               ..default()\n            }),\n           ..default()\n        }))\n       .add_plugins(IpcPlugin) // Add IPC support\n       .add_plugins(AdvancedUIPlugin) // Add advanced UI features\n       .insert_resource(reader)\n       .add_systems(Startup, setup)\n       .add_systems(Update, sync_grid)\n       .run();\n}\n\nfn setup(mut commands: Commands) {\n    commands.spawn(Camera2dBundle::default());\n    commands.spawn((\n        TerminalGrid,\n        SpriteBundle {\n            transform: Transform::from_xyz(0.0, 0.0, 0.0),\n            ..default()\n        },\n    ));\n    println!(\"Scarab Client Initialized with shared memory reader and IPC.\");\n}\n\nfn sync_grid(mut reader: ResMut\u003cSharedMemoryReader\u003e) {\n    // Read SharedState from shared memory (zero-copy, lock-free)\n    let shared_ptr = reader.shmem.0.as_ptr() as *const SharedState;\n\n    unsafe {\n        let state = \u0026*shared_ptr;\n\n        // Check if sequence number changed (atomic read)\n        let current_seq = state.sequence_number;\n\n        if current_seq != reader.last_sequence {\n            // Grid has been updated by daemon\n            println!(\n                \"Grid updated! Seq: {} -\u003e {}, Cursor: ({}, {})\",\n                reader.last_sequence, current_seq, state.cursor_x, state.cursor_y\n            );\n\n            // TODO: Update texture/mesh from state.cells\n            // For now, just update our tracking sequence\n            reader.last_sequence = current_seq;\n\n            // Reset dirty flag (optional, depending on your protocol)\n            // Note: This is a read-only client, so we don't modify shared memory\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","rendering","atlas.rs"],"content":"// GPU texture atlas for glyph caching\n\nuse bevy::prelude::*;\nuse bevy::render::render_resource::{Extent3d, TextureDimension, TextureFormat};\nuse cosmic_text::{CacheKey, SwashCache, SwashContent};\nuse std::collections::HashMap;\n\n/// Maximum atlas texture size (4096x4096 for compatibility)\npub const ATLAS_SIZE: u32 = 4096;\n\n/// Padding between glyphs in the atlas\nconst GLYPH_PADDING: u32 = 2;\n\n/// Key for identifying unique glyphs in the atlas\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct GlyphKey {\n    pub cache_key: CacheKey,\n}\n\nimpl From\u003cCacheKey\u003e for GlyphKey {\n    fn from(cache_key: CacheKey) -\u003e Self {\n        Self { cache_key }\n    }\n}\n\n/// Rectangle in the atlas texture (UV coordinates)\n#[derive(Debug, Clone, Copy)]\npub struct AtlasRect {\n    pub x: u32,\n    pub y: u32,\n    pub width: u32,\n    pub height: u32,\n}\n\nimpl AtlasRect {\n    /// Get UV coordinates normalized to [0, 1]\n    pub fn uv_rect(\u0026self) -\u003e [f32; 4] {\n        let atlas_size = ATLAS_SIZE as f32;\n        [\n            self.x as f32 / atlas_size,\n            self.y as f32 / atlas_size,\n            (self.x + self.width) as f32 / atlas_size,\n            (self.y + self.height) as f32 / atlas_size,\n        ]\n    }\n}\n\n/// Glyph atlas for caching rasterized glyphs\npub struct GlyphAtlas {\n    /// Texture handle for the atlas\n    pub texture: Handle\u003cImage\u003e,\n\n    /// Map from glyph key to atlas position\n    glyph_positions: HashMap\u003cGlyphKey, AtlasRect\u003e,\n\n    /// Current packing position\n    current_x: u32,\n    current_y: u32,\n    current_row_height: u32,\n\n    /// Raw texture data (RGBA8)\n    texture_data: Vec\u003cu8\u003e,\n\n    /// Whether the texture needs updating\n    dirty: bool,\n}\n\nimpl GlyphAtlas {\n    /// Create a new glyph atlas\n    pub fn new(images: \u0026mut ResMut\u003cAssets\u003cImage\u003e\u003e) -\u003e Self {\n        // Create initial atlas texture\n        let size = Extent3d {\n            width: ATLAS_SIZE,\n            height: ATLAS_SIZE,\n            depth_or_array_layers: 1,\n        };\n\n        let mut image = Image::new_fill(\n            size,\n            TextureDimension::D2,\n            \u0026[0, 0, 0, 0], // Transparent black\n            TextureFormat::Rgba8UnormSrgb,\n        );\n\n        image.texture_descriptor.usage = bevy::render::render_resource::TextureUsages::TEXTURE_BINDING\n            | bevy::render::render_resource::TextureUsages::COPY_DST;\n\n        let texture = images.add(image);\n\n        Self {\n            texture,\n            glyph_positions: HashMap::new(),\n            current_x: GLYPH_PADDING,\n            current_y: GLYPH_PADDING,\n            current_row_height: 0,\n            texture_data: vec![0; (ATLAS_SIZE * ATLAS_SIZE * 4) as usize],\n            dirty: false,\n        }\n    }\n\n    /// Get or cache a glyph in the atlas\n    pub fn get_or_cache(\n        \u0026mut self,\n        glyph_key: GlyphKey,\n        swash_cache: \u0026mut SwashCache,\n    ) -\u003e Option\u003cAtlasRect\u003e {\n        // Check if already cached\n        if let Some(rect) = self.glyph_positions.get(\u0026glyph_key) {\n            return Some(*rect);\n        }\n\n        // Rasterize the glyph using cosmic-text\n        let image = swash_cache.get_image(glyph_key.cache_key)?;\n\n        // Check if we have space in the atlas\n        let glyph_width = image.placement.width as u32;\n        let glyph_height = image.placement.height as u32;\n\n        if !self.can_fit(glyph_width, glyph_height) {\n            warn!(\"Atlas full! Consider implementing dynamic atlas expansion\");\n            return None;\n        }\n\n        // Pack the glyph\n        let rect = self.pack_glyph(glyph_width, glyph_height);\n\n        // Copy glyph data to atlas\n        self.copy_glyph_data(\u0026image, \u0026rect);\n\n        // Cache the position\n        self.glyph_positions.insert(glyph_key, rect);\n        self.dirty = true;\n\n        Some(rect)\n    }\n\n    /// Check if a glyph can fit in the atlas\n    fn can_fit(\u0026self, width: u32, height: u32) -\u003e bool {\n        let padded_width = width + GLYPH_PADDING * 2;\n        let padded_height = height + GLYPH_PADDING * 2;\n\n        // Try current row\n        if self.current_x + padded_width \u003c= ATLAS_SIZE {\n            return true;\n        }\n\n        // Try next row\n        let next_y = self.current_y + self.current_row_height + GLYPH_PADDING;\n        next_y + padded_height \u003c= ATLAS_SIZE\n    }\n\n    /// Pack a glyph into the atlas and return its rect\n    fn pack_glyph(\u0026mut self, width: u32, height: u32) -\u003e AtlasRect {\n        let padded_width = width + GLYPH_PADDING * 2;\n        let padded_height = height + GLYPH_PADDING * 2;\n\n        // Check if we need to move to next row\n        if self.current_x + padded_width \u003e ATLAS_SIZE {\n            self.current_x = GLYPH_PADDING;\n            self.current_y += self.current_row_height + GLYPH_PADDING;\n            self.current_row_height = 0;\n        }\n\n        let rect = AtlasRect {\n            x: self.current_x,\n            y: self.current_y,\n            width,\n            height,\n        };\n\n        self.current_x += padded_width;\n        self.current_row_height = self.current_row_height.max(padded_height);\n\n        rect\n    }\n\n    /// Copy glyph image data to the atlas texture\n    fn copy_glyph_data(\u0026mut self, image: \u0026SwashContent, rect: \u0026AtlasRect) {\n        let atlas_width = ATLAS_SIZE as usize;\n\n        for y in 0..rect.height {\n            for x in 0..rect.width {\n                let src_idx = (y * rect.width + x) as usize;\n                let dst_idx = ((rect.y + y) * ATLAS_SIZE + (rect.x + x)) as usize * 4;\n\n                // Convert alpha mask to RGBA\n                let alpha = match image.content {\n                    cosmic_text::SwashContent::Mask =\u003e {\n                        if src_idx \u003c image.data.len() {\n                            image.data[src_idx]\n                        } else {\n                            0\n                        }\n                    }\n                    cosmic_text::SwashContent::Color =\u003e {\n                        // For colored emoji, copy RGBA directly\n                        if src_idx * 4 + 3 \u003c image.data.len() {\n                            let offset = src_idx * 4;\n                            self.texture_data[dst_idx] = image.data[offset];\n                            self.texture_data[dst_idx + 1] = image.data[offset + 1];\n                            self.texture_data[dst_idx + 2] = image.data[offset + 2];\n                            image.data[offset + 3]\n                        } else {\n                            0\n                        }\n                    }\n                    cosmic_text::SwashContent::SubpixelMask =\u003e {\n                        // Use red channel for subpixel rendering\n                        if src_idx * 3 \u003c image.data.len() {\n                            image.data[src_idx * 3]\n                        } else {\n                            0\n                        }\n                    }\n                };\n\n                // Set white color with alpha (for monochrome glyphs)\n                if matches!(image.content, cosmic_text::SwashContent::Mask) {\n                    self.texture_data[dst_idx] = 255;\n                    self.texture_data[dst_idx + 1] = 255;\n                    self.texture_data[dst_idx + 2] = 255;\n                }\n                self.texture_data[dst_idx + 3] = alpha;\n            }\n        }\n    }\n\n    /// Update the GPU texture if dirty\n    pub fn update_texture(\u0026mut self, images: \u0026mut ResMut\u003cAssets\u003cImage\u003e\u003e) {\n        if !self.dirty {\n            return;\n        }\n\n        if let Some(image) = images.get_mut(\u0026self.texture) {\n            image.data.copy_from_slice(\u0026self.texture_data);\n        }\n\n        self.dirty = false;\n    }\n\n    /// Clear the atlas (for debugging/testing)\n    pub fn clear(\u0026mut self) {\n        self.glyph_positions.clear();\n        self.current_x = GLYPH_PADDING;\n        self.current_y = GLYPH_PADDING;\n        self.current_row_height = 0;\n        self.texture_data.fill(0);\n        self.dirty = true;\n    }\n\n    /// Get atlas statistics\n    pub fn stats(\u0026self) -\u003e AtlasStats {\n        let used_height = self.current_y + self.current_row_height;\n        let total_pixels = ATLAS_SIZE * ATLAS_SIZE;\n        let used_pixels = used_height * ATLAS_SIZE;\n\n        AtlasStats {\n            glyph_count: self.glyph_positions.len(),\n            used_height,\n            total_height: ATLAS_SIZE,\n            occupancy: used_pixels as f32 / total_pixels as f32,\n            memory_mb: (self.texture_data.len() as f32) / (1024.0 * 1024.0),\n        }\n    }\n}\n\n/// Atlas statistics for monitoring\n#[derive(Debug, Clone, Copy)]\npub struct AtlasStats {\n    pub glyph_count: usize,\n    pub used_height: u32,\n    pub total_height: u32,\n    pub occupancy: f32,\n    pub memory_mb: f32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","rendering","config.rs"],"content":"// Font configuration and management\n\nuse serde::{Deserialize, Serialize};\n\n/// Font configuration for the terminal\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FontConfig {\n    /// Primary font family name\n    pub family: String,\n\n    /// Font size in points\n    pub size: f32,\n\n    /// Fallback font families (in order of preference)\n    pub fallback: Vec\u003cString\u003e,\n\n    /// Line height multiplier\n    pub line_height: f32,\n\n    /// Letter spacing adjustment\n    pub letter_spacing: f32,\n\n    /// Enable font hinting\n    pub hinting: bool,\n\n    /// Enable subpixel positioning\n    pub subpixel: bool,\n}\n\nimpl Default for FontConfig {\n    fn default() -\u003e Self {\n        Self {\n            family: \"JetBrains Mono\".to_string(),\n            size: 14.0,\n            fallback: vec![\n                \"Fira Code\".to_string(),\n                \"Cascadia Code\".to_string(),\n                \"DejaVu Sans Mono\".to_string(),\n                \"Noto Sans Mono\".to_string(),\n            ],\n            line_height: 1.2,\n            letter_spacing: 0.0,\n            hinting: true,\n            subpixel: true,\n        }\n    }\n}\n\nimpl FontConfig {\n    /// Create a new font configuration\n    pub fn new(family: impl Into\u003cString\u003e, size: f32) -\u003e Self {\n        Self {\n            family: family.into(),\n            size,\n            ..Default::default()\n        }\n    }\n\n    /// Get all font families (primary + fallbacks)\n    pub fn all_families(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        let mut families = vec![self.family.as_str()];\n        families.extend(self.fallback.iter().map(|s| s.as_str()));\n        families\n    }\n\n    /// Calculate cell dimensions based on font metrics\n    pub fn cell_dimensions(\u0026self) -\u003e (f32, f32) {\n        // Approximate cell dimensions (will be refined with actual font metrics)\n        let width = self.size * 0.6; // Monospace width ratio\n        let height = self.size * self.line_height;\n        (width, height)\n    }\n}\n\n/// Text attributes flags (matches SharedState Cell flags)\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct TextAttributes {\n    pub bold: bool,\n    pub italic: bool,\n    pub underline: bool,\n    pub strikethrough: bool,\n    pub dim: bool,\n    pub reverse: bool,\n}\n\nimpl TextAttributes {\n    pub fn from_flags(flags: u8) -\u003e Self {\n        Self {\n            bold: flags \u0026 0x01 != 0,\n            italic: flags \u0026 0x02 != 0,\n            underline: flags \u0026 0x04 != 0,\n            strikethrough: flags \u0026 0x08 != 0,\n            dim: flags \u0026 0x10 != 0,\n            reverse: flags \u0026 0x20 != 0,\n        }\n    }\n\n    pub fn to_flags(\u0026self) -\u003e u8 {\n        let mut flags = 0u8;\n        if self.bold { flags |= 0x01; }\n        if self.italic { flags |= 0x02; }\n        if self.underline { flags |= 0x04; }\n        if self.strikethrough { flags |= 0x08; }\n        if self.dim { flags |= 0x10; }\n        if self.reverse { flags |= 0x20; }\n        flags\n    }\n}\n\nimpl Default for TextAttributes {\n    fn default() -\u003e Self {\n        Self {\n            bold: false,\n            italic: false,\n            underline: false,\n            strikethrough: false,\n            dim: false,\n            reverse: false,\n        }\n    }\n}\n\n/// Color helper functions for converting between formats\npub mod color {\n    use bevy::prelude::{Color, ColorToComponents};\n\n    /// Convert u32 RGBA to Bevy Color\n    pub fn from_rgba(rgba: u32) -\u003e Color {\n        let r = ((rgba \u003e\u003e 24) \u0026 0xFF) as f32 / 255.0;\n        let g = ((rgba \u003e\u003e 16) \u0026 0xFF) as f32 / 255.0;\n        let b = ((rgba \u003e\u003e 8) \u0026 0xFF) as f32 / 255.0;\n        let a = (rgba \u0026 0xFF) as f32 / 255.0;\n        Color::srgba(r, g, b, a)\n    }\n\n    /// Convert Bevy Color to u32 RGBA\n    pub fn to_rgba(color: Color) -\u003e u32 {\n        let [r, g, b, a] = color.to_srgba().to_f32_array();\n        let r = (r * 255.0) as u32;\n        let g = (g * 255.0) as u32;\n        let b = (b * 255.0) as u32;\n        let a = (a * 255.0) as u32;\n        (r \u003c\u003c 24) | (g \u003c\u003c 16) | (b \u003c\u003c 8) | a\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","rendering","mod.rs"],"content":"// Text rendering module for Scarab terminal emulator\n// Integrates cosmic-text with Bevy for GPU-accelerated text rendering\n\npub mod atlas;\npub mod text;\npub mod config;\n\npub use atlas::{GlyphAtlas, GlyphKey, AtlasRect};\npub use text::{TextRenderer, TerminalMesh, DirtyRegion};\npub use config::FontConfig;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","rendering","text.rs"],"content":"// Text rendering system for terminal grid\n\nuse bevy::prelude::*;\nuse bevy::render::mesh::{Indices, PrimitiveTopology};\nuse bevy::render::render_asset::RenderAssetUsages;\nuse cosmic_text::{Attrs, Buffer, FontSystem, Metrics, Shaping, SwashCache};\nuse scarab_protocol::{Cell, SharedState, GRID_HEIGHT, GRID_WIDTH};\nuse std::collections::HashSet;\n\nuse super::atlas::{AtlasRect, GlyphAtlas, GlyphKey};\nuse super::config::{color, FontConfig, TextAttributes};\n\n/// Text renderer resource managing fonts and glyph caching\n#[derive(Resource)]\npub struct TextRenderer {\n    pub font_system: FontSystem,\n    pub swash_cache: SwashCache,\n    pub atlas: GlyphAtlas,\n    pub config: FontConfig,\n    pub cell_width: f32,\n    pub cell_height: f32,\n}\n\nimpl TextRenderer {\n    /// Create a new text renderer\n    pub fn new(config: FontConfig, images: \u0026mut ResMut\u003cAssets\u003cImage\u003e\u003e) -\u003e Self {\n        let font_system = FontSystem::new();\n        let swash_cache = SwashCache::new();\n        let atlas = GlyphAtlas::new(images);\n\n        let (cell_width, cell_height) = config.cell_dimensions();\n\n        Self {\n            font_system,\n            swash_cache,\n            atlas,\n            config,\n            cell_width,\n            cell_height,\n        }\n    }\n\n    /// Update font size and recalculate cell dimensions\n    pub fn set_font_size(\u0026mut self, size: f32) {\n        self.config.size = size;\n        let (width, height) = self.config.cell_dimensions();\n        self.cell_width = width;\n        self.cell_height = height;\n    }\n\n    /// Get actual font metrics for precise cell sizing\n    pub fn update_metrics(\u0026mut self) {\n        let mut buffer = Buffer::new(\u0026mut self.font_system, Metrics::new(self.config.size, self.config.size * self.config.line_height));\n\n        buffer.set_size(\u0026mut self.font_system, 100.0, 100.0);\n        buffer.set_text(\u0026mut self.font_system, \"M\", Attrs::new(), Shaping::Advanced);\n\n        // Get actual glyph dimensions\n        for run in buffer.layout_runs() {\n            for glyph in run.glyphs {\n                self.cell_width = glyph.w;\n                self.cell_height = self.config.size * self.config.line_height;\n                return;\n            }\n        }\n    }\n}\n\n/// Dirty region tracking for optimized mesh updates\n#[derive(Debug, Clone, Default)]\npub struct DirtyRegion {\n    /// Set of dirty cell indices\n    dirty_cells: HashSet\u003cusize\u003e,\n    /// Whether the entire grid is dirty\n    full_redraw: bool,\n}\n\nimpl DirtyRegion {\n    pub fn new() -\u003e Self {\n        Self {\n            dirty_cells: HashSet::new(),\n            full_redraw: true, // Start with full redraw\n        }\n    }\n\n    pub fn mark_dirty(\u0026mut self, index: usize) {\n        self.dirty_cells.insert(index);\n    }\n\n    pub fn mark_full_redraw(\u0026mut self) {\n        self.full_redraw = true;\n        self.dirty_cells.clear();\n    }\n\n    pub fn is_dirty(\u0026self, index: usize) -\u003e bool {\n        self.full_redraw || self.dirty_cells.contains(\u0026index)\n    }\n\n    pub fn clear(\u0026mut self) {\n        self.dirty_cells.clear();\n        self.full_redraw = false;\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        !self.full_redraw \u0026\u0026 self.dirty_cells.is_empty()\n    }\n}\n\n/// Terminal mesh component\n#[derive(Component)]\npub struct TerminalMesh {\n    pub dirty_region: DirtyRegion,\n    pub last_sequence: u64,\n}\n\nimpl Default for TerminalMesh {\n    fn default() -\u003e Self {\n        Self {\n            dirty_region: DirtyRegion::new(),\n            last_sequence: 0,\n        }\n    }\n}\n\n/// Vertex data for terminal quad\n#[repr(C)]\n#[derive(Copy, Clone, Debug)]\nstruct TerminalVertex {\n    position: [f32; 3],\n    uv: [f32; 2],\n    color: [f32; 4],\n}\n\n/// Generate mesh from terminal grid state\npub fn generate_terminal_mesh(\n    state: \u0026SharedState,\n    renderer: \u0026mut TextRenderer,\n    dirty_region: \u0026DirtyRegion,\n    images: \u0026mut ResMut\u003cAssets\u003cImage\u003e\u003e,\n) -\u003e Mesh {\n    let mut positions = Vec::new();\n    let mut uvs = Vec::new();\n    let mut colors = Vec::new();\n    let mut indices = Vec::new();\n\n    let grid_width = GRID_WIDTH as f32;\n    let grid_height = GRID_HEIGHT as f32;\n\n    // Calculate screen positioning (center grid)\n    let start_x = -(grid_width * renderer.cell_width) / 2.0;\n    let start_y = (grid_height * renderer.cell_height) / 2.0;\n\n    let mut vertex_index = 0u32;\n\n    // Iterate through all cells\n    for (idx, cell) in state.cells.iter().enumerate() {\n        // Skip if not dirty (optimization)\n        if !dirty_region.is_empty() \u0026\u0026 !dirty_region.is_dirty(idx) {\n            continue;\n        }\n\n        let row = idx / GRID_WIDTH;\n        let col = idx % GRID_WIDTH;\n\n        let x = start_x + (col as f32 * renderer.cell_width);\n        let y = start_y - (row as f32 * renderer.cell_height);\n\n        // Background quad\n        if cell.bg != 0 {\n            add_background_quad(\n                \u0026mut positions,\n                \u0026mut uvs,\n                \u0026mut colors,\n                \u0026mut indices,\n                \u0026mut vertex_index,\n                x,\n                y,\n                renderer.cell_width,\n                renderer.cell_height,\n                cell.bg,\n            );\n        }\n\n        // Foreground glyph\n        if cell.char_codepoint != 0 \u0026\u0026 cell.char_codepoint != 32 {\n            // Space character, skip rendering\n            let _ = render_glyph(\n                cell,\n                renderer,\n                \u0026mut positions,\n                \u0026mut uvs,\n                \u0026mut colors,\n                \u0026mut indices,\n                \u0026mut vertex_index,\n                x,\n                y,\n            );\n        }\n    }\n\n    // Update atlas texture if dirty\n    renderer.atlas.update_texture(images);\n\n    // Build mesh\n    let mut mesh = Mesh::new(\n        PrimitiveTopology::TriangleList,\n        RenderAssetUsages::RENDER_WORLD,\n    );\n\n    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);\n    mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);\n    mesh.insert_attribute(Mesh::ATTRIBUTE_COLOR, colors);\n    mesh.insert_indices(Indices::U32(indices));\n\n    mesh\n}\n\n/// Add a background quad for a cell\nfn add_background_quad(\n    positions: \u0026mut Vec\u003c[f32; 3]\u003e,\n    uvs: \u0026mut Vec\u003c[f32; 2]\u003e,\n    colors: \u0026mut Vec\u003c[f32; 4]\u003e,\n    indices: \u0026mut Vec\u003cu32\u003e,\n    vertex_index: \u0026mut u32,\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n    bg_color: u32,\n) {\n    let bg = color::from_rgba(bg_color);\n    let color_array = bg.to_srgba().to_f32_array();\n\n    // Add four vertices (quad)\n    positions.extend_from_slice(\u0026[\n        [x, y, 0.0],\n        [x + width, y, 0.0],\n        [x + width, y - height, 0.0],\n        [x, y - height, 0.0],\n    ]);\n\n    // UVs don't matter for solid color\n    uvs.extend_from_slice(\u0026[\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n    ]);\n\n    // All vertices have same background color\n    for _ in 0..4 {\n        colors.push(color_array);\n    }\n\n    // Two triangles (counter-clockwise winding)\n    indices.extend_from_slice(\u0026[\n        *vertex_index,\n        *vertex_index + 1,\n        *vertex_index + 2,\n        *vertex_index,\n        *vertex_index + 2,\n        *vertex_index + 3,\n    ]);\n\n    *vertex_index += 4;\n}\n\n/// Render a glyph quad\nfn render_glyph(\n    cell: \u0026Cell,\n    renderer: \u0026mut TextRenderer,\n    positions: \u0026mut Vec\u003c[f32; 3]\u003e,\n    uvs: \u0026mut Vec\u003c[f32; 2]\u003e,\n    colors: \u0026mut Vec\u003c[f32; 4]\u003e,\n    indices: \u0026mut Vec\u003cu32\u003e,\n    vertex_index: \u0026mut u32,\n    x: f32,\n    y: f32,\n) -\u003e Option\u003cAtlasRect\u003e {\n    // Get character from codepoint\n    let ch = char::from_u32(cell.char_codepoint)?;\n\n    // Parse text attributes\n    let attrs = TextAttributes::from_flags(cell.flags);\n\n    // Create cosmic-text buffer to get glyph info\n    let metrics = Metrics::new(renderer.config.size, renderer.config.size * renderer.config.line_height);\n    let mut buffer = Buffer::new(\u0026mut renderer.font_system, metrics);\n\n    // Build attrs with bold/italic\n    let mut cosmic_attrs = Attrs::new();\n\n    if attrs.bold {\n        cosmic_attrs = cosmic_attrs.weight(cosmic_text::Weight::BOLD);\n    }\n    if attrs.italic {\n        cosmic_attrs = cosmic_attrs.style(cosmic_text::Style::Italic);\n    }\n\n    buffer.set_text(\u0026mut renderer.font_system, \u0026ch.to_string(), cosmic_attrs, Shaping::Advanced);\n\n    // Get the glyph cache key\n    let mut glyph_key = None;\n    for run in buffer.layout_runs() {\n        for glyph in run.glyphs {\n            glyph_key = Some(GlyphKey::from(glyph.cache_key));\n            break;\n        }\n    }\n\n    let glyph_key = glyph_key?;\n\n    // Get or cache the glyph in atlas\n    let atlas_rect = renderer.atlas.get_or_cache(glyph_key, \u0026mut renderer.swash_cache)?;\n\n    // Get UV coordinates\n    let uv_rect = atlas_rect.uv_rect();\n\n    // Get foreground color (with dim attribute)\n    let mut fg = color::from_rgba(cell.fg);\n    if attrs.dim {\n        let [r, g, b, a] = fg.to_srgba().to_f32_array();\n        fg = Color::srgba(r * 0.5, g * 0.5, b * 0.5, a);\n    }\n\n    // Handle reverse video\n    if attrs.reverse {\n        fg = color::from_rgba(cell.bg);\n    }\n\n    let fg_array = fg.to_srgba().to_f32_array();\n\n    // Add glyph quad\n    let glyph_width = atlas_rect.width as f32;\n    let glyph_height = atlas_rect.height as f32;\n\n    positions.extend_from_slice(\u0026[\n        [x, y, 0.1], // Slightly above background\n        [x + glyph_width, y, 0.1],\n        [x + glyph_width, y - glyph_height, 0.1],\n        [x, y - glyph_height, 0.1],\n    ]);\n\n    uvs.extend_from_slice(\u0026[\n        [uv_rect[0], uv_rect[1]],\n        [uv_rect[2], uv_rect[1]],\n        [uv_rect[2], uv_rect[3]],\n        [uv_rect[0], uv_rect[3]],\n    ]);\n\n    for _ in 0..4 {\n        colors.push(fg_array);\n    }\n\n    indices.extend_from_slice(\u0026[\n        *vertex_index,\n        *vertex_index + 1,\n        *vertex_index + 2,\n        *vertex_index,\n        *vertex_index + 2,\n        *vertex_index + 3,\n    ]);\n\n    *vertex_index += 4;\n\n    // Handle underline\n    if attrs.underline {\n        add_underline_quad(\n            positions,\n            uvs,\n            colors,\n            indices,\n            vertex_index,\n            x,\n            y - renderer.cell_height + 2.0,\n            renderer.cell_width,\n            1.0,\n            cell.fg,\n        );\n    }\n\n    // Handle strikethrough\n    if attrs.strikethrough {\n        add_underline_quad(\n            positions,\n            uvs,\n            colors,\n            indices,\n            vertex_index,\n            x,\n            y - renderer.cell_height / 2.0,\n            renderer.cell_width,\n            1.0,\n            cell.fg,\n        );\n    }\n\n    Some(atlas_rect)\n}\n\n/// Add underline/strikethrough line\nfn add_underline_quad(\n    positions: \u0026mut Vec\u003c[f32; 3]\u003e,\n    uvs: \u0026mut Vec\u003c[f32; 2]\u003e,\n    colors: \u0026mut Vec\u003c[f32; 4]\u003e,\n    indices: \u0026mut Vec\u003cu32\u003e,\n    vertex_index: \u0026mut u32,\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n    color_u32: u32,\n) {\n    let color = color::from_rgba(color_u32);\n    let color_array = color.to_srgba().to_f32_array();\n\n    positions.extend_from_slice(\u0026[\n        [x, y, 0.15], // Above glyph\n        [x + width, y, 0.15],\n        [x + width, y - height, 0.15],\n        [x, y - height, 0.15],\n    ]);\n\n    uvs.extend_from_slice(\u0026[\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n    ]);\n\n    for _ in 0..4 {\n        colors.push(color_array);\n    }\n\n    indices.extend_from_slice(\u0026[\n        *vertex_index,\n        *vertex_index + 1,\n        *vertex_index + 2,\n        *vertex_index,\n        *vertex_index + 2,\n        *vertex_index + 3,\n    ]);\n\n    *vertex_index += 4;\n}\n\n/// System to update terminal mesh when state changes\npub fn update_terminal_mesh_system(\n    mut renderer: ResMut\u003cTextRenderer\u003e,\n    mut meshes: ResMut\u003cAssets\u003cMesh\u003e\u003e,\n    mut images: ResMut\u003cAssets\u003cImage\u003e\u003e,\n    mut query: Query\u003c(\u0026mut TerminalMesh, \u0026Handle\u003cMesh\u003e)\u003e,\n    state_reader: Res\u003ccrate::SharedMemoryReader\u003e,\n) {\n    let state = unsafe { \u0026*(state_reader.shmem.0.as_ptr() as *const SharedState) };\n\n    for (mut terminal_mesh, mesh_handle) in query.iter_mut() {\n        // Check if state changed\n        let current_seq = state.sequence_number;\n        if current_seq != terminal_mesh.last_sequence {\n            terminal_mesh.dirty_region.mark_full_redraw();\n            terminal_mesh.last_sequence = current_seq;\n        }\n\n        // Skip if nothing to update\n        if terminal_mesh.dirty_region.is_empty() {\n            continue;\n        }\n\n        // Generate new mesh\n        let new_mesh = generate_terminal_mesh(\n            state,\n            \u0026mut renderer,\n            \u0026terminal_mesh.dirty_region,\n            \u0026mut images,\n        );\n\n        // Update mesh asset\n        if let Some(mesh) = meshes.get_mut(mesh_handle) {\n            *mesh = new_mesh;\n        }\n\n        // Clear dirty region\n        terminal_mesh.dirty_region.clear();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","ui","animations.rs"],"content":"// Smooth animations for UI elements\n// Provides fade in/out and other transitions\n\nuse bevy::prelude::*;\n\n/// Plugin for UI animations\npub struct AnimationsPlugin;\n\nimpl Plugin for AnimationsPlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        app\n            .add_systems(Update, (\n                update_fade_animations_system,\n                update_slide_animations_system,\n                cleanup_finished_animations_system,\n            ));\n    }\n}\n\n/// Animation state for UI elements\n#[derive(Component, Clone, Debug)]\npub enum AnimationState {\n    FadeIn {\n        duration: f32,\n        elapsed: f32,\n    },\n    FadeOut {\n        duration: f32,\n        elapsed: f32,\n    },\n    SlideIn {\n        direction: SlideDirection,\n        duration: f32,\n        elapsed: f32,\n        start_pos: Vec2,\n        end_pos: Vec2,\n    },\n    SlideOut {\n        direction: SlideDirection,\n        duration: f32,\n        elapsed: f32,\n        start_pos: Vec2,\n        end_pos: Vec2,\n    },\n}\n\n/// Direction for slide animations\n#[derive(Clone, Debug, Copy)]\npub enum SlideDirection {\n    Left,\n    Right,\n    Up,\n    Down,\n}\n\n/// Fade animation component\n#[derive(Component, Clone, Debug)]\npub struct FadeAnimation {\n    pub duration: f32,\n    pub fade_in: bool,\n    pub elapsed: f32,\n}\n\nimpl FadeAnimation {\n    pub fn fade_in(duration: f32) -\u003e Self {\n        Self {\n            duration,\n            fade_in: true,\n            elapsed: 0.0,\n        }\n    }\n\n    pub fn fade_out(duration: f32) -\u003e Self {\n        Self {\n            duration,\n            fade_in: false,\n            elapsed: 0.0,\n        }\n    }\n\n    pub fn progress(\u0026self) -\u003e f32 {\n        (self.elapsed / self.duration).clamp(0.0, 1.0)\n    }\n\n    pub fn alpha(\u0026self) -\u003e f32 {\n        let progress = self.progress();\n        if self.fade_in {\n            easing::ease_out_cubic(progress)\n        } else {\n            1.0 - easing::ease_in_cubic(progress)\n        }\n    }\n\n    pub fn is_complete(\u0026self) -\u003e bool {\n        self.elapsed \u003e= self.duration\n    }\n}\n\n/// Slide animation component\n#[derive(Component, Clone, Debug)]\npub struct SlideAnimation {\n    pub direction: SlideDirection,\n    pub distance: f32,\n    pub duration: f32,\n    pub elapsed: f32,\n    pub initial_position: Vec2,\n}\n\nimpl SlideAnimation {\n    pub fn new(direction: SlideDirection, distance: f32, duration: f32) -\u003e Self {\n        Self {\n            direction,\n            distance,\n            duration,\n            elapsed: 0.0,\n            initial_position: Vec2::ZERO,\n        }\n    }\n\n    pub fn progress(\u0026self) -\u003e f32 {\n        (self.elapsed / self.duration).clamp(0.0, 1.0)\n    }\n\n    pub fn current_offset(\u0026self) -\u003e Vec2 {\n        let progress = easing::ease_out_cubic(self.progress());\n        let offset = self.distance * progress;\n\n        match self.direction {\n            SlideDirection::Left =\u003e Vec2::new(-offset, 0.0),\n            SlideDirection::Right =\u003e Vec2::new(offset, 0.0),\n            SlideDirection::Up =\u003e Vec2::new(0.0, offset),\n            SlideDirection::Down =\u003e Vec2::new(0.0, -offset),\n        }\n    }\n\n    pub fn is_complete(\u0026self) -\u003e bool {\n        self.elapsed \u003e= self.duration\n    }\n}\n\n/// Marker for animation completion\n#[derive(Component)]\npub struct AnimationComplete;\n\n/// Update fade animations\nfn update_fade_animations_system(\n    time: Res\u003cTime\u003e,\n    mut query: Query\u003c(\u0026mut FadeAnimation, Option\u003c\u0026mut BackgroundColor\u003e, Option\u003c\u0026mut Text\u003e)\u003e,\n) {\n    for (mut anim, bg_color, text) in query.iter_mut() {\n        anim.elapsed += time.delta_seconds();\n\n        let alpha = anim.alpha();\n\n        // Update background color alpha\n        if let Some(mut bg) = bg_color {\n            let mut color = bg.0;\n            color.set_alpha(alpha);\n            bg.0 = color;\n        }\n\n        // Update text color alpha\n        if let Some(mut text) = text {\n            for section in \u0026mut text.sections {\n                section.style.color.set_alpha(alpha);\n            }\n        }\n    }\n}\n\n/// Update slide animations\nfn update_slide_animations_system(\n    time: Res\u003cTime\u003e,\n    mut query: Query\u003c(\u0026mut SlideAnimation, \u0026mut Style)\u003e,\n) {\n    for (mut anim, mut style) in query.iter_mut() {\n        anim.elapsed += time.delta_seconds();\n\n        let offset = anim.current_offset();\n        let final_pos = anim.initial_position + offset;\n\n        style.left = Val::Px(final_pos.x);\n        style.top = Val::Px(final_pos.y);\n    }\n}\n\n/// Clean up finished animations\nfn cleanup_finished_animations_system(\n    mut commands: Commands,\n    fade_query: Query\u003c(Entity, \u0026FadeAnimation), Without\u003cAnimationComplete\u003e\u003e,\n    slide_query: Query\u003c(Entity, \u0026SlideAnimation), Without\u003cAnimationComplete\u003e\u003e,\n) {\n    for (entity, anim) in fade_query.iter() {\n        if anim.is_complete() {\n            commands.entity(entity).insert(AnimationComplete);\n        }\n    }\n\n    for (entity, anim) in slide_query.iter() {\n        if anim.is_complete() {\n            commands.entity(entity).insert(AnimationComplete);\n        }\n    }\n}\n\n/// Easing functions for smooth animations\npub mod easing {\n    pub fn ease_in_cubic(t: f32) -\u003e f32 {\n        t * t * t\n    }\n\n    pub fn ease_out_cubic(t: f32) -\u003e f32 {\n        let t = t - 1.0;\n        t * t * t + 1.0\n    }\n\n    pub fn ease_in_out_cubic(t: f32) -\u003e f32 {\n        if t \u003c 0.5 {\n            4.0 * t * t * t\n        } else {\n            let t = 2.0 * t - 2.0;\n            1.0 + t * t * t / 2.0\n        }\n    }\n\n    pub fn ease_in_quad(t: f32) -\u003e f32 {\n        t * t\n    }\n\n    pub fn ease_out_quad(t: f32) -\u003e f32 {\n        t * (2.0 - t)\n    }\n\n    pub fn ease_in_out_quad(t: f32) -\u003e f32 {\n        if t \u003c 0.5 {\n            2.0 * t * t\n        } else {\n            -1.0 + (4.0 - 2.0 * t) * t\n        }\n    }\n\n    pub fn ease_in_sine(t: f32) -\u003e f32 {\n        1.0 - f32::cos(t * std::f32::consts::PI / 2.0)\n    }\n\n    pub fn ease_out_sine(t: f32) -\u003e f32 {\n        f32::sin(t * std::f32::consts::PI / 2.0)\n    }\n\n    pub fn ease_in_out_sine(t: f32) -\u003e f32 {\n        -(f32::cos(std::f32::consts::PI * t) - 1.0) / 2.0\n    }\n}\n\n/// Bundle for animated UI elements\n#[derive(Bundle)]\npub struct AnimatedUIBundle {\n    pub node: NodeBundle,\n    pub fade: FadeAnimation,\n}\n\nimpl AnimatedUIBundle {\n    pub fn fade_in(duration: f32) -\u003e Self {\n        Self {\n            node: NodeBundle {\n                background_color: Color::srgba(0.0, 0.0, 0.0, 0.0).into(),\n                ..default()\n            },\n            fade: FadeAnimation::fade_in(duration),\n        }\n    }\n\n    pub fn fade_out(duration: f32) -\u003e Self {\n        Self {\n            node: NodeBundle {\n                background_color: Color::srgba(0.0, 0.0, 0.0, 1.0).into(),\n                ..default()\n            },\n            fade: FadeAnimation::fade_out(duration),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fade_animation_progress() {\n        let mut anim = FadeAnimation::fade_in(1.0);\n        assert_eq!(anim.progress(), 0.0);\n\n        anim.elapsed = 0.5;\n        assert_eq!(anim.progress(), 0.5);\n\n        anim.elapsed = 1.0;\n        assert_eq!(anim.progress(), 1.0);\n\n        anim.elapsed = 2.0;\n        assert_eq!(anim.progress(), 1.0); // Clamped\n    }\n\n    #[test]\n    fn test_fade_in_alpha() {\n        let mut anim = FadeAnimation::fade_in(1.0);\n\n        anim.elapsed = 0.0;\n        assert_eq!(anim.alpha(), 0.0);\n\n        anim.elapsed = 1.0;\n        assert_eq!(anim.alpha(), 1.0);\n    }\n\n    #[test]\n    fn test_fade_out_alpha() {\n        let mut anim = FadeAnimation::fade_out(1.0);\n\n        anim.elapsed = 0.0;\n        assert_eq!(anim.alpha(), 1.0);\n\n        anim.elapsed = 1.0;\n        assert_eq!(anim.alpha(), 0.0);\n    }\n\n    #[test]\n    fn test_easing_functions() {\n        use super::easing::*;\n\n        assert_eq!(ease_in_cubic(0.0), 0.0);\n        assert_eq!(ease_in_cubic(1.0), 1.0);\n\n        assert_eq!(ease_out_cubic(0.0), 0.0);\n        assert_eq!(ease_out_cubic(1.0), 1.0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","ui","command_palette.rs"],"content":"// Command palette with fuzzy search\n// Provides quick access to all terminal commands\n\nuse bevy::prelude::*;\nuse bevy::input::keyboard::KeyCode;\nuse bevy::ui::{Style, UiRect, Val, PositionType, FlexDirection};\nuse bevy::text::{Text, TextStyle, TextSection};\nuse fuzzy_matcher::FuzzyMatcher;\nuse fuzzy_matcher::skim::SkimMatcherV2;\nuse std::sync::Arc;\n\n/// Plugin for command palette functionality\npub struct CommandPalettePlugin;\n\nimpl Plugin for CommandPalettePlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        app\n            .init_resource::\u003cCommandRegistry\u003e()\n            .init_resource::\u003cCommandPaletteState\u003e()\n            .add_event::\u003cCommandExecutedEvent\u003e()\n            .add_systems(Update, (\n                toggle_palette_system,\n                handle_palette_input_system,\n                render_palette_system,\n                execute_command_system,\n            ).chain());\n    }\n}\n\n/// A command that can be executed\n#[derive(Clone)]\npub struct Command {\n    pub id: String,\n    pub name: String,\n    pub description: String,\n    pub category: String,\n    pub keybind: Option\u003cString\u003e,\n    pub action: Arc\u003cdyn Fn() + Send + Sync\u003e,\n}\n\nimpl Command {\n    pub fn new\u003cF\u003e(id: \u0026str, name: \u0026str, description: \u0026str, category: \u0026str, action: F) -\u003e Self\n    where\n        F: Fn() + Send + Sync + 'static,\n    {\n        Self {\n            id: id.to_string(),\n            name: name.to_string(),\n            description: description.to_string(),\n            category: category.to_string(),\n            keybind: None,\n            action: Arc::new(action),\n        }\n    }\n\n    pub fn with_keybind(mut self, keybind: \u0026str) -\u003e Self {\n        self.keybind = Some(keybind.to_string());\n        self\n    }\n}\n\n/// Registry of all available commands\n#[derive(Resource, Default)]\npub struct CommandRegistry {\n    commands: Vec\u003cCommand\u003e,\n}\n\nimpl CommandRegistry {\n    pub fn register(\u0026mut self, command: Command) {\n        self.commands.push(command);\n    }\n\n    pub fn get(\u0026self, id: \u0026str) -\u003e Option\u003c\u0026Command\u003e {\n        self.commands.iter().find(|c| c.id == id)\n    }\n\n    pub fn all(\u0026self) -\u003e \u0026[Command] {\n        \u0026self.commands\n    }\n\n    pub fn fuzzy_search(\u0026self, query: \u0026str) -\u003e Vec\u003c(Command, i64)\u003e {\n        if query.is_empty() {\n            return self.commands.iter().map(|c| (c.clone(), 0)).collect();\n        }\n\n        let matcher = SkimMatcherV2::default();\n        let mut results: Vec\u003c(Command, i64)\u003e = self.commands\n            .iter()\n            .filter_map(|cmd| {\n                let name_score = matcher.fuzzy_match(\u0026cmd.name, query).unwrap_or(0);\n                let desc_score = matcher.fuzzy_match(\u0026cmd.description, query).unwrap_or(0);\n                let score = name_score.max(desc_score);\n\n                if score \u003e 0 {\n                    Some((cmd.clone(), score))\n                } else {\n                    None\n                }\n            })\n            .collect();\n\n        // Sort by score (highest first)\n        results.sort_by(|a, b| b.1.cmp(\u0026a.1));\n        results\n    }\n}\n\n/// State of command palette\n#[derive(Resource, Default)]\npub struct CommandPaletteState {\n    pub active: bool,\n    pub query: String,\n    pub selected_index: usize,\n    pub filtered_commands: Vec\u003c(Command, i64)\u003e,\n}\n\n/// Event fired when command is executed\n#[derive(Event)]\npub struct CommandExecutedEvent {\n    pub command_id: String,\n}\n\n/// Component for palette UI elements\n#[derive(Component)]\nstruct PaletteUI;\n\n/// Component for command list item\n#[derive(Component)]\nstruct CommandItem {\n    index: usize,\n}\n\n/// Toggle command palette visibility\nfn toggle_palette_system(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    mut state: ResMut\u003cCommandPaletteState\u003e,\n    registry: Res\u003cCommandRegistry\u003e,\n) {\n    // Toggle palette with Ctrl+P\n    if keyboard.just_pressed(KeyCode::ControlLeft) \u0026\u0026 keyboard.pressed(KeyCode::KeyP) {\n        state.active = !state.active;\n\n        if state.active {\n            state.query.clear();\n            state.selected_index = 0;\n            state.filtered_commands = registry.fuzzy_search(\"\");\n        }\n    }\n\n    // Close with Escape\n    if state.active \u0026\u0026 keyboard.just_pressed(KeyCode::Escape) {\n        state.active = false;\n    }\n}\n\n/// Handle input in command palette\nfn handle_palette_input_system(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    mut state: ResMut\u003cCommandPaletteState\u003e,\n    registry: Res\u003cCommandRegistry\u003e,\n    mut command_events: EventWriter\u003cCommandExecutedEvent\u003e,\n) {\n    if !state.active {\n        return;\n    }\n\n    // Note: Character input handling would need keyboard text input events\n    // For now, we'll handle basic commands with keycodes\n\n    // Handle backspace\n    if keyboard.just_pressed(KeyCode::Backspace) {\n        state.query.pop();\n        state.filtered_commands = registry.fuzzy_search(\u0026state.query);\n        state.selected_index = 0;\n    }\n\n    // Handle navigation\n    if keyboard.just_pressed(KeyCode::ArrowDown) {\n        if state.selected_index \u003c state.filtered_commands.len().saturating_sub(1) {\n            state.selected_index += 1;\n        }\n    }\n\n    if keyboard.just_pressed(KeyCode::ArrowUp) {\n        state.selected_index = state.selected_index.saturating_sub(1);\n    }\n\n    // Handle selection with Enter\n    if keyboard.just_pressed(KeyCode::Enter) {\n        if let Some((command, _)) = state.filtered_commands.get(state.selected_index) {\n            command_events.send(CommandExecutedEvent {\n                command_id: command.id.clone(),\n            });\n            state.active = false;\n        }\n    }\n}\n\n/// Render command palette UI\nfn render_palette_system(\n    mut commands: Commands,\n    state: Res\u003cCommandPaletteState\u003e,\n    existing_ui: Query\u003cEntity, With\u003cPaletteUI\u003e\u003e,\n) {\n    // Remove existing UI\n    for entity in existing_ui.iter() {\n        commands.entity(entity).despawn_recursive();\n    }\n\n    if !state.active {\n        return;\n    }\n\n    // Create palette container\n    commands.spawn((\n        PaletteUI,\n        NodeBundle {\n            style: Style {\n                width: Val::Px(600.0),\n                height: Val::Px(400.0),\n                position_type: PositionType::Absolute,\n                left: Val::Px(200.0),\n                top: Val::Px(100.0),\n                flex_direction: FlexDirection::Column,\n                padding: UiRect::all(Val::Px(10.0)),\n                ..default()\n            },\n            background_color: Color::srgba(0.1, 0.1, 0.1, 0.95).into(),\n            ..default()\n        },\n    ))\n    .with_children(|parent| {\n        // Search input display\n        parent.spawn(TextBundle {\n            text: Text::from_section(\n                format!(\"\u003e {}\", state.query),\n                TextStyle {\n                    font_size: 20.0,\n                    color: Color::WHITE,\n                    ..default()\n                },\n            ),\n            style: Style {\n                margin: UiRect::bottom(Val::Px(10.0)),\n                ..default()\n            },\n            ..default()\n        });\n\n        // Command list (show first 10 results)\n        for (index, (command, score)) in state.filtered_commands.iter().take(10).enumerate() {\n            let is_selected = index == state.selected_index;\n            let bg_color = if is_selected {\n                Color::srgba(0.3, 0.3, 0.5, 0.8)\n            } else {\n                Color::srgba(0.2, 0.2, 0.2, 0.5)\n            };\n\n            parent.spawn((\n                CommandItem { index },\n                NodeBundle {\n                    style: Style {\n                        width: Val::Percent(100.0),\n                        padding: UiRect::all(Val::Px(8.0)),\n                        margin: UiRect::bottom(Val::Px(2.0)),\n                        ..default()\n                    },\n                    background_color: bg_color.into(),\n                    ..default()\n                },\n            ))\n            .with_children(|item| {\n                // Command name and keybind\n                let keybind_text = command.keybind\n                    .as_ref()\n                    .map(|k| format!(\" [{}]\", k))\n                    .unwrap_or_default();\n\n                item.spawn(TextBundle {\n                    text: Text::from_section(\n                        format!(\"{}{}\", command.name, keybind_text),\n                        TextStyle {\n                            font_size: 16.0,\n                            color: Color::WHITE,\n                            ..default()\n                        },\n                    ),\n                    ..default()\n                });\n\n                // Command description\n                item.spawn(TextBundle {\n                    text: Text::from_section(\n                        format!(\"{} (score: {})\", command.description, score),\n                        TextStyle {\n                            font_size: 12.0,\n                            color: Color::srgba(0.7, 0.7, 0.7, 1.0),\n                            ..default()\n                        },\n                    ),\n                    style: Style {\n                        margin: UiRect::top(Val::Px(4.0)),\n                        ..default()\n                    },\n                    ..default()\n                });\n            });\n        }\n    });\n}\n\n/// Execute selected command\nfn execute_command_system(\n    mut events: EventReader\u003cCommandExecutedEvent\u003e,\n    registry: Res\u003cCommandRegistry\u003e,\n) {\n    for event in events.read() {\n        if let Some(command) = registry.get(\u0026event.command_id) {\n            info!(\"Executing command: {}\", command.name);\n            (command.action)();\n        }\n    }\n}\n\n/// Initialize default commands\npub fn register_default_commands(registry: \u0026mut CommandRegistry) {\n    registry.register(\n        Command::new(\n            \"copy\",\n            \"Copy Selection\",\n            \"Copy selected text to clipboard\",\n            \"Edit\",\n            || info!(\"Copy executed\"),\n        )\n        .with_keybind(\"Ctrl+C\"),\n    );\n\n    registry.register(\n        Command::new(\n            \"paste\",\n            \"Paste\",\n            \"Paste from clipboard\",\n            \"Edit\",\n            || info!(\"Paste executed\"),\n        )\n        .with_keybind(\"Ctrl+V\"),\n    );\n\n    registry.register(\n        Command::new(\n            \"clear\",\n            \"Clear Terminal\",\n            \"Clear all terminal output\",\n            \"Terminal\",\n            || info!(\"Clear executed\"),\n        )\n        .with_keybind(\"Ctrl+L\"),\n    );\n\n    registry.register(\n        Command::new(\n            \"split_h\",\n            \"Split Horizontal\",\n            \"Split terminal horizontally\",\n            \"Window\",\n            || info!(\"Split horizontal executed\"),\n        ),\n    );\n\n    registry.register(\n        Command::new(\n            \"split_v\",\n            \"Split Vertical\",\n            \"Split terminal vertically\",\n            \"Window\",\n            || info!(\"Split vertical executed\"),\n        ),\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fuzzy_search() {\n        let mut registry = CommandRegistry::default();\n        registry.register(Command::new(\n            \"copy\",\n            \"Copy Selection\",\n            \"Copy text\",\n            \"Edit\",\n            || {},\n        ));\n        registry.register(Command::new(\n            \"paste\",\n            \"Paste\",\n            \"Paste text\",\n            \"Edit\",\n            || {},\n        ));\n\n        let results = registry.fuzzy_search(\"cop\");\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].0.id, \"copy\");\n    }\n\n    #[test]\n    fn test_fuzzy_search_performance() {\n        let mut registry = CommandRegistry::default();\n\n        // Add 1000 commands\n        for i in 0..1000 {\n            registry.register(Command::new(\n                \u0026format!(\"cmd_{}\", i),\n                \u0026format!(\"Command {}\", i),\n                \u0026format!(\"Description {}\", i),\n                \"Test\",\n                || {},\n            ));\n        }\n\n        use std::time::Instant;\n        let start = Instant::now();\n        let _results = registry.fuzzy_search(\"command\");\n        let duration = start.elapsed();\n\n        // Should complete in \u003c50ms\n        assert!(duration.as_millis() \u003c 50);\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","ui","keybindings.rs"],"content":"// Configurable key bindings system\n// Allows users to customize keyboard shortcuts\n\nuse bevy::prelude::*;\nuse bevy::input::keyboard::KeyCode;\nuse std::collections::HashMap;\n\n/// Plugin for key bindings functionality\npub struct KeybindingsPlugin;\n\nimpl Plugin for KeybindingsPlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        app\n            .init_resource::\u003cKeyBindingConfig\u003e()\n            .add_event::\u003cKeyBindingTriggeredEvent\u003e()\n            .add_systems(Update, handle_keybindings_system);\n    }\n}\n\n/// A single key binding\n#[derive(Clone, Debug, PartialEq, Eq, Hash)]\npub struct KeyBinding {\n    pub key: KeyCode,\n    pub ctrl: bool,\n    pub alt: bool,\n    pub shift: bool,\n    pub super_key: bool,\n}\n\nimpl KeyBinding {\n    pub fn new(key: KeyCode) -\u003e Self {\n        Self {\n            key,\n            ctrl: false,\n            alt: false,\n            shift: false,\n            super_key: false,\n        }\n    }\n\n    pub fn with_ctrl(mut self) -\u003e Self {\n        self.ctrl = true;\n        self\n    }\n\n    pub fn with_alt(mut self) -\u003e Self {\n        self.alt = true;\n        self\n    }\n\n    pub fn with_shift(mut self) -\u003e Self {\n        self.shift = true;\n        self\n    }\n\n    pub fn with_super(mut self) -\u003e Self {\n        self.super_key = true;\n        self\n    }\n\n    pub fn matches(\u0026self, keyboard: \u0026ButtonInput\u003cKeyCode\u003e) -\u003e bool {\n        if !keyboard.pressed(self.key) {\n            return false;\n        }\n\n        let ctrl_pressed = keyboard.any_pressed([KeyCode::ControlLeft, KeyCode::ControlRight]);\n        let alt_pressed = keyboard.any_pressed([KeyCode::AltLeft, KeyCode::AltRight]);\n        let shift_pressed = keyboard.any_pressed([KeyCode::ShiftLeft, KeyCode::ShiftRight]);\n        let super_pressed = keyboard.any_pressed([KeyCode::SuperLeft, KeyCode::SuperRight]);\n\n        self.ctrl == ctrl_pressed\n            \u0026\u0026 self.alt == alt_pressed\n            \u0026\u0026 self.shift == shift_pressed\n            \u0026\u0026 self.super_key == super_pressed\n    }\n\n    pub fn to_string(\u0026self) -\u003e String {\n        let mut parts = Vec::new();\n\n        if self.ctrl {\n            parts.push(\"Ctrl\");\n        }\n        if self.alt {\n            parts.push(\"Alt\");\n        }\n        if self.shift {\n            parts.push(\"Shift\");\n        }\n        if self.super_key {\n            parts.push(\"Super\");\n        }\n\n        let key_str = format!(\"{:?}\", self.key);\n        parts.push(\u0026key_str);\n\n        parts.join(\"+\")\n    }\n\n    pub fn from_string(s: \u0026str) -\u003e Option\u003cSelf\u003e {\n        let parts: Vec\u003c\u0026str\u003e = s.split('+').collect();\n        if parts.is_empty() {\n            return None;\n        }\n\n        let mut binding = KeyBinding::new(KeyCode::KeyA); // Default, will be overwritten\n        let mut key_set = false;\n\n        for part in parts {\n            match part {\n                \"Ctrl\" =\u003e binding.ctrl = true,\n                \"Alt\" =\u003e binding.alt = true,\n                \"Shift\" =\u003e binding.shift = true,\n                \"Super\" =\u003e binding.super_key = true,\n                key_str =\u003e {\n                    // Parse key code\n                    if let Some(key) = parse_keycode(key_str) {\n                        binding.key = key;\n                        key_set = true;\n                    }\n                }\n            }\n        }\n\n        if key_set {\n            Some(binding)\n        } else {\n            None\n        }\n    }\n}\n\n/// Configuration for all key bindings\n#[derive(Resource)]\npub struct KeyBindingConfig {\n    bindings: HashMap\u003cKeyBinding, String\u003e,\n}\n\nimpl Default for KeyBindingConfig {\n    fn default() -\u003e Self {\n        let mut config = Self {\n            bindings: HashMap::new(),\n        };\n        config.register_defaults();\n        config\n    }\n}\n\nimpl KeyBindingConfig {\n    pub fn bind(\u0026mut self, binding: KeyBinding, action: \u0026str) {\n        self.bindings.insert(binding, action.to_string());\n    }\n\n    pub fn unbind(\u0026mut self, binding: \u0026KeyBinding) {\n        self.bindings.remove(binding);\n    }\n\n    pub fn get_action(\u0026self, binding: \u0026KeyBinding) -\u003e Option\u003c\u0026str\u003e {\n        self.bindings.get(binding).map(|s| s.as_str())\n    }\n\n    pub fn find_binding(\u0026self, action: \u0026str) -\u003e Option\u003c\u0026KeyBinding\u003e {\n        self.bindings\n            .iter()\n            .find(|(_, a)| a.as_str() == action)\n            .map(|(k, _)| k)\n    }\n\n    pub fn all_bindings(\u0026self) -\u003e \u0026HashMap\u003cKeyBinding, String\u003e {\n        \u0026self.bindings\n    }\n\n    fn register_defaults(\u0026mut self) {\n        // Copy/Paste\n        self.bind(\n            KeyBinding::new(KeyCode::KeyC).with_ctrl(),\n            \"edit.copy\",\n        );\n        self.bind(\n            KeyBinding::new(KeyCode::KeyV).with_ctrl(),\n            \"edit.paste\",\n        );\n        self.bind(\n            KeyBinding::new(KeyCode::KeyX).with_ctrl(),\n            \"edit.cut\",\n        );\n\n        // Undo/Redo\n        self.bind(\n            KeyBinding::new(KeyCode::KeyZ).with_ctrl(),\n            \"edit.undo\",\n        );\n        self.bind(\n            KeyBinding::new(KeyCode::KeyY).with_ctrl(),\n            \"edit.redo\",\n        );\n\n        // Search\n        self.bind(\n            KeyBinding::new(KeyCode::KeyF).with_ctrl(),\n            \"search.find\",\n        );\n        self.bind(\n            KeyBinding::new(KeyCode::KeyH).with_ctrl(),\n            \"search.replace\",\n        );\n\n        // Terminal operations\n        self.bind(\n            KeyBinding::new(KeyCode::KeyL).with_ctrl(),\n            \"terminal.clear\",\n        );\n        self.bind(\n            KeyBinding::new(KeyCode::KeyT).with_ctrl(),\n            \"terminal.new_tab\",\n        );\n        self.bind(\n            KeyBinding::new(KeyCode::KeyW).with_ctrl(),\n            \"terminal.close_tab\",\n        );\n\n        // Window management\n        self.bind(\n            KeyBinding::new(KeyCode::Backslash).with_ctrl(),\n            \"window.split_vertical\",\n        );\n        self.bind(\n            KeyBinding::new(KeyCode::Minus).with_ctrl(),\n            \"window.split_horizontal\",\n        );\n\n        // Navigation\n        self.bind(\n            KeyBinding::new(KeyCode::Tab).with_ctrl(),\n            \"navigation.next_pane\",\n        );\n        self.bind(\n            KeyBinding::new(KeyCode::Tab).with_ctrl().with_shift(),\n            \"navigation.prev_pane\",\n        );\n\n        // Command palette\n        self.bind(\n            KeyBinding::new(KeyCode::KeyP).with_ctrl(),\n            \"palette.open\",\n        );\n\n        // Link hints\n        self.bind(\n            KeyBinding::new(KeyCode::KeyK).with_ctrl(),\n            \"links.show_hints\",\n        );\n    }\n\n    pub fn save_to_file(\u0026self, path: \u0026std::path::Path) -\u003e Result\u003c(), std::io::Error\u003e {\n        use std::io::Write;\n        let mut file = std::fs::File::create(path)?;\n\n        for (binding, action) in \u0026self.bindings {\n            writeln!(file, \"{}={}\", binding.to_string(), action)?;\n        }\n\n        Ok(())\n    }\n\n    pub fn load_from_file(\u0026mut self, path: \u0026std::path::Path) -\u003e Result\u003c(), std::io::Error\u003e {\n        use std::io::BufRead;\n        let file = std::fs::File::open(path)?;\n        let reader = std::io::BufReader::new(file);\n\n        for line in reader.lines() {\n            let line = line?;\n            if let Some((binding_str, action)) = line.split_once('=') {\n                if let Some(binding) = KeyBinding::from_string(binding_str) {\n                    self.bind(binding, action);\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n\n/// Event fired when key binding is triggered\n#[derive(Event)]\npub struct KeyBindingTriggeredEvent {\n    pub action: String,\n}\n\n/// Handle key binding inputs\nfn handle_keybindings_system(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    config: Res\u003cKeyBindingConfig\u003e,\n    mut event_writer: EventWriter\u003cKeyBindingTriggeredEvent\u003e,\n) {\n    // Check all registered bindings\n    for (binding, action) in config.all_bindings() {\n        if keyboard.just_pressed(binding.key) \u0026\u0026 binding.matches(\u0026keyboard) {\n            info!(\"Key binding triggered: {} -\u003e {}\", binding.to_string(), action);\n            event_writer.send(KeyBindingTriggeredEvent {\n                action: action.clone(),\n            });\n        }\n    }\n}\n\n/// Parse string to KeyCode\nfn parse_keycode(s: \u0026str) -\u003e Option\u003cKeyCode\u003e {\n    match s {\n        \"KeyA\" =\u003e Some(KeyCode::KeyA),\n        \"KeyB\" =\u003e Some(KeyCode::KeyB),\n        \"KeyC\" =\u003e Some(KeyCode::KeyC),\n        \"KeyD\" =\u003e Some(KeyCode::KeyD),\n        \"KeyE\" =\u003e Some(KeyCode::KeyE),\n        \"KeyF\" =\u003e Some(KeyCode::KeyF),\n        \"KeyG\" =\u003e Some(KeyCode::KeyG),\n        \"KeyH\" =\u003e Some(KeyCode::KeyH),\n        \"KeyI\" =\u003e Some(KeyCode::KeyI),\n        \"KeyJ\" =\u003e Some(KeyCode::KeyJ),\n        \"KeyK\" =\u003e Some(KeyCode::KeyK),\n        \"KeyL\" =\u003e Some(KeyCode::KeyL),\n        \"KeyM\" =\u003e Some(KeyCode::KeyM),\n        \"KeyN\" =\u003e Some(KeyCode::KeyN),\n        \"KeyO\" =\u003e Some(KeyCode::KeyO),\n        \"KeyP\" =\u003e Some(KeyCode::KeyP),\n        \"KeyQ\" =\u003e Some(KeyCode::KeyQ),\n        \"KeyR\" =\u003e Some(KeyCode::KeyR),\n        \"KeyS\" =\u003e Some(KeyCode::KeyS),\n        \"KeyT\" =\u003e Some(KeyCode::KeyT),\n        \"KeyU\" =\u003e Some(KeyCode::KeyU),\n        \"KeyV\" =\u003e Some(KeyCode::KeyV),\n        \"KeyW\" =\u003e Some(KeyCode::KeyW),\n        \"KeyX\" =\u003e Some(KeyCode::KeyX),\n        \"KeyY\" =\u003e Some(KeyCode::KeyY),\n        \"KeyZ\" =\u003e Some(KeyCode::KeyZ),\n        \"Escape\" =\u003e Some(KeyCode::Escape),\n        \"Enter\" =\u003e Some(KeyCode::Enter),\n        \"Space\" =\u003e Some(KeyCode::Space),\n        \"Backspace\" =\u003e Some(KeyCode::Backspace),\n        \"Tab\" =\u003e Some(KeyCode::Tab),\n        \"Minus\" =\u003e Some(KeyCode::Minus),\n        \"Backslash\" =\u003e Some(KeyCode::Backslash),\n        _ =\u003e None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_key_binding_string_conversion() {\n        let binding = KeyBinding::new(KeyCode::KeyC).with_ctrl();\n        assert_eq!(binding.to_string(), \"Ctrl+KeyC\");\n\n        let parsed = KeyBinding::from_string(\"Ctrl+KeyC\").unwrap();\n        assert_eq!(parsed, binding);\n    }\n\n    #[test]\n    fn test_keybinding_config() {\n        let mut config = KeyBindingConfig::default();\n\n        let binding = KeyBinding::new(KeyCode::KeyS).with_ctrl();\n        config.bind(binding.clone(), \"test.save\");\n\n        assert_eq!(config.get_action(\u0026binding), Some(\"test.save\"));\n        assert_eq!(\n            config.find_binding(\"test.save\").unwrap(),\n            \u0026binding\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","ui","leader_key.rs"],"content":"// Spacemacs-like leader key menu system\n// Provides hierarchical command menus triggered by a leader key\n\nuse bevy::prelude::*;\nuse bevy::input::keyboard::KeyCode;\nuse bevy::ui::{Style, UiRect, Val, PositionType, FlexDirection};\nuse bevy::text::{Text, TextStyle, TextSection};\nuse std::time::{Duration, Instant};\n\n/// Plugin for leader key functionality\npub struct LeaderKeyPlugin;\n\nimpl Plugin for LeaderKeyPlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        app\n            .init_resource::\u003cLeaderKeyState\u003e()\n            .init_resource::\u003cLeaderKeyMenus\u003e()\n            .add_event::\u003cLeaderKeyActivatedEvent\u003e()\n            .add_systems(Update, (\n                handle_leader_key_system,\n                handle_menu_navigation_system,\n                render_menu_system,\n                timeout_check_system,\n            ).chain());\n    }\n}\n\n/// State of leader key system\n#[derive(Resource)]\npub struct LeaderKeyState {\n    pub active: bool,\n    pub last_press: Option\u003cInstant\u003e,\n    pub timeout: Duration,\n    pub current_menu: String,\n    pub key_sequence: Vec\u003cchar\u003e,\n}\n\nimpl Default for LeaderKeyState {\n    fn default() -\u003e Self {\n        Self {\n            active: false,\n            last_press: None,\n            timeout: Duration::from_millis(1000),\n            current_menu: \"root\".to_string(),\n            key_sequence: Vec::new(),\n        }\n    }\n}\n\n/// Menu item in leader key system\n#[derive(Clone)]\npub struct MenuItem {\n    pub key: char,\n    pub label: String,\n    pub description: String,\n    pub action: MenuAction,\n}\n\n/// Action that can be triggered by menu item\n#[derive(Clone)]\npub enum MenuAction {\n    Command(String),\n    SubMenu(String),\n}\n\n/// Menu definition\n#[derive(Clone, Default)]\npub struct Menu {\n    pub title: String,\n    pub items: Vec\u003cMenuItem\u003e,\n}\n\n/// Registry of all leader key menus\n#[derive(Resource, Default)]\npub struct LeaderKeyMenus {\n    menus: std::collections::HashMap\u003cString, Menu\u003e,\n}\n\nimpl LeaderKeyMenus {\n    pub fn register(\u0026mut self, id: \u0026str, menu: Menu) {\n        self.menus.insert(id.to_string(), menu);\n    }\n\n    pub fn get(\u0026self, id: \u0026str) -\u003e Option\u003c\u0026Menu\u003e {\n        self.menus.get(id)\n    }\n}\n\n/// Event fired when leader key is activated\n#[derive(Event)]\npub struct LeaderKeyActivatedEvent {\n    pub command: String,\n}\n\n/// Component for menu UI\n#[derive(Component)]\nstruct LeaderMenuUI;\n\n/// Handle leader key activation\nfn handle_leader_key_system(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    mut state: ResMut\u003cLeaderKeyState\u003e,\n) {\n    // Activate with Space key (when not in insert mode)\n    if keyboard.just_pressed(KeyCode::Space) {\n        state.active = true;\n        state.last_press = Some(Instant::now());\n        state.current_menu = \"root\".to_string();\n        state.key_sequence.clear();\n        info!(\"Leader key activated\");\n    }\n\n    // Deactivate with Escape\n    if state.active \u0026\u0026 keyboard.just_pressed(KeyCode::Escape) {\n        state.active = false;\n        state.key_sequence.clear();\n        info!(\"Leader key deactivated\");\n    }\n}\n\n/// Handle menu navigation and selection\nfn handle_menu_navigation_system(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    mut state: ResMut\u003cLeaderKeyState\u003e,\n    menus: Res\u003cLeaderKeyMenus\u003e,\n    mut event_writer: EventWriter\u003cLeaderKeyActivatedEvent\u003e,\n) {\n    if !state.active {\n        return;\n    }\n\n    // Get current menu\n    let current_menu = match menus.get(\u0026state.current_menu) {\n        Some(menu) =\u003e menu,\n        None =\u003e return,\n    };\n\n    // Check for key presses\n    for key_code in keyboard.get_just_pressed() {\n        if let Some(char) = keycode_to_char(*key_code) {\n            state.last_press = Some(Instant::now());\n\n            // Find matching menu item\n            if let Some(item) = current_menu.items.iter().find(|i| i.key == char) {\n                state.key_sequence.push(char);\n\n                match \u0026item.action {\n                    MenuAction::Command(cmd) =\u003e {\n                        info!(\"Executing command: {}\", cmd);\n                        event_writer.send(LeaderKeyActivatedEvent {\n                            command: cmd.clone(),\n                        });\n                        state.active = false;\n                        state.key_sequence.clear();\n                    }\n                    MenuAction::SubMenu(menu_id) =\u003e {\n                        info!(\"Entering submenu: {}\", menu_id);\n                        state.current_menu = menu_id.clone();\n                    }\n                }\n            }\n        }\n    }\n}\n\n/// Render leader key menu\nfn render_menu_system(\n    mut commands: Commands,\n    state: Res\u003cLeaderKeyState\u003e,\n    menus: Res\u003cLeaderKeyMenus\u003e,\n    existing_ui: Query\u003cEntity, With\u003cLeaderMenuUI\u003e\u003e,\n) {\n    // Remove existing UI\n    for entity in existing_ui.iter() {\n        commands.entity(entity).despawn_recursive();\n    }\n\n    if !state.active {\n        return;\n    }\n\n    // Get current menu\n    let current_menu = match menus.get(\u0026state.current_menu) {\n        Some(menu) =\u003e menu,\n        None =\u003e return,\n    };\n\n    // Create menu container\n    commands.spawn((\n        LeaderMenuUI,\n        NodeBundle {\n            style: Style {\n                width: Val::Px(400.0),\n                position_type: PositionType::Absolute,\n                left: Val::Px(50.0),\n                top: Val::Px(50.0),\n                flex_direction: FlexDirection::Column,\n                padding: UiRect::all(Val::Px(15.0)),\n                row_gap: Val::Px(5.0),\n                ..default()\n            },\n            background_color: Color::srgba(0.1, 0.1, 0.1, 0.95).into(),\n            ..default()\n        },\n    ))\n    .with_children(|parent| {\n        // Menu title\n        parent.spawn(TextBundle {\n            text: Text::from_section(\n                \u0026current_menu.title,\n                TextStyle {\n                    font_size: 20.0,\n                    color: Color::WHITE,\n                    ..default()\n                },\n            ),\n            style: Style {\n                margin: UiRect::bottom(Val::Px(10.0)),\n                ..default()\n            },\n            ..default()\n        });\n\n        // Key sequence display\n        if !state.key_sequence.is_empty() {\n            let sequence: String = state.key_sequence.iter().collect();\n            parent.spawn(TextBundle {\n                text: Text::from_section(\n                    format!(\"Keys: {}\", sequence),\n                    TextStyle {\n                        font_size: 14.0,\n                        color: Color::srgb(0.5, 0.8, 0.5),\n                        ..default()\n                    },\n                ),\n                style: Style {\n                    margin: UiRect::bottom(Val::Px(10.0)),\n                    ..default()\n                },\n                ..default()\n            });\n        }\n\n        // Menu items\n        for item in \u0026current_menu.items {\n            parent.spawn(NodeBundle {\n                style: Style {\n                    flex_direction: FlexDirection::Row,\n                    padding: UiRect::all(Val::Px(5.0)),\n                    ..default()\n                },\n                ..default()\n            })\n            .with_children(|item_parent| {\n                // Key\n                item_parent.spawn(TextBundle {\n                    text: Text::from_section(\n                        format!(\"[{}]\", item.key),\n                        TextStyle {\n                            font_size: 16.0,\n                            color: Color::srgb(1.0, 0.8, 0.0),\n                            ..default()\n                        },\n                    ),\n                    style: Style {\n                        margin: UiRect::right(Val::Px(10.0)),\n                        ..default()\n                    },\n                    ..default()\n                });\n\n                // Label\n                item_parent.spawn(TextBundle {\n                    text: Text::from_section(\n                        \u0026item.label,\n                        TextStyle {\n                            font_size: 16.0,\n                            color: Color::WHITE,\n                            ..default()\n                        },\n                    ),\n                    style: Style {\n                        margin: UiRect::right(Val::Px(10.0)),\n                        ..default()\n                    },\n                    ..default()\n                });\n\n                // Description\n                item_parent.spawn(TextBundle {\n                    text: Text::from_section(\n                        \u0026item.description,\n                        TextStyle {\n                            font_size: 12.0,\n                            color: Color::srgba(0.7, 0.7, 0.7, 1.0),\n                            ..default()\n                        },\n                    ),\n                    ..default()\n                });\n            });\n        }\n\n        // Timeout indicator\n        if let Some(last_press) = state.last_press {\n            let elapsed = last_press.elapsed();\n            let remaining = state.timeout.saturating_sub(elapsed);\n            let progress = (remaining.as_millis() as f32) / (state.timeout.as_millis() as f32);\n\n            parent.spawn(NodeBundle {\n                style: Style {\n                    width: Val::Percent(100.0),\n                    height: Val::Px(4.0),\n                    margin: UiRect::top(Val::Px(10.0)),\n                    ..default()\n                },\n                background_color: Color::srgba(0.3, 0.3, 0.3, 0.5).into(),\n                ..default()\n            })\n            .with_children(|bar| {\n                bar.spawn(NodeBundle {\n                    style: Style {\n                        width: Val::Percent(progress * 100.0),\n                        height: Val::Percent(100.0),\n                        ..default()\n                    },\n                    background_color: Color::srgb(0.0, 0.8, 0.0).into(),\n                    ..default()\n                });\n            });\n        }\n    });\n}\n\n/// Check for timeout and deactivate\nfn timeout_check_system(mut state: ResMut\u003cLeaderKeyState\u003e) {\n    if !state.active {\n        return;\n    }\n\n    if let Some(last_press) = state.last_press {\n        if last_press.elapsed() \u003e= state.timeout {\n            info!(\"Leader key timeout\");\n            state.active = false;\n            state.key_sequence.clear();\n        }\n    }\n}\n\n/// Convert KeyCode to character\nfn keycode_to_char(keycode: KeyCode) -\u003e Option\u003cchar\u003e {\n    match keycode {\n        KeyCode::KeyA =\u003e Some('a'),\n        KeyCode::KeyB =\u003e Some('b'),\n        KeyCode::KeyC =\u003e Some('c'),\n        KeyCode::KeyD =\u003e Some('d'),\n        KeyCode::KeyE =\u003e Some('e'),\n        KeyCode::KeyF =\u003e Some('f'),\n        KeyCode::KeyG =\u003e Some('g'),\n        KeyCode::KeyH =\u003e Some('h'),\n        KeyCode::KeyI =\u003e Some('i'),\n        KeyCode::KeyJ =\u003e Some('j'),\n        KeyCode::KeyK =\u003e Some('k'),\n        KeyCode::KeyL =\u003e Some('l'),\n        KeyCode::KeyM =\u003e Some('m'),\n        KeyCode::KeyN =\u003e Some('n'),\n        KeyCode::KeyO =\u003e Some('o'),\n        KeyCode::KeyP =\u003e Some('p'),\n        KeyCode::KeyQ =\u003e Some('q'),\n        KeyCode::KeyR =\u003e Some('r'),\n        KeyCode::KeyS =\u003e Some('s'),\n        KeyCode::KeyT =\u003e Some('t'),\n        KeyCode::KeyU =\u003e Some('u'),\n        KeyCode::KeyV =\u003e Some('v'),\n        KeyCode::KeyW =\u003e Some('w'),\n        KeyCode::KeyX =\u003e Some('x'),\n        KeyCode::KeyY =\u003e Some('y'),\n        KeyCode::KeyZ =\u003e Some('z'),\n        _ =\u003e None,\n    }\n}\n\n/// Initialize default leader key menus\npub fn register_default_menus(menus: \u0026mut LeaderKeyMenus) {\n    // Root menu\n    let mut root_menu = Menu {\n        title: \"Leader Menu\".to_string(),\n        items: Vec::new(),\n    };\n\n    root_menu.items.push(MenuItem {\n        key: 'b',\n        label: \"Buffer\".to_string(),\n        description: \"Buffer operations\".to_string(),\n        action: MenuAction::SubMenu(\"buffer\".to_string()),\n    });\n\n    root_menu.items.push(MenuItem {\n        key: 'w',\n        label: \"Window\".to_string(),\n        description: \"Window operations\".to_string(),\n        action: MenuAction::SubMenu(\"window\".to_string()),\n    });\n\n    root_menu.items.push(MenuItem {\n        key: 'f',\n        label: \"File\".to_string(),\n        description: \"File operations\".to_string(),\n        action: MenuAction::SubMenu(\"file\".to_string()),\n    });\n\n    menus.register(\"root\", root_menu);\n\n    // Buffer submenu\n    let mut buffer_menu = Menu {\n        title: \"Buffer Operations\".to_string(),\n        items: Vec::new(),\n    };\n\n    buffer_menu.items.push(MenuItem {\n        key: 'c',\n        label: \"Clear\".to_string(),\n        description: \"Clear buffer\".to_string(),\n        action: MenuAction::Command(\"buffer.clear\".to_string()),\n    });\n\n    buffer_menu.items.push(MenuItem {\n        key: 's',\n        label: \"Save\".to_string(),\n        description: \"Save buffer to file\".to_string(),\n        action: MenuAction::Command(\"buffer.save\".to_string()),\n    });\n\n    menus.register(\"buffer\", buffer_menu);\n\n    // Window submenu\n    let mut window_menu = Menu {\n        title: \"Window Operations\".to_string(),\n        items: Vec::new(),\n    };\n\n    window_menu.items.push(MenuItem {\n        key: 's',\n        label: \"Split\".to_string(),\n        description: \"Split window\".to_string(),\n        action: MenuAction::Command(\"window.split\".to_string()),\n    });\n\n    window_menu.items.push(MenuItem {\n        key: 'v',\n        label: \"VSplit\".to_string(),\n        description: \"Split window vertically\".to_string(),\n        action: MenuAction::Command(\"window.vsplit\".to_string()),\n    });\n\n    window_menu.items.push(MenuItem {\n        key: 'c',\n        label: \"Close\".to_string(),\n        description: \"Close current window\".to_string(),\n        action: MenuAction::Command(\"window.close\".to_string()),\n    });\n\n    menus.register(\"window\", window_menu);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","ui","link_hints.rs"],"content":"// Vimium-style link hints for clickable URLs and file paths\n// Detects links in terminal output and provides keyboard shortcuts\n\nuse bevy::prelude::*;\nuse bevy::input::keyboard::KeyCode;\nuse bevy::text::{Text, TextStyle, TextSection};\nuse regex::Regex;\nuse std::sync::Arc;\n\n/// Plugin for link hint functionality\npub struct LinkHintsPlugin;\n\nimpl Plugin for LinkHintsPlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        app\n            .init_resource::\u003cLinkDetector\u003e()\n            .init_resource::\u003cLinkHintsState\u003e()\n            .add_event::\u003cLinkActivatedEvent\u003e()\n            .add_systems(Update, (\n                detect_links_system,\n                show_hints_system,\n                handle_hint_input_system,\n                activate_link_system,\n            ).chain());\n    }\n}\n\n/// Detected link in terminal output\n#[derive(Component, Clone, Debug)]\npub struct LinkHint {\n    pub url: String,\n    pub position: Vec2,\n    pub hint_key: String,\n    pub link_type: LinkType,\n}\n\n/// Type of detected link\n#[derive(Clone, Debug, PartialEq)]\npub enum LinkType {\n    Url,\n    FilePath,\n    Email,\n}\n\n/// Link detector with regex patterns\n#[derive(Resource)]\npub struct LinkDetector {\n    url_regex: Regex,\n    filepath_regex: Regex,\n    email_regex: Regex,\n}\n\nimpl Default for LinkDetector {\n    fn default() -\u003e Self {\n        Self {\n            // Match HTTP(S) URLs\n            url_regex: Regex::new(\n                r\"https?://[^\\s\u003c\u003e{}|\\^~\\[\\]`]+|www\\.[^\\s\u003c\u003e{}|\\^~\\[\\]`]+\"\n            ).unwrap(),\n            // Match absolute and relative file paths\n            filepath_regex: Regex::new(\n                r\"(?:~|\\.{1,2}|/)?(?:[a-zA-Z0-9_\\-./]+/)*[a-zA-Z0-9_\\-.]+\"\n            ).unwrap(),\n            // Match email addresses\n            email_regex: Regex::new(\n                r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\"\n            ).unwrap(),\n        }\n    }\n}\n\nimpl LinkDetector {\n    /// Detect all links in text content\n    pub fn detect(\u0026self, text: \u0026str) -\u003e Vec\u003c(String, LinkType)\u003e {\n        let mut links = Vec::new();\n\n        // Detect URLs\n        for cap in self.url_regex.find_iter(text) {\n            links.push((cap.as_str().to_string(), LinkType::Url));\n        }\n\n        // Detect file paths (with basic validation)\n        for cap in self.filepath_regex.find_iter(text) {\n            let path = cap.as_str();\n            // Filter out very short or unlikely paths\n            if path.len() \u003e 3 \u0026\u0026 (path.contains('/') || path.contains('.')) {\n                links.push((path.to_string(), LinkType::FilePath));\n            }\n        }\n\n        // Detect emails\n        for cap in self.email_regex.find_iter(text) {\n            links.push((cap.as_str().to_string(), LinkType::Email));\n        }\n\n        links\n    }\n\n    /// Generate hint keys (aa, ab, ac, ..., ba, bb, ...)\n    pub fn generate_hint_keys(count: usize) -\u003e Vec\u003cString\u003e {\n        let chars = \"abcdefghijklmnopqrstuvwxyz\";\n        let mut keys = Vec::new();\n\n        for i in 0..count {\n            let first = i / 26;\n            let second = i % 26;\n            let key = if first == 0 {\n                chars.chars().nth(second).unwrap().to_string()\n            } else {\n                format!(\n                    \"{}{}\",\n                    chars.chars().nth(first - 1).unwrap(),\n                    chars.chars().nth(second).unwrap()\n                )\n            };\n            keys.push(key);\n        }\n\n        keys\n    }\n}\n\n/// State of link hints system\n#[derive(Resource, Default)]\npub struct LinkHintsState {\n    pub active: bool,\n    pub hints: Vec\u003cLinkHint\u003e,\n    pub current_input: String,\n}\n\n/// Event fired when a link is activated\n#[derive(Event)]\npub struct LinkActivatedEvent {\n    pub link: LinkHint,\n}\n\n/// Component for hint label display\n#[derive(Component)]\nstruct HintLabel {\n    hint_key: String,\n}\n\n/// Detect links in terminal grid\nfn detect_links_system(\n    detector: Res\u003cLinkDetector\u003e,\n    mut state: ResMut\u003cLinkHintsState\u003e,\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n) {\n    // Toggle link hints with Ctrl+K\n    if keyboard.just_pressed(KeyCode::ControlLeft) \u0026\u0026 keyboard.pressed(KeyCode::KeyK) {\n        state.active = !state.active;\n\n        if state.active {\n            // TODO: Get actual terminal text from SharedState\n            let sample_text = \"Check out https://example.com or /path/to/file.txt\";\n            let detected_links = detector.detect(sample_text);\n\n            let hint_keys = LinkDetector::generate_hint_keys(detected_links.len());\n\n            state.hints = detected_links\n                .into_iter()\n                .zip(hint_keys)\n                .enumerate()\n                .map(|(i, ((url, link_type), hint_key))| LinkHint {\n                    url,\n                    position: Vec2::new(100.0, 100.0 + i as f32 * 20.0), // TODO: Calculate from grid\n                    hint_key,\n                    link_type,\n                })\n                .collect();\n\n            state.current_input.clear();\n        } else {\n            state.hints.clear();\n            state.current_input.clear();\n        }\n    }\n}\n\n/// Show hint labels on screen\nfn show_hints_system(\n    mut commands: Commands,\n    state: Res\u003cLinkHintsState\u003e,\n    existing_hints: Query\u003cEntity, With\u003cHintLabel\u003e\u003e,\n    asset_server: Res\u003cAssetServer\u003e,\n) {\n    // Remove existing hint labels\n    for entity in existing_hints.iter() {\n        commands.entity(entity).despawn();\n    }\n\n    if !state.active {\n        return;\n    }\n\n    // Spawn new hint labels\n    for hint in \u0026state.hints {\n        let mut matched = false;\n        let mut partial_match = true;\n\n        if !state.current_input.is_empty() {\n            if hint.hint_key.starts_with(\u0026state.current_input) {\n                matched = hint.hint_key == state.current_input;\n                partial_match = true;\n            } else {\n                partial_match = false;\n            }\n        }\n\n        if !partial_match {\n            continue;\n        }\n\n        let color = if matched {\n            Color::srgb(0.0, 1.0, 0.0) // Green when matched\n        } else {\n            Color::srgb(1.0, 1.0, 0.0) // Yellow for hints\n        };\n\n        commands.spawn((\n            HintLabel {\n                hint_key: hint.hint_key.clone(),\n            },\n            Text2dBundle {\n                text: Text::from_section(\n                    \u0026hint.hint_key,\n                    TextStyle {\n                        font_size: 16.0,\n                        color,\n                        ..default()\n                    },\n                ),\n                transform: Transform::from_translation(hint.position.extend(100.0)),\n                ..default()\n            },\n        ));\n    }\n}\n\n/// Handle keyboard input for hint selection\nfn handle_hint_input_system(\n    mut state: ResMut\u003cLinkHintsState\u003e,\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    mut event_writer: EventWriter\u003cLinkActivatedEvent\u003e,\n) {\n    if !state.active {\n        return;\n    }\n\n    // Handle escape to cancel\n    if keyboard.just_pressed(KeyCode::Escape) {\n        state.active = false;\n        state.hints.clear();\n        state.current_input.clear();\n        return;\n    }\n\n    // Handle letter input\n    for key_code in keyboard.get_just_pressed() {\n        if let Some(char) = keycode_to_char(*key_code) {\n            state.current_input.push(char);\n\n            // Check if we have a complete match\n            if let Some(hint) = state.hints.iter().find(|h| h.hint_key == state.current_input) {\n                event_writer.send(LinkActivatedEvent {\n                    link: hint.clone(),\n                });\n                state.active = false;\n                state.hints.clear();\n                state.current_input.clear();\n            }\n        }\n    }\n}\n\n/// Activate selected link\nfn activate_link_system(\n    mut events: EventReader\u003cLinkActivatedEvent\u003e,\n) {\n    for event in events.read() {\n        match event.link.link_type {\n            LinkType::Url =\u003e {\n                info!(\"Opening URL: {}\", event.link.url);\n                // TODO: Open URL in browser\n                #[cfg(target_os = \"macos\")]\n                {\n                    std::process::Command::new(\"open\")\n                        .arg(\u0026event.link.url)\n                        .spawn()\n                        .ok();\n                }\n            }\n            LinkType::FilePath =\u003e {\n                info!(\"Opening file: {}\", event.link.url);\n                // TODO: Open file in editor\n            }\n            LinkType::Email =\u003e {\n                info!(\"Opening email: {}\", event.link.url);\n                // TODO: Open email client\n            }\n        }\n    }\n}\n\n/// Convert KeyCode to character (a-z)\nfn keycode_to_char(keycode: KeyCode) -\u003e Option\u003cchar\u003e {\n    match keycode {\n        KeyCode::KeyA =\u003e Some('a'),\n        KeyCode::KeyB =\u003e Some('b'),\n        KeyCode::KeyC =\u003e Some('c'),\n        KeyCode::KeyD =\u003e Some('d'),\n        KeyCode::KeyE =\u003e Some('e'),\n        KeyCode::KeyF =\u003e Some('f'),\n        KeyCode::KeyG =\u003e Some('g'),\n        KeyCode::KeyH =\u003e Some('h'),\n        KeyCode::KeyI =\u003e Some('i'),\n        KeyCode::KeyJ =\u003e Some('j'),\n        KeyCode::KeyK =\u003e Some('k'),\n        KeyCode::KeyL =\u003e Some('l'),\n        KeyCode::KeyM =\u003e Some('m'),\n        KeyCode::KeyN =\u003e Some('n'),\n        KeyCode::KeyO =\u003e Some('o'),\n        KeyCode::KeyP =\u003e Some('p'),\n        KeyCode::KeyQ =\u003e Some('q'),\n        KeyCode::KeyR =\u003e Some('r'),\n        KeyCode::KeyS =\u003e Some('s'),\n        KeyCode::KeyT =\u003e Some('t'),\n        KeyCode::KeyU =\u003e Some('u'),\n        KeyCode::KeyV =\u003e Some('v'),\n        KeyCode::KeyW =\u003e Some('w'),\n        KeyCode::KeyX =\u003e Some('x'),\n        KeyCode::KeyY =\u003e Some('y'),\n        KeyCode::KeyZ =\u003e Some('z'),\n        _ =\u003e None,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_url_detection() {\n        let detector = LinkDetector::default();\n        let text = \"Visit https://example.com or www.github.com\";\n        let links = detector.detect(text);\n\n        assert_eq!(links.len(), 2);\n        assert_eq!(links[0].0, \"https://example.com\");\n        assert_eq!(links[1].0, \"www.github.com\");\n    }\n\n    #[test]\n    fn test_filepath_detection() {\n        let detector = LinkDetector::default();\n        let text = \"Check /usr/local/bin or ./relative/path.txt\";\n        let links = detector.detect(text);\n\n        assert!(links.iter().any(|(l, _)| l.contains(\"/usr/local/bin\")));\n        assert!(links.iter().any(|(l, _)| l.contains(\"./relative/path.txt\")));\n    }\n\n    #[test]\n    fn test_hint_key_generation() {\n        let keys = LinkDetector::generate_hint_keys(30);\n\n        assert_eq!(keys[0], \"a\");\n        assert_eq!(keys[25], \"z\");\n        assert_eq!(keys[26], \"aa\");\n        assert_eq!(keys[27], \"ab\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","ui","mod.rs"],"content":"// Advanced UI/UX module for Scarab terminal emulator\n// Provides power-user features: link hints, command palette, leader keys, etc.\n\npub mod link_hints;\npub mod command_palette;\npub mod leader_key;\npub mod keybindings;\npub mod animations;\npub mod visual_selection;\n\npub use link_hints::{LinkHintsPlugin, LinkHint, LinkDetector};\npub use command_palette::{CommandPalettePlugin, Command, CommandRegistry};\npub use leader_key::{LeaderKeyPlugin, LeaderKeyState};\npub use keybindings::{KeybindingsPlugin, KeyBinding, KeyBindingConfig};\npub use animations::{AnimationsPlugin, FadeAnimation, AnimationState};\npub use visual_selection::{VisualSelectionPlugin, SelectionMode, SelectionRegion};\n\nuse bevy::prelude::*;\n\n/// Main plugin that bundles all UI features\npub struct AdvancedUIPlugin;\n\nimpl Plugin for AdvancedUIPlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        app\n            .add_plugins((\n                LinkHintsPlugin,\n                CommandPalettePlugin,\n                LeaderKeyPlugin,\n                KeybindingsPlugin,\n                AnimationsPlugin,\n                VisualSelectionPlugin,\n            ))\n            .insert_resource(UIConfig::default());\n    }\n}\n\n/// Global UI configuration\n#[derive(Resource, Clone)]\npub struct UIConfig {\n    pub link_hints_enabled: bool,\n    pub command_palette_enabled: bool,\n    pub leader_key_enabled: bool,\n    pub animations_enabled: bool,\n    pub leader_key_timeout_ms: u64,\n    pub fuzzy_search_threshold: f64,\n}\n\nimpl Default for UIConfig {\n    fn default() -\u003e Self {\n        Self {\n            link_hints_enabled: true,\n            command_palette_enabled: true,\n            leader_key_enabled: true,\n            animations_enabled: true,\n            leader_key_timeout_ms: 1000,\n            fuzzy_search_threshold: 0.3,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","src","ui","visual_selection.rs"],"content":"// Visual selection mode for terminal text\n// Allows users to select text using keyboard\n\nuse bevy::prelude::*;\nuse bevy::input::keyboard::KeyCode;\n\n/// Plugin for visual selection\npub struct VisualSelectionPlugin;\n\nimpl Plugin for VisualSelectionPlugin {\n    fn build(\u0026self, app: \u0026mut App) {\n        app\n            .init_resource::\u003cSelectionState\u003e()\n            .add_event::\u003cSelectionChangedEvent\u003e()\n            .add_event::\u003cSelectionCopiedEvent\u003e()\n            .add_systems(Update, (\n                handle_selection_input_system,\n                render_selection_system,\n                copy_selection_system,\n            ));\n    }\n}\n\n/// Selection mode type\n#[derive(Clone, Copy, Debug, PartialEq)]\npub enum SelectionMode {\n    Character,\n    Line,\n    Block,\n}\n\n/// Region of selected text\n#[derive(Clone, Debug, Default)]\npub struct SelectionRegion {\n    pub start_x: u16,\n    pub start_y: u16,\n    pub end_x: u16,\n    pub end_y: u16,\n}\n\nimpl SelectionRegion {\n    pub fn new(start_x: u16, start_y: u16, end_x: u16, end_y: u16) -\u003e Self {\n        Self {\n            start_x,\n            start_y,\n            end_x,\n            end_y,\n        }\n    }\n\n    pub fn contains(\u0026self, x: u16, y: u16) -\u003e bool {\n        let (min_x, max_x) = if self.start_x \u003c= self.end_x {\n            (self.start_x, self.end_x)\n        } else {\n            (self.end_x, self.start_x)\n        };\n\n        let (min_y, max_y) = if self.start_y \u003c= self.end_y {\n            (self.start_y, self.end_y)\n        } else {\n            (self.end_y, self.start_y)\n        };\n\n        x \u003e= min_x \u0026\u0026 x \u003c= max_x \u0026\u0026 y \u003e= min_y \u0026\u0026 y \u003c= max_y\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.start_x == self.end_x \u0026\u0026 self.start_y == self.end_y\n    }\n\n    pub fn normalize(\u0026mut self) {\n        if self.start_y \u003e self.end_y || (self.start_y == self.end_y \u0026\u0026 self.start_x \u003e self.end_x) {\n            std::mem::swap(\u0026mut self.start_x, \u0026mut self.end_x);\n            std::mem::swap(\u0026mut self.start_y, \u0026mut self.end_y);\n        }\n    }\n}\n\n/// State of visual selection\n#[derive(Resource)]\npub struct SelectionState {\n    pub active: bool,\n    pub mode: SelectionMode,\n    pub region: SelectionRegion,\n    pub cursor_x: u16,\n    pub cursor_y: u16,\n}\n\nimpl Default for SelectionState {\n    fn default() -\u003e Self {\n        Self {\n            active: false,\n            mode: SelectionMode::Character,\n            region: SelectionRegion::default(),\n            cursor_x: 0,\n            cursor_y: 0,\n        }\n    }\n}\n\nimpl SelectionState {\n    pub fn start_selection(\u0026mut self, x: u16, y: u16, mode: SelectionMode) {\n        self.active = true;\n        self.mode = mode;\n        self.region = SelectionRegion::new(x, y, x, y);\n        self.cursor_x = x;\n        self.cursor_y = y;\n    }\n\n    pub fn update_selection(\u0026mut self, x: u16, y: u16) {\n        if !self.active {\n            return;\n        }\n\n        self.region.end_x = x;\n        self.region.end_y = y;\n        self.cursor_x = x;\n        self.cursor_y = y;\n    }\n\n    pub fn end_selection(\u0026mut self) {\n        self.active = false;\n    }\n\n    pub fn clear(\u0026mut self) {\n        self.active = false;\n        self.region = SelectionRegion::default();\n    }\n}\n\n/// Event fired when selection changes\n#[derive(Event)]\npub struct SelectionChangedEvent {\n    pub region: SelectionRegion,\n}\n\n/// Event fired when selection is copied\n#[derive(Event)]\npub struct SelectionCopiedEvent {\n    pub text: String,\n}\n\n/// Component for selection overlay\n#[derive(Component)]\nstruct SelectionOverlay;\n\n/// Handle keyboard input for visual selection\nfn handle_selection_input_system(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    mut state: ResMut\u003cSelectionState\u003e,\n    mut event_writer: EventWriter\u003cSelectionChangedEvent\u003e,\n) {\n    // Enter visual mode with 'v'\n    if keyboard.just_pressed(KeyCode::KeyV) \u0026\u0026 !state.active {\n        // TODO: Get actual cursor position from terminal state\n        state.start_selection(0, 0, SelectionMode::Character);\n        info!(\"Visual selection mode activated\");\n    }\n\n    // Enter visual line mode with 'V'\n    if keyboard.just_pressed(KeyCode::KeyV) \u0026\u0026 keyboard.pressed(KeyCode::ShiftLeft) \u0026\u0026 !state.active {\n        state.start_selection(0, 0, SelectionMode::Line);\n        info!(\"Visual line selection mode activated\");\n    }\n\n    // Enter visual block mode with Ctrl+V\n    if keyboard.just_pressed(KeyCode::KeyV) \u0026\u0026 keyboard.pressed(KeyCode::ControlLeft) \u0026\u0026 !state.active {\n        state.start_selection(0, 0, SelectionMode::Block);\n        info!(\"Visual block selection mode activated\");\n    }\n\n    if !state.active {\n        return;\n    }\n\n    // Exit visual mode with Escape\n    if keyboard.just_pressed(KeyCode::Escape) {\n        state.end_selection();\n        info!(\"Visual selection mode deactivated\");\n        return;\n    }\n\n    // Move cursor with arrow keys\n    let mut cursor_moved = false;\n    let mut new_x = state.cursor_x;\n    let mut new_y = state.cursor_y;\n\n    if keyboard.just_pressed(KeyCode::ArrowLeft) {\n        new_x = new_x.saturating_sub(1);\n        cursor_moved = true;\n    }\n\n    if keyboard.just_pressed(KeyCode::ArrowRight) {\n        new_x = new_x.saturating_add(1);\n        cursor_moved = true;\n    }\n\n    if keyboard.just_pressed(KeyCode::ArrowUp) {\n        new_y = new_y.saturating_sub(1);\n        cursor_moved = true;\n    }\n\n    if keyboard.just_pressed(KeyCode::ArrowDown) {\n        new_y = new_y.saturating_add(1);\n        cursor_moved = true;\n    }\n\n    if cursor_moved {\n        state.update_selection(new_x, new_y);\n        event_writer.send(SelectionChangedEvent {\n            region: state.region.clone(),\n        });\n    }\n}\n\n/// Render selection overlay\nfn render_selection_system(\n    mut commands: Commands,\n    state: Res\u003cSelectionState\u003e,\n    existing_overlays: Query\u003cEntity, With\u003cSelectionOverlay\u003e\u003e,\n) {\n    // Remove existing overlays\n    for entity in existing_overlays.iter() {\n        commands.entity(entity).despawn();\n    }\n\n    if !state.active || state.region.is_empty() {\n        return;\n    }\n\n    // TODO: Calculate actual pixel positions from grid coordinates\n    let cell_width = 8.0;\n    let cell_height = 16.0;\n\n    let mut region = state.region.clone();\n    region.normalize();\n\n    match state.mode {\n        SelectionMode::Character =\u003e {\n            // Render character-wise selection\n            for y in region.start_y..=region.end_y {\n                let start_x = if y == region.start_y {\n                    region.start_x\n                } else {\n                    0\n                };\n\n                let end_x = if y == region.end_y {\n                    region.end_x\n                } else {\n                    79 // TODO: Get actual grid width\n                };\n\n                commands.spawn((\n                    SelectionOverlay,\n                    SpriteBundle {\n                        sprite: Sprite {\n                            color: Color::srgba(0.3, 0.5, 1.0, 0.3),\n                            custom_size: Some(Vec2::new(\n                                (end_x - start_x + 1) as f32 * cell_width,\n                                cell_height,\n                            )),\n                            ..default()\n                        },\n                        transform: Transform::from_xyz(\n                            start_x as f32 * cell_width,\n                            -(y as f32 * cell_height),\n                            10.0,\n                        ),\n                        ..default()\n                    },\n                ));\n            }\n        }\n\n        SelectionMode::Line =\u003e {\n            // Render line-wise selection (full lines)\n            for y in region.start_y..=region.end_y {\n                commands.spawn((\n                    SelectionOverlay,\n                    SpriteBundle {\n                        sprite: Sprite {\n                            color: Color::srgba(0.3, 0.5, 1.0, 0.3),\n                            custom_size: Some(Vec2::new(\n                                80.0 * cell_width, // TODO: Get actual grid width\n                                cell_height,\n                            )),\n                            ..default()\n                        },\n                        transform: Transform::from_xyz(\n                            0.0,\n                            -(y as f32 * cell_height),\n                            10.0,\n                        ),\n                        ..default()\n                    },\n                ));\n            }\n        }\n\n        SelectionMode::Block =\u003e {\n            // Render block-wise selection (rectangular)\n            commands.spawn((\n                SelectionOverlay,\n                SpriteBundle {\n                    sprite: Sprite {\n                        color: Color::srgba(0.3, 0.5, 1.0, 0.3),\n                        custom_size: Some(Vec2::new(\n                            (region.end_x - region.start_x + 1) as f32 * cell_width,\n                            (region.end_y - region.start_y + 1) as f32 * cell_height,\n                        )),\n                        ..default()\n                    },\n                    transform: Transform::from_xyz(\n                        region.start_x as f32 * cell_width,\n                        -(region.start_y as f32 * cell_height),\n                        10.0,\n                    ),\n                    ..default()\n                },\n            ));\n        }\n    }\n}\n\n/// Copy selected text to clipboard\nfn copy_selection_system(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    state: Res\u003cSelectionState\u003e,\n    mut event_writer: EventWriter\u003cSelectionCopiedEvent\u003e,\n) {\n    if !state.active {\n        return;\n    }\n\n    // Copy with 'y' (yank in vim terminology)\n    if keyboard.just_pressed(KeyCode::KeyY) {\n        // TODO: Extract actual text from SharedState based on selection region\n        let text = format!(\n            \"Selected text from ({}, {}) to ({}, {})\",\n            state.region.start_x, state.region.start_y,\n            state.region.end_x, state.region.end_y\n        );\n\n        info!(\"Copied selection: {}\", text);\n        event_writer.send(SelectionCopiedEvent { text });\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_selection_region_contains() {\n        let region = SelectionRegion::new(5, 5, 10, 10);\n\n        assert!(region.contains(5, 5));\n        assert!(region.contains(10, 10));\n        assert!(region.contains(7, 7));\n        assert!(!region.contains(4, 5));\n        assert!(!region.contains(11, 10));\n    }\n\n    #[test]\n    fn test_selection_region_normalize() {\n        let mut region = SelectionRegion::new(10, 10, 5, 5);\n        region.normalize();\n\n        assert_eq!(region.start_x, 5);\n        assert_eq!(region.start_y, 5);\n        assert_eq!(region.end_x, 10);\n        assert_eq!(region.end_y, 10);\n    }\n\n    #[test]\n    fn test_selection_state() {\n        let mut state = SelectionState::default();\n\n        assert!(!state.active);\n\n        state.start_selection(5, 5, SelectionMode::Character);\n        assert!(state.active);\n        assert_eq!(state.region.start_x, 5);\n        assert_eq!(state.region.start_y, 5);\n\n        state.update_selection(10, 10);\n        assert_eq!(state.region.end_x, 10);\n        assert_eq!(state.region.end_y, 10);\n\n        state.end_selection();\n        assert!(!state.active);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-client","tests","ui_tests.rs"],"content":"// Comprehensive tests for UI components\n// Tests link hints, command palette, leader key, keybindings, animations, and visual selection\n\n#[cfg(test)]\nmod link_hints_tests {\n    use scarab_client::ui::{LinkDetector, LinkType};\n\n    #[test]\n    fn test_url_detection_http() {\n        let detector = LinkDetector::default();\n        let text = \"Check out https://example.com for more info\";\n        let links = detector.detect(text);\n\n        assert_eq!(links.len(), 1);\n        assert_eq!(links[0].0, \"https://example.com\");\n        assert_eq!(links[0].1, LinkType::Url);\n    }\n\n    #[test]\n    fn test_url_detection_www() {\n        let detector = LinkDetector::default();\n        let text = \"Visit www.github.com/user/repo\";\n        let links = detector.detect(text);\n\n        assert!(links.iter().any(|(url, _)| url.contains(\"www.github.com\")));\n    }\n\n    #[test]\n    fn test_multiple_urls() {\n        let detector = LinkDetector::default();\n        let text = \"Check https://example.com and www.test.org\";\n        let links = detector.detect(text);\n\n        assert!(links.len() \u003e= 2);\n    }\n\n    #[test]\n    fn test_filepath_detection() {\n        let detector = LinkDetector::default();\n        let text = \"Edit /usr/local/bin/script.sh or ./relative/path.txt\";\n        let links = detector.detect(text);\n\n        assert!(links.iter().any(|(path, _)| path.contains(\"/usr/local/bin\")));\n        assert!(links.iter().any(|(path, _)| path.contains(\"./relative/path.txt\")));\n    }\n\n    #[test]\n    fn test_email_detection() {\n        let detector = LinkDetector::default();\n        let text = \"Contact user@example.com for support\";\n        let links = detector.detect(text);\n\n        assert!(links.iter().any(|(email, t)| {\n            email == \"user@example.com\" \u0026\u0026 *t == LinkType::Email\n        }));\n    }\n\n    #[test]\n    fn test_hint_key_generation() {\n        let keys = LinkDetector::generate_hint_keys(30);\n\n        assert_eq!(keys.len(), 30);\n        assert_eq!(keys[0], \"a\");\n        assert_eq!(keys[25], \"z\");\n        assert_eq!(keys[26], \"aa\");\n        assert_eq!(keys[27], \"ab\");\n\n        // Ensure all keys are unique\n        let unique_keys: std::collections::HashSet\u003c_\u003e = keys.iter().collect();\n        assert_eq!(unique_keys.len(), 30);\n    }\n\n    #[test]\n    fn test_hint_key_generation_large() {\n        let keys = LinkDetector::generate_hint_keys(100);\n        assert_eq!(keys.len(), 100);\n\n        // All keys should be unique\n        let unique_keys: std::collections::HashSet\u003c_\u003e = keys.iter().collect();\n        assert_eq!(unique_keys.len(), 100);\n    }\n\n    #[test]\n    fn test_link_detection_accuracy() {\n        let detector = LinkDetector::default();\n\n        // Test cases with expected link counts\n        let test_cases = vec![\n            (\"No links here\", 0),\n            (\"https://example.com\", 1),\n            (\"Visit https://a.com and https://b.com\", 2),\n            (\"Email user@test.com\", 1),\n            (\"/path/to/file.txt\", 1),\n        ];\n\n        for (text, expected_count) in test_cases {\n            let links = detector.detect(text);\n            assert!(\n                links.len() \u003e= expected_count,\n                \"Text '{}' should have at least {} links, got {}\",\n                text,\n                expected_count,\n                links.len()\n            );\n        }\n    }\n}\n\n#[cfg(test)]\nmod command_palette_tests {\n    use scarab_client::ui::{Command, CommandRegistry};\n    use std::sync::Arc;\n\n    #[test]\n    fn test_command_registration() {\n        let mut registry = CommandRegistry::default();\n\n        registry.register(Command::new(\n            \"test\",\n            \"Test Command\",\n            \"A test command\",\n            \"Test\",\n            || {},\n        ));\n\n        assert!(registry.get(\"test\").is_some());\n        assert_eq!(registry.get(\"test\").unwrap().name, \"Test Command\");\n    }\n\n    #[test]\n    fn test_fuzzy_search_exact_match() {\n        let mut registry = CommandRegistry::default();\n\n        registry.register(Command::new(\n            \"copy\",\n            \"Copy Selection\",\n            \"Copy text to clipboard\",\n            \"Edit\",\n            || {},\n        ));\n\n        let results = registry.fuzzy_search(\"Copy\");\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].0.id, \"copy\");\n    }\n\n    #[test]\n    fn test_fuzzy_search_partial_match() {\n        let mut registry = CommandRegistry::default();\n\n        registry.register(Command::new(\n            \"copy\",\n            \"Copy Selection\",\n            \"Copy text\",\n            \"Edit\",\n            || {},\n        ));\n\n        let results = registry.fuzzy_search(\"cop\");\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].0.id, \"copy\");\n    }\n\n    #[test]\n    fn test_fuzzy_search_ranking() {\n        let mut registry = CommandRegistry::default();\n\n        registry.register(Command::new(\"a\", \"Copy\", \"Copy text\", \"Edit\", || {}));\n        registry.register(Command::new(\"b\", \"Paste\", \"Paste text\", \"Edit\", || {}));\n        registry.register(Command::new(\"c\", \"Cut\", \"Cut text\", \"Edit\", || {}));\n\n        let results = registry.fuzzy_search(\"copy\");\n        assert!(results.len() \u003e 0);\n        assert_eq!(results[0].0.id, \"a\"); // \"Copy\" should rank highest\n    }\n\n    #[test]\n    fn test_fuzzy_search_performance() {\n        let mut registry = CommandRegistry::default();\n\n        // Register 1000 commands\n        for i in 0..1000 {\n            registry.register(Command::new(\n                \u0026format!(\"cmd_{}\", i),\n                \u0026format!(\"Command {}\", i),\n                \u0026format!(\"Description {}\", i),\n                \"Test\",\n                || {},\n            ));\n        }\n\n        // Search should complete quickly\n        use std::time::Instant;\n        let start = Instant::now();\n        let _results = registry.fuzzy_search(\"command\");\n        let duration = start.elapsed();\n\n        // Should complete in less than 50ms\n        assert!(\n            duration.as_millis() \u003c 50,\n            \"Fuzzy search took {}ms, expected \u003c50ms\",\n            duration.as_millis()\n        );\n    }\n\n    #[test]\n    fn test_empty_search() {\n        let mut registry = CommandRegistry::default();\n\n        registry.register(Command::new(\"a\", \"Test A\", \"Test\", \"Cat\", || {}));\n        registry.register(Command::new(\"b\", \"Test B\", \"Test\", \"Cat\", || {}));\n\n        // Empty search should return all commands\n        let results = registry.fuzzy_search(\"\");\n        assert_eq!(results.len(), 2);\n    }\n\n    #[test]\n    fn test_no_matches() {\n        let mut registry = CommandRegistry::default();\n\n        registry.register(Command::new(\"a\", \"Test\", \"Test\", \"Cat\", || {}));\n\n        let results = registry.fuzzy_search(\"xyz123nonexistent\");\n        assert_eq!(results.len(), 0);\n    }\n}\n\n#[cfg(test)]\nmod keybindings_tests {\n    use scarab_client::ui::{KeyBinding, KeyBindingConfig};\n    use bevy::input::keyboard::KeyCode;\n\n    #[test]\n    fn test_keybinding_creation() {\n        let binding = KeyBinding::new(KeyCode::KeyC).with_ctrl();\n\n        assert_eq!(binding.key, KeyCode::KeyC);\n        assert!(binding.ctrl);\n        assert!(!binding.alt);\n        assert!(!binding.shift);\n    }\n\n    #[test]\n    fn test_keybinding_string_conversion() {\n        let binding = KeyBinding::new(KeyCode::KeyC)\n            .with_ctrl()\n            .with_shift();\n\n        let string = binding.to_string();\n        assert_eq!(string, \"Ctrl+Shift+KeyC\");\n\n        let parsed = KeyBinding::from_string(\u0026string).unwrap();\n        assert_eq!(parsed, binding);\n    }\n\n    #[test]\n    fn test_keybinding_config() {\n        let mut config = KeyBindingConfig::default();\n\n        let binding = KeyBinding::new(KeyCode::KeyS).with_ctrl();\n        config.bind(binding.clone(), \"file.save\");\n\n        assert_eq!(config.get_action(\u0026binding), Some(\"file.save\"));\n    }\n\n    #[test]\n    fn test_find_binding_by_action() {\n        let mut config = KeyBindingConfig::default();\n\n        let binding = KeyBinding::new(KeyCode::KeyO).with_ctrl();\n        config.bind(binding.clone(), \"file.open\");\n\n        let found = config.find_binding(\"file.open\");\n        assert!(found.is_some());\n        assert_eq!(found.unwrap(), \u0026binding);\n    }\n\n    #[test]\n    fn test_unbind() {\n        let mut config = KeyBindingConfig::default();\n\n        let binding = KeyBinding::new(KeyCode::KeyX).with_ctrl();\n        config.bind(binding.clone(), \"edit.cut\");\n\n        assert!(config.get_action(\u0026binding).is_some());\n\n        config.unbind(\u0026binding);\n        assert!(config.get_action(\u0026binding).is_none());\n    }\n\n    #[test]\n    fn test_default_bindings() {\n        let config = KeyBindingConfig::default();\n\n        // Should have some default bindings\n        assert!(config.all_bindings().len() \u003e 0);\n\n        // Check for common bindings\n        let ctrl_c = KeyBinding::new(KeyCode::KeyC).with_ctrl();\n        assert!(config.get_action(\u0026ctrl_c).is_some());\n    }\n}\n\n#[cfg(test)]\nmod animation_tests {\n    use scarab_client::ui::FadeAnimation;\n\n    #[test]\n    fn test_fade_in_animation() {\n        let mut anim = FadeAnimation::fade_in(1.0);\n\n        assert_eq!(anim.progress(), 0.0);\n        assert_eq!(anim.alpha(), 0.0);\n\n        anim.elapsed = 0.5;\n        assert!(anim.alpha() \u003e 0.0 \u0026\u0026 anim.alpha() \u003c 1.0);\n\n        anim.elapsed = 1.0;\n        assert_eq!(anim.alpha(), 1.0);\n        assert!(anim.is_complete());\n    }\n\n    #[test]\n    fn test_fade_out_animation() {\n        let mut anim = FadeAnimation::fade_out(1.0);\n\n        assert_eq!(anim.alpha(), 1.0);\n\n        anim.elapsed = 0.5;\n        assert!(anim.alpha() \u003e 0.0 \u0026\u0026 anim.alpha() \u003c 1.0);\n\n        anim.elapsed = 1.0;\n        assert_eq!(anim.alpha(), 0.0);\n        assert!(anim.is_complete());\n    }\n\n    #[test]\n    fn test_animation_clamping() {\n        let mut anim = FadeAnimation::fade_in(1.0);\n\n        anim.elapsed = 2.0; // Exceed duration\n        assert_eq!(anim.progress(), 1.0); // Should be clamped\n    }\n\n    #[test]\n    fn test_easing_functions() {\n        use scarab_client::ui::animations::easing::*;\n\n        // Test boundary conditions\n        assert_eq!(ease_in_cubic(0.0), 0.0);\n        assert_eq!(ease_in_cubic(1.0), 1.0);\n\n        assert_eq!(ease_out_cubic(0.0), 0.0);\n        assert_eq!(ease_out_cubic(1.0), 1.0);\n\n        assert_eq!(ease_in_out_cubic(0.0), 0.0);\n        assert_eq!(ease_in_out_cubic(1.0), 1.0);\n\n        // Test midpoint behavior\n        let mid_in = ease_in_cubic(0.5);\n        let mid_out = ease_out_cubic(0.5);\n        assert!(mid_in \u003c 0.5); // Ease in should be slower at start\n        assert!(mid_out \u003e 0.5); // Ease out should be faster at start\n    }\n\n    #[test]\n    fn test_60fps_animation_smoothness() {\n        let mut anim = FadeAnimation::fade_in(1.0);\n        let frame_time = 1.0 / 60.0; // 16.67ms per frame\n\n        let mut last_alpha = 0.0;\n        for _ in 0..60 {\n            anim.elapsed += frame_time;\n            let alpha = anim.alpha();\n\n            // Alpha should increase monotonically\n            assert!(alpha \u003e= last_alpha);\n\n            // Change should be smooth (not too large)\n            let delta = alpha - last_alpha;\n            assert!(delta \u003c 0.5, \"Alpha change too large: {}\", delta);\n\n            last_alpha = alpha;\n        }\n\n        assert!(anim.is_complete());\n    }\n}\n\n#[cfg(test)]\nmod visual_selection_tests {\n    use scarab_client::ui::{SelectionRegion, SelectionMode, SelectionState};\n\n    #[test]\n    fn test_selection_region_contains() {\n        let region = SelectionRegion::new(5, 5, 10, 10);\n\n        assert!(region.contains(5, 5));\n        assert!(region.contains(10, 10));\n        assert!(region.contains(7, 7));\n        assert!(!region.contains(4, 5));\n        assert!(!region.contains(11, 10));\n    }\n\n    #[test]\n    fn test_selection_region_normalize() {\n        let mut region = SelectionRegion::new(10, 10, 5, 5);\n        region.normalize();\n\n        assert_eq!(region.start_x, 5);\n        assert_eq!(region.start_y, 5);\n        assert_eq!(region.end_x, 10);\n        assert_eq!(region.end_y, 10);\n    }\n\n    #[test]\n    fn test_selection_region_is_empty() {\n        let region1 = SelectionRegion::new(5, 5, 5, 5);\n        assert!(region1.is_empty());\n\n        let region2 = SelectionRegion::new(5, 5, 10, 10);\n        assert!(!region2.is_empty());\n    }\n\n    #[test]\n    fn test_selection_state_lifecycle() {\n        let mut state = SelectionState::default();\n\n        assert!(!state.active);\n\n        state.start_selection(5, 5, SelectionMode::Character);\n        assert!(state.active);\n        assert_eq!(state.region.start_x, 5);\n        assert_eq!(state.region.start_y, 5);\n\n        state.update_selection(10, 10);\n        assert_eq!(state.region.end_x, 10);\n        assert_eq!(state.region.end_y, 10);\n\n        state.end_selection();\n        assert!(!state.active);\n    }\n\n    #[test]\n    fn test_selection_modes() {\n        let mut state = SelectionState::default();\n\n        state.start_selection(0, 0, SelectionMode::Character);\n        assert_eq!(state.mode, SelectionMode::Character);\n\n        state.start_selection(0, 0, SelectionMode::Line);\n        assert_eq!(state.mode, SelectionMode::Line);\n\n        state.start_selection(0, 0, SelectionMode::Block);\n        assert_eq!(state.mode, SelectionMode::Block);\n    }\n\n    #[test]\n    fn test_selection_clear() {\n        let mut state = SelectionState::default();\n\n        state.start_selection(5, 5, SelectionMode::Character);\n        state.update_selection(10, 10);\n\n        state.clear();\n\n        assert!(!state.active);\n        assert!(state.region.is_empty());\n    }\n}\n\n#[cfg(test)]\nmod integration_tests {\n    // Integration tests would go here\n    // These would test the interaction between different UI components\n    // For example: leader key triggering command palette, etc.\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-config","src","config.rs"],"content":"//! Core configuration structures\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Root configuration structure\n#[derive(Debug, Clone, Deserialize, Serialize)]\n#[serde(default)]\npub struct ScarabConfig {\n    pub terminal: TerminalConfig,\n    pub font: FontConfig,\n    pub colors: ColorConfig,\n    pub keybindings: KeyBindings,\n    pub ui: UiConfig,\n    pub plugins: PluginConfig,\n    pub sessions: SessionConfig,\n}\n\nimpl Default for ScarabConfig {\n    fn default() -\u003e Self {\n        Self {\n            terminal: TerminalConfig::default(),\n            font: FontConfig::default(),\n            colors: ColorConfig::default(),\n            keybindings: KeyBindings::default(),\n            ui: UiConfig::default(),\n            plugins: PluginConfig::default(),\n            sessions: SessionConfig::default(),\n        }\n    }\n}\n\nimpl ScarabConfig {\n    /// Merge another config into this one (for local overrides)\n    pub fn merge(\u0026mut self, other: ScarabConfig) {\n        // Terminal settings\n        if other.terminal != TerminalConfig::default() {\n            self.terminal = other.terminal;\n        }\n\n        // Font settings\n        if other.font != FontConfig::default() {\n            self.font = other.font;\n        }\n\n        // Colors\n        if other.colors != ColorConfig::default() {\n            self.colors = other.colors;\n        }\n\n        // Keybindings\n        self.keybindings.custom.extend(other.keybindings.custom);\n\n        // UI settings\n        if other.ui != UiConfig::default() {\n            self.ui = other.ui;\n        }\n\n        // Plugins\n        self.plugins.enabled.extend(other.plugins.enabled);\n        self.plugins.config.extend(other.plugins.config);\n\n        // Sessions\n        if other.sessions != SessionConfig::default() {\n            self.sessions = other.sessions;\n        }\n    }\n}\n\n/// Terminal emulator settings\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\n#[serde(default)]\npub struct TerminalConfig {\n    pub default_shell: String,\n    pub scrollback_lines: u32,\n    pub alt_screen: bool,\n    pub scroll_multiplier: f32,\n    pub auto_scroll: bool,\n}\n\nimpl Default for TerminalConfig {\n    fn default() -\u003e Self {\n        Self {\n            default_shell: std::env::var(\"SHELL\").unwrap_or_else(|_| \"/bin/zsh\".to_string()),\n            scrollback_lines: 10_000,\n            alt_screen: true,\n            scroll_multiplier: 3.0,\n            auto_scroll: true,\n        }\n    }\n}\n\n/// Font configuration\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\n#[serde(default)]\npub struct FontConfig {\n    pub family: String,\n    pub size: f32,\n    pub line_height: f32,\n    pub fallback: Vec\u003cString\u003e,\n    pub bold_is_bright: bool,\n    pub use_thin_strokes: bool,\n}\n\nimpl Default for FontConfig {\n    fn default() -\u003e Self {\n        Self {\n            family: \"JetBrains Mono\".to_string(),\n            size: 14.0,\n            line_height: 1.2,\n            fallback: vec![\n                \"Fira Code\".to_string(),\n                \"DejaVu Sans Mono\".to_string(),\n                \"Menlo\".to_string(),\n            ],\n            bold_is_bright: true,\n            use_thin_strokes: false,\n        }\n    }\n}\n\n/// Color configuration\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\n#[serde(default)]\npub struct ColorConfig {\n    /// Theme name (e.g., \"dracula\", \"nord\", \"monokai\")\n    pub theme: Option\u003cString\u003e,\n\n    /// Custom colors (override theme)\n    pub foreground: Option\u003cString\u003e,\n    pub background: Option\u003cString\u003e,\n    pub cursor: Option\u003cString\u003e,\n    pub selection_background: Option\u003cString\u003e,\n    pub selection_foreground: Option\u003cString\u003e,\n\n    /// Color palette (16 colors)\n    pub palette: ColorPalette,\n\n    /// Transparency settings\n    pub opacity: f32,\n    pub dim_opacity: f32,\n}\n\nimpl Default for ColorConfig {\n    fn default() -\u003e Self {\n        Self {\n            theme: Some(\"dracula\".to_string()),\n            foreground: None,\n            background: None,\n            cursor: None,\n            selection_background: None,\n            selection_foreground: None,\n            palette: ColorPalette::default(),\n            opacity: 1.0,\n            dim_opacity: 0.7,\n        }\n    }\n}\n\n/// 16-color ANSI palette\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\n#[serde(default)]\npub struct ColorPalette {\n    // Normal colors\n    pub black: String,\n    pub red: String,\n    pub green: String,\n    pub yellow: String,\n    pub blue: String,\n    pub magenta: String,\n    pub cyan: String,\n    pub white: String,\n\n    // Bright colors\n    pub bright_black: String,\n    pub bright_red: String,\n    pub bright_green: String,\n    pub bright_yellow: String,\n    pub bright_blue: String,\n    pub bright_magenta: String,\n    pub bright_cyan: String,\n    pub bright_white: String,\n}\n\nimpl Default for ColorPalette {\n    fn default() -\u003e Self {\n        // Dracula theme colors\n        Self {\n            black: \"#21222c\".to_string(),\n            red: \"#ff5555\".to_string(),\n            green: \"#50fa7b\".to_string(),\n            yellow: \"#f1fa8c\".to_string(),\n            blue: \"#bd93f9\".to_string(),\n            magenta: \"#ff79c6\".to_string(),\n            cyan: \"#8be9fd\".to_string(),\n            white: \"#f8f8f2\".to_string(),\n            bright_black: \"#6272a4\".to_string(),\n            bright_red: \"#ff6e6e\".to_string(),\n            bright_green: \"#69ff94\".to_string(),\n            bright_yellow: \"#ffffa5\".to_string(),\n            bright_blue: \"#d6acff\".to_string(),\n            bright_magenta: \"#ff92df\".to_string(),\n            bright_cyan: \"#a4ffff\".to_string(),\n            bright_white: \"#ffffff\".to_string(),\n        }\n    }\n}\n\n/// Key bindings configuration\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\n#[serde(default)]\npub struct KeyBindings {\n    pub leader_key: String,\n    pub copy_mode: String,\n    pub paste: String,\n    pub search: String,\n    pub command_palette: String,\n    pub new_window: String,\n    pub close_window: String,\n    pub next_tab: String,\n    pub prev_tab: String,\n\n    /// Custom keybindings (action -\u003e key)\n    pub custom: HashMap\u003cString, String\u003e,\n}\n\nimpl Default for KeyBindings {\n    fn default() -\u003e Self {\n        Self {\n            leader_key: \"Space\".to_string(),\n            copy_mode: \"Ctrl+Shift+C\".to_string(),\n            paste: \"Ctrl+Shift+V\".to_string(),\n            search: \"Ctrl+Shift+F\".to_string(),\n            command_palette: \"Ctrl+Shift+P\".to_string(),\n            new_window: \"Ctrl+Shift+N\".to_string(),\n            close_window: \"Ctrl+Shift+W\".to_string(),\n            next_tab: \"Ctrl+Tab\".to_string(),\n            prev_tab: \"Ctrl+Shift+Tab\".to_string(),\n            custom: HashMap::new(),\n        }\n    }\n}\n\n/// UI behavior configuration\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\n#[serde(default)]\npub struct UiConfig {\n    pub link_hints: bool,\n    pub command_palette: bool,\n    pub animations: bool,\n    pub smooth_scroll: bool,\n    pub show_tabs: bool,\n    pub tab_position: TabPosition,\n    pub cursor_style: CursorStyle,\n    pub cursor_blink: bool,\n    pub cursor_blink_interval: u32,\n}\n\nimpl Default for UiConfig {\n    fn default() -\u003e Self {\n        Self {\n            link_hints: true,\n            command_palette: true,\n            animations: true,\n            smooth_scroll: true,\n            show_tabs: true,\n            tab_position: TabPosition::Top,\n            cursor_style: CursorStyle::Block,\n            cursor_blink: true,\n            cursor_blink_interval: 750,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum TabPosition {\n    Top,\n    Bottom,\n    Left,\n    Right,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Deserialize, Serialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum CursorStyle {\n    Block,\n    Beam,\n    Underline,\n}\n\n/// Plugin configuration\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\n#[serde(default)]\npub struct PluginConfig {\n    pub enabled: Vec\u003cString\u003e,\n    pub config: HashMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl Default for PluginConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: vec![],\n            config: HashMap::new(),\n        }\n    }\n}\n\n/// Session management configuration\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\n#[serde(default)]\npub struct SessionConfig {\n    pub restore_on_startup: bool,\n    pub auto_save_interval: u32,\n    pub save_scrollback: bool,\n    pub working_directory: Option\u003cString\u003e,\n}\n\nimpl Default for SessionConfig {\n    fn default() -\u003e Self {\n        Self {\n            restore_on_startup: false,\n            auto_save_interval: 300, // 5 minutes\n            save_scrollback: true,\n            working_directory: None,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = ScarabConfig::default();\n        assert_eq!(config.font.size, 14.0);\n        assert_eq!(config.terminal.scrollback_lines, 10_000);\n        assert!(config.ui.link_hints);\n    }\n\n    #[test]\n    fn test_config_merge() {\n        let mut base = ScarabConfig::default();\n        let mut override_config = ScarabConfig::default();\n        override_config.font.size = 16.0;\n\n        base.merge(override_config);\n        assert_eq!(base.font.size, 16.0);\n    }\n\n    #[test]\n    fn test_serialize_deserialize() {\n        let config = ScarabConfig::default();\n        let toml = toml::to_string(\u0026config).unwrap();\n        let parsed: ScarabConfig = toml::from_str(\u0026toml).unwrap();\n        assert_eq!(config.font.size, parsed.font.size);\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":45}},{"line":22,"address":[],"length":0,"stats":{"Line":90}},{"line":23,"address":[],"length":0,"stats":{"Line":90}},{"line":24,"address":[],"length":0,"stats":{"Line":90}},{"line":25,"address":[],"length":0,"stats":{"Line":90}},{"line":26,"address":[],"length":0,"stats":{"Line":90}},{"line":27,"address":[],"length":0,"stats":{"Line":45}},{"line":28,"address":[],"length":0,"stats":{"Line":45}},{"line":35,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":3}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":9}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":9}},{"line":61,"address":[],"length":0,"stats":{"Line":9}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":57}},{"line":84,"address":[],"length":0,"stats":{"Line":114}},{"line":106,"address":[],"length":0,"stats":{"Line":57}},{"line":108,"address":[],"length":0,"stats":{"Line":171}},{"line":111,"address":[],"length":0,"stats":{"Line":114}},{"line":145,"address":[],"length":0,"stats":{"Line":57}},{"line":147,"address":[],"length":0,"stats":{"Line":114}},{"line":153,"address":[],"length":0,"stats":{"Line":57}},{"line":186,"address":[],"length":0,"stats":{"Line":66}},{"line":189,"address":[],"length":0,"stats":{"Line":198}},{"line":190,"address":[],"length":0,"stats":{"Line":198}},{"line":191,"address":[],"length":0,"stats":{"Line":198}},{"line":192,"address":[],"length":0,"stats":{"Line":198}},{"line":193,"address":[],"length":0,"stats":{"Line":198}},{"line":194,"address":[],"length":0,"stats":{"Line":198}},{"line":195,"address":[],"length":0,"stats":{"Line":198}},{"line":196,"address":[],"length":0,"stats":{"Line":198}},{"line":197,"address":[],"length":0,"stats":{"Line":198}},{"line":198,"address":[],"length":0,"stats":{"Line":198}},{"line":199,"address":[],"length":0,"stats":{"Line":198}},{"line":200,"address":[],"length":0,"stats":{"Line":198}},{"line":201,"address":[],"length":0,"stats":{"Line":198}},{"line":202,"address":[],"length":0,"stats":{"Line":198}},{"line":203,"address":[],"length":0,"stats":{"Line":198}},{"line":204,"address":[],"length":0,"stats":{"Line":66}},{"line":228,"address":[],"length":0,"stats":{"Line":54}},{"line":230,"address":[],"length":0,"stats":{"Line":162}},{"line":231,"address":[],"length":0,"stats":{"Line":162}},{"line":232,"address":[],"length":0,"stats":{"Line":162}},{"line":233,"address":[],"length":0,"stats":{"Line":162}},{"line":234,"address":[],"length":0,"stats":{"Line":162}},{"line":235,"address":[],"length":0,"stats":{"Line":162}},{"line":236,"address":[],"length":0,"stats":{"Line":162}},{"line":237,"address":[],"length":0,"stats":{"Line":162}},{"line":238,"address":[],"length":0,"stats":{"Line":108}},{"line":239,"address":[],"length":0,"stats":{"Line":54}},{"line":260,"address":[],"length":0,"stats":{"Line":57}},{"line":301,"address":[],"length":0,"stats":{"Line":54}},{"line":303,"address":[],"length":0,"stats":{"Line":54}},{"line":304,"address":[],"length":0,"stats":{"Line":54}},{"line":320,"address":[],"length":0,"stats":{"Line":57}}],"covered":59,"coverable":63},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-config","src","error.rs"],"content":"//! Error types for configuration system\n\nuse std::path::PathBuf;\nuse thiserror::Error;\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, ConfigError\u003e;\n\n#[derive(Debug, Error)]\npub enum ConfigError {\n    #[error(\"I/O error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"TOML parsing error: {0}\")]\n    TomlParse(#[from] toml::de::Error),\n\n    #[error(\"TOML serialization error: {0}\")]\n    TomlSerialize(#[from] toml::ser::Error),\n\n    #[error(\"JSON error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"Invalid font size: {0} (must be between 6.0 and 72.0)\")]\n    InvalidFontSize(f32),\n\n    #[error(\"Invalid scrollback lines: {0} (must be between 100 and 100,000)\")]\n    InvalidScrollback(u32),\n\n    #[error(\"Invalid color format: {0} (expected #RRGGBB)\")]\n    InvalidColor(String),\n\n    #[error(\"Invalid line height: {0} (must be between 0.5 and 3.0)\")]\n    InvalidLineHeight(f32),\n\n    #[error(\"Config file not found at {0}\")]\n    FileNotFound(PathBuf),\n\n    #[error(\"Invalid theme name: {0}\")]\n    InvalidTheme(String),\n\n    #[error(\"Invalid shell command: {0}\")]\n    InvalidShell(String),\n\n    #[error(\"Watch error: {0}\")]\n    Watch(#[from] notify::Error),\n\n    #[error(\"Plugin config error: {0}\")]\n    PluginConfig(String),\n\n    #[error(\"Migration error: {0}\")]\n    Migration(String),\n\n    #[error(\"Validation error: {0}\")]\n    Validation(String),\n}\n\nimpl ConfigError {\n    /// Create a helpful error message with suggestions\n    pub fn help_text(\u0026self) -\u003e String {\n        match self {\n            ConfigError::InvalidFontSize(size) =\u003e {\n                format!(\n                    \"Font size {} is out of range.\\n\\\n                     Valid range: 6.0 to 72.0\\n\\\n                     Suggestion: Try 12.0 or 14.0 for readability\",\n                    size\n                )\n            }\n            ConfigError::InvalidColor(color) =\u003e {\n                format!(\n                    \"Color '{}' is not valid.\\n\\\n                     Expected format: #RRGGBB (e.g., #FF5555)\\n\\\n                     You can use color names in theme presets instead\",\n                    color\n                )\n            }\n            ConfigError::InvalidScrollback(lines) =\u003e {\n                format!(\n                    \"Scrollback {} lines is out of range.\\n\\\n                     Valid range: 100 to 100,000\\n\\\n                     Suggestion: Try 10,000 for good balance\",\n                    lines\n                )\n            }\n            ConfigError::FileNotFound(path) =\u003e {\n                format!(\n                    \"Config file not found: {}\\n\\\n                     Run 'scarab config init' to create a default config\\n\\\n                     Or create it manually at ~/.config/scarab/config.toml\",\n                    path.display()\n                )\n            }\n            _ =\u003e format!(\"{}\", self),\n        }\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":12},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-config","src","lib.rs"],"content":"//! Scarab Configuration System\n//!\n//! Provides TOML-based configuration with:\n//! - Global config (~/.config/scarab/config.toml)\n//! - Per-directory overrides (.scarab.toml)\n//! - Hot-reload support (\u003c100ms)\n//! - Validation with helpful errors\n//! - Sensible defaults (zero-config startup)\n\npub mod config;\npub mod error;\npub mod loader;\npub mod validation;\npub mod watcher;\n\npub use config::*;\npub use error::{ConfigError, Result};\npub use loader::ConfigLoader;\npub use validation::ConfigValidator;\npub use watcher::ConfigWatcher;\n\n/// Prelude for convenient imports\npub mod prelude {\n    pub use crate::{\n        config::*,\n        error::{ConfigError, Result},\n        loader::ConfigLoader,\n        validation::ConfigValidator,\n        watcher::ConfigWatcher,\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-config","src","loader.rs"],"content":"//! Configuration file loading and discovery\n\nuse crate::{error::Result, ConfigError, ScarabConfig};\nuse std::{\n    env,\n    fs,\n    path::{Path, PathBuf},\n};\nuse tracing::{debug, info};\n\n/// Configuration loader with discovery\npub struct ConfigLoader {\n    global_path: PathBuf,\n}\n\nimpl ConfigLoader {\n    /// Create a new loader with default paths\n    pub fn new() -\u003e Self {\n        Self {\n            global_path: Self::default_config_path(),\n        }\n    }\n\n    /// Create a loader with custom global path (for testing)\n    pub fn with_path(path: PathBuf) -\u003e Self {\n        Self {\n            global_path: path,\n        }\n    }\n\n    /// Get default global config path (~/.config/scarab/config.toml)\n    pub fn default_config_path() -\u003e PathBuf {\n        dirs::config_dir()\n            .unwrap_or_else(|| PathBuf::from(\".\"))\n            .join(\"scarab\")\n            .join(\"config.toml\")\n    }\n\n    /// Load configuration with global + local merging\n    pub fn load(\u0026self) -\u003e Result\u003cScarabConfig\u003e {\n        let mut config = self.load_global()?;\n\n        if let Some(local) = self.load_local()? {\n            debug!(\"Found local config, merging with global\");\n            config.merge(local);\n        }\n\n        Ok(config)\n    }\n\n    /// Load global configuration\n    fn load_global(\u0026self) -\u003e Result\u003cScarabConfig\u003e {\n        if self.global_path.exists() {\n            info!(\"Loading global config from: {}\", self.global_path.display());\n            Self::from_file(\u0026self.global_path)\n        } else {\n            debug!(\"No global config found, using defaults\");\n            Ok(ScarabConfig::default())\n        }\n    }\n\n    /// Load local configuration by walking up from cwd\n    fn load_local(\u0026self) -\u003e Result\u003cOption\u003cScarabConfig\u003e\u003e {\n        let mut current = env::current_dir()?;\n\n        loop {\n            let config_path = current.join(\".scarab.toml\");\n\n            if config_path.exists() {\n                info!(\"Found local config at: {}\", config_path.display());\n                return Ok(Some(Self::from_file(\u0026config_path)?));\n            }\n\n            // Try to go up one directory\n            if !current.pop() {\n                break;\n            }\n        }\n\n        debug!(\"No local config found in directory tree\");\n        Ok(None)\n    }\n\n    /// Load config from a specific file\n    pub fn from_file(path: \u0026Path) -\u003e Result\u003cScarabConfig\u003e {\n        let content = fs::read_to_string(path).map_err(|_| {\n            ConfigError::FileNotFound(path.to_path_buf())\n        })?;\n\n        let config: ScarabConfig = toml::from_str(\u0026content)?;\n        debug!(\"Loaded config from: {}\", path.display());\n        Ok(config)\n    }\n\n    /// Save config to global config file\n    pub fn save_global(\u0026self, config: \u0026ScarabConfig) -\u003e Result\u003c()\u003e {\n        self.save_to(\u0026self.global_path, config)\n    }\n\n    /// Save config to a specific file\n    pub fn save_to(\u0026self, path: \u0026Path, config: \u0026ScarabConfig) -\u003e Result\u003c()\u003e {\n        // Ensure parent directory exists\n        if let Some(parent) = path.parent() {\n            fs::create_dir_all(parent)?;\n        }\n\n        let toml = toml::to_string_pretty(config)?;\n        fs::write(path, toml)?;\n        info!(\"Saved config to: {}\", path.display());\n        Ok(())\n    }\n\n    /// Create default config file if it doesn't exist\n    pub fn ensure_default_config(\u0026self) -\u003e Result\u003cPathBuf\u003e {\n        if self.global_path.exists() {\n            debug!(\"Global config already exists\");\n            return Ok(self.global_path.clone());\n        }\n\n        info!(\"Creating default config at: {}\", self.global_path.display());\n\n        // Ensure directory exists\n        if let Some(parent) = self.global_path.parent() {\n            fs::create_dir_all(parent)?;\n        }\n\n        let default_config = ScarabConfig::default();\n        self.save_global(\u0026default_config)?;\n\n        Ok(self.global_path.clone())\n    }\n\n    /// Get all config locations (for debugging)\n    pub fn config_locations(\u0026self) -\u003e Vec\u003c(String, PathBuf, bool)\u003e {\n        let mut locations = vec![\n            (\n                \"Global\".to_string(),\n                self.global_path.clone(),\n                self.global_path.exists(),\n            ),\n        ];\n\n        // Walk up from cwd\n        if let Ok(mut current) = env::current_dir() {\n            loop {\n                let local_path = current.join(\".scarab.toml\");\n                if local_path.exists() {\n                    locations.push((\n                        format!(\"Local ({})\", current.display()),\n                        local_path,\n                        true,\n                    ));\n                }\n\n                if !current.pop() {\n                    break;\n                }\n            }\n        }\n\n        locations\n    }\n}\n\nimpl Default for ConfigLoader {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_default_config_path() {\n        let path = ConfigLoader::default_config_path();\n        assert!(path.to_string_lossy().contains(\"scarab\"));\n        assert!(path.to_string_lossy().ends_with(\"config.toml\"));\n    }\n\n    #[test]\n    fn test_load_default_config() {\n        let loader = ConfigLoader::new();\n        // Should not fail even if file doesn't exist\n        let config = loader.load_global().unwrap();\n        assert_eq!(config.font.size, 14.0);\n    }\n\n    #[test]\n    fn test_save_and_load() {\n        let temp_dir = TempDir::new().unwrap();\n        let config_path = temp_dir.path().join(\"config.toml\");\n\n        let mut loader = ConfigLoader::new();\n        loader.global_path = config_path.clone();\n\n        let mut config = ScarabConfig::default();\n        config.font.size = 18.0;\n\n        loader.save_global(\u0026config).unwrap();\n        assert!(config_path.exists());\n\n        let loaded = ConfigLoader::from_file(\u0026config_path).unwrap();\n        assert_eq!(loaded.font.size, 18.0);\n    }\n\n    #[test]\n    fn test_ensure_default_config() {\n        let temp_dir = TempDir::new().unwrap();\n        let config_path = temp_dir.path().join(\"scarab/config.toml\");\n\n        let mut loader = ConfigLoader::new();\n        loader.global_path = config_path.clone();\n\n        let path = loader.ensure_default_config().unwrap();\n        assert!(path.exists());\n        assert_eq!(path, config_path);\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":10}},{"line":20,"address":[],"length":0,"stats":{"Line":10}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":17}},{"line":33,"address":[],"length":0,"stats":{"Line":17}},{"line":34,"address":[],"length":0,"stats":{"Line":17}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":16}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":8}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":5}},{"line":86,"address":[],"length":0,"stats":{"Line":20}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":20}},{"line":91,"address":[],"length":0,"stats":{"Line":5}},{"line":92,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":16}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":8}},{"line":104,"address":[],"length":0,"stats":{"Line":8}},{"line":107,"address":[],"length":0,"stats":{"Line":12}},{"line":108,"address":[],"length":0,"stats":{"Line":12}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}}],"covered":44,"coverable":70},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-config","src","validation.rs"],"content":"//! Configuration validation\n\nuse crate::{\n    ColorPalette, ConfigError, Result, ScarabConfig,\n};\nuse tracing::warn;\n\n/// Configuration validator\npub struct ConfigValidator;\n\nimpl ConfigValidator {\n    /// Validate entire configuration\n    pub fn validate(config: \u0026ScarabConfig) -\u003e Result\u003c()\u003e {\n        Self::validate_font(\u0026config.font)?;\n        Self::validate_terminal(\u0026config.terminal)?;\n        Self::validate_colors(\u0026config.colors)?;\n        Self::validate_ui(\u0026config.ui)?;\n        Ok(())\n    }\n\n    /// Validate font configuration\n    fn validate_font(font: \u0026crate::FontConfig) -\u003e Result\u003c()\u003e {\n        if font.size \u003c 6.0 || font.size \u003e 72.0 {\n            return Err(ConfigError::InvalidFontSize(font.size));\n        }\n\n        if font.line_height \u003c 0.5 || font.line_height \u003e 3.0 {\n            return Err(ConfigError::InvalidLineHeight(font.line_height));\n        }\n\n        if font.family.is_empty() {\n            return Err(ConfigError::Validation(\n                \"Font family cannot be empty\".to_string(),\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Validate terminal configuration\n    fn validate_terminal(terminal: \u0026crate::TerminalConfig) -\u003e Result\u003c()\u003e {\n        if terminal.scrollback_lines \u003c 100 || terminal.scrollback_lines \u003e 100_000 {\n            return Err(ConfigError::InvalidScrollback(terminal.scrollback_lines));\n        }\n\n        if terminal.default_shell.is_empty() {\n            return Err(ConfigError::InvalidShell(\n                \"Shell command cannot be empty\".to_string(),\n            ));\n        }\n\n        if terminal.scroll_multiplier \u003c 0.1 || terminal.scroll_multiplier \u003e 10.0 {\n            warn!(\n                \"Scroll multiplier {} is unusual (recommended: 1.0-5.0)\",\n                terminal.scroll_multiplier\n            );\n        }\n\n        Ok(())\n    }\n\n    /// Validate color configuration\n    fn validate_colors(colors: \u0026crate::ColorConfig) -\u003e Result\u003c()\u003e {\n        // Validate custom colors if set\n        if let Some(ref fg) = colors.foreground {\n            Self::validate_color(fg)?;\n        }\n        if let Some(ref bg) = colors.background {\n            Self::validate_color(bg)?;\n        }\n        if let Some(ref cursor) = colors.cursor {\n            Self::validate_color(cursor)?;\n        }\n        if let Some(ref sel_bg) = colors.selection_background {\n            Self::validate_color(sel_bg)?;\n        }\n        if let Some(ref sel_fg) = colors.selection_foreground {\n            Self::validate_color(sel_fg)?;\n        }\n\n        // Validate palette\n        Self::validate_palette(\u0026colors.palette)?;\n\n        // Validate opacity\n        if colors.opacity \u003c 0.0 || colors.opacity \u003e 1.0 {\n            return Err(ConfigError::Validation(format!(\n                \"Opacity {} must be between 0.0 and 1.0\",\n                colors.opacity\n            )));\n        }\n\n        if colors.dim_opacity \u003c 0.0 || colors.dim_opacity \u003e 1.0 {\n            return Err(ConfigError::Validation(format!(\n                \"Dim opacity {} must be between 0.0 and 1.0\",\n                colors.dim_opacity\n            )));\n        }\n\n        Ok(())\n    }\n\n    /// Validate UI configuration\n    fn validate_ui(ui: \u0026crate::UiConfig) -\u003e Result\u003c()\u003e {\n        if ui.cursor_blink_interval \u003c 100 || ui.cursor_blink_interval \u003e 5000 {\n            warn!(\n                \"Cursor blink interval {}ms is unusual (recommended: 500-1000ms)\",\n                ui.cursor_blink_interval\n            );\n        }\n\n        Ok(())\n    }\n\n    /// Validate a single color (hex format)\n    fn validate_color(color: \u0026str) -\u003e Result\u003c()\u003e {\n        if !color.starts_with('#') {\n            return Err(ConfigError::InvalidColor(format!(\n                \"{} (missing # prefix)\",\n                color\n            )));\n        }\n\n        if color.len() != 7 \u0026\u0026 color.len() != 9 {\n            return Err(ConfigError::InvalidColor(format!(\n                \"{} (must be #RRGGBB or #RRGGBBAA)\",\n                color\n            )));\n        }\n\n        // Validate hex digits\n        for ch in color[1..].chars() {\n            if !ch.is_ascii_hexdigit() {\n                return Err(ConfigError::InvalidColor(format!(\n                    \"{} (invalid hex digit: {})\",\n                    color, ch\n                )));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Validate color palette\n    fn validate_palette(palette: \u0026ColorPalette) -\u003e Result\u003c()\u003e {\n        let colors = [\n            (\"black\", \u0026palette.black),\n            (\"red\", \u0026palette.red),\n            (\"green\", \u0026palette.green),\n            (\"yellow\", \u0026palette.yellow),\n            (\"blue\", \u0026palette.blue),\n            (\"magenta\", \u0026palette.magenta),\n            (\"cyan\", \u0026palette.cyan),\n            (\"white\", \u0026palette.white),\n            (\"bright_black\", \u0026palette.bright_black),\n            (\"bright_red\", \u0026palette.bright_red),\n            (\"bright_green\", \u0026palette.bright_green),\n            (\"bright_yellow\", \u0026palette.bright_yellow),\n            (\"bright_blue\", \u0026palette.bright_blue),\n            (\"bright_magenta\", \u0026palette.bright_magenta),\n            (\"bright_cyan\", \u0026palette.bright_cyan),\n            (\"bright_white\", \u0026palette.bright_white),\n        ];\n\n        for (name, color) in colors {\n            Self::validate_color(color).map_err(|e| {\n                ConfigError::InvalidColor(format!(\"palette.{}: {}\", name, e))\n            })?;\n        }\n\n        Ok(())\n    }\n\n    /// Auto-fix common issues (returns fixed config)\n    pub fn auto_fix(mut config: ScarabConfig) -\u003e ScarabConfig {\n        // Clamp font size\n        if config.font.size \u003c 6.0 {\n            warn!(\"Font size too small, setting to 6.0\");\n            config.font.size = 6.0;\n        } else if config.font.size \u003e 72.0 {\n            warn!(\"Font size too large, setting to 72.0\");\n            config.font.size = 72.0;\n        }\n\n        // Clamp line height\n        if config.font.line_height \u003c 0.5 {\n            warn!(\"Line height too small, setting to 0.5\");\n            config.font.line_height = 0.5;\n        } else if config.font.line_height \u003e 3.0 {\n            warn!(\"Line height too large, setting to 3.0\");\n            config.font.line_height = 3.0;\n        }\n\n        // Clamp scrollback\n        if config.terminal.scrollback_lines \u003c 100 {\n            warn!(\"Scrollback too small, setting to 100\");\n            config.terminal.scrollback_lines = 100;\n        } else if config.terminal.scrollback_lines \u003e 100_000 {\n            warn!(\"Scrollback too large, setting to 100,000\");\n            config.terminal.scrollback_lines = 100_000;\n        }\n\n        // Clamp opacity\n        config.colors.opacity = config.colors.opacity.clamp(0.0, 1.0);\n        config.colors.dim_opacity = config.colors.dim_opacity.clamp(0.0, 1.0);\n\n        config\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_default_config() {\n        let config = ScarabConfig::default();\n        assert!(ConfigValidator::validate(\u0026config).is_ok());\n    }\n\n    #[test]\n    fn test_invalid_font_size() {\n        let mut config = ScarabConfig::default();\n        config.font.size = 100.0;\n        assert!(ConfigValidator::validate(\u0026config).is_err());\n    }\n\n    #[test]\n    fn test_invalid_color() {\n        let result = ConfigValidator::validate_color(\"FF5555\");\n        assert!(result.is_err());\n\n        let result = ConfigValidator::validate_color(\"#GG5555\");\n        assert!(result.is_err());\n\n        let result = ConfigValidator::validate_color(\"#FF5555\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_auto_fix() {\n        let mut config = ScarabConfig::default();\n        config.font.size = 100.0;\n        config.terminal.scrollback_lines = 200_000;\n\n        let fixed = ConfigValidator::auto_fix(config);\n        assert_eq!(fixed.font.size, 72.0);\n        assert_eq!(fixed.terminal.scrollback_lines, 100_000);\n    }\n\n    #[test]\n    fn test_validate_opacity() {\n        let mut config = ScarabConfig::default();\n        config.colors.opacity = 1.5;\n        assert!(ConfigValidator::validate(\u0026config).is_err());\n\n        config.colors.opacity = 0.8;\n        assert!(ConfigValidator::validate(\u0026config).is_ok());\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":23}},{"line":14,"address":[],"length":0,"stats":{"Line":51}},{"line":15,"address":[],"length":0,"stats":{"Line":38}},{"line":16,"address":[],"length":0,"stats":{"Line":38}},{"line":17,"address":[],"length":0,"stats":{"Line":20}},{"line":18,"address":[],"length":0,"stats":{"Line":10}},{"line":22,"address":[],"length":0,"stats":{"Line":23}},{"line":23,"address":[],"length":0,"stats":{"Line":45}},{"line":24,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":39}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":36}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":18}},{"line":41,"address":[],"length":0,"stats":{"Line":18}},{"line":42,"address":[],"length":0,"stats":{"Line":35}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":32}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":32}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":16}},{"line":63,"address":[],"length":0,"stats":{"Line":16}},{"line":65,"address":[],"length":0,"stats":{"Line":20}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":68,"address":[],"length":0,"stats":{"Line":13}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":13}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":13}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":13}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":26}},{"line":85,"address":[],"length":0,"stats":{"Line":25}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":20}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":10}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":104,"address":[],"length":0,"stats":{"Line":20}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":10}},{"line":115,"address":[],"length":0,"stats":{"Line":215}},{"line":116,"address":[],"length":0,"stats":{"Line":215}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":214}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":1686}},{"line":132,"address":[],"length":0,"stats":{"Line":1262}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":210}},{"line":144,"address":[],"length":0,"stats":{"Line":13}},{"line":145,"address":[],"length":0,"stats":{"Line":26}},{"line":146,"address":[],"length":0,"stats":{"Line":26}},{"line":147,"address":[],"length":0,"stats":{"Line":26}},{"line":148,"address":[],"length":0,"stats":{"Line":26}},{"line":149,"address":[],"length":0,"stats":{"Line":26}},{"line":150,"address":[],"length":0,"stats":{"Line":26}},{"line":151,"address":[],"length":0,"stats":{"Line":26}},{"line":152,"address":[],"length":0,"stats":{"Line":26}},{"line":153,"address":[],"length":0,"stats":{"Line":26}},{"line":154,"address":[],"length":0,"stats":{"Line":26}},{"line":155,"address":[],"length":0,"stats":{"Line":26}},{"line":156,"address":[],"length":0,"stats":{"Line":26}},{"line":157,"address":[],"length":0,"stats":{"Line":26}},{"line":158,"address":[],"length":0,"stats":{"Line":26}},{"line":159,"address":[],"length":0,"stats":{"Line":26}},{"line":160,"address":[],"length":0,"stats":{"Line":26}},{"line":161,"address":[],"length":0,"stats":{"Line":13}},{"line":164,"address":[],"length":0,"stats":{"Line":637}},{"line":165,"address":[],"length":0,"stats":{"Line":624}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":13}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":2}}],"covered":86,"coverable":110},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-config","src","watcher.rs"],"content":"//! Configuration hot-reload watcher\n\nuse crate::{ConfigLoader, Result, ScarabConfig};\nuse notify::{Event, EventKind, RecommendedWatcher, RecursiveMode, Watcher};\nuse std::{\n    path::PathBuf,\n    sync::{\n        atomic::{AtomicBool, Ordering},\n        Arc, RwLock,\n    },\n    time::Instant,\n};\nuse tracing::{debug, error, info};\n\n/// Callback function for config changes\npub type ConfigChangeCallback = Box\u003cdyn Fn(\u0026ScarabConfig) + Send + Sync\u003e;\n\n/// Configuration file watcher with hot-reload\npub struct ConfigWatcher {\n    config: Arc\u003cRwLock\u003cScarabConfig\u003e\u003e,\n    loader: ConfigLoader,\n    _watcher: Option\u003cRecommendedWatcher\u003e,\n    watch_paths: Vec\u003cPathBuf\u003e,\n    callbacks: Arc\u003cRwLock\u003cVec\u003cConfigChangeCallback\u003e\u003e\u003e,\n    running: Arc\u003cAtomicBool\u003e,\n}\n\nimpl ConfigWatcher {\n    /// Create a new watcher with initial config\n    pub fn new(initial_config: ScarabConfig) -\u003e Result\u003cSelf\u003e {\n        let config = Arc::new(RwLock::new(initial_config));\n        let loader = ConfigLoader::new();\n        let watch_paths = Self::get_watch_paths(\u0026loader);\n\n        Ok(Self {\n            config,\n            loader,\n            _watcher: None,\n            watch_paths,\n            callbacks: Arc::new(RwLock::new(Vec::new())),\n            running: Arc::new(AtomicBool::new(false)),\n        })\n    }\n\n    /// Start watching for config file changes\n    pub fn start(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if self.running.load(Ordering::SeqCst) {\n            debug!(\"Config watcher already running\");\n            return Ok(());\n        }\n\n        let config = Arc::clone(\u0026self.config);\n        let callbacks = Arc::clone(\u0026self.callbacks);\n        let _running = Arc::clone(\u0026self.running);\n        let watch_paths = self.watch_paths.clone();\n\n        let mut watcher = notify::recommended_watcher(\n            move |res: std::result::Result\u003cEvent, notify::Error\u003e| {\n                match res {\n                    Ok(event) =\u003e {\n                        if matches!(\n                            event.kind,\n                            EventKind::Create(_) | EventKind::Modify(_)\n                        ) {\n                            // Check if the event is for a config file\n                            if event.paths.iter().any(|p| {\n                                watch_paths.iter().any(|wp| p.ends_with(wp))\n                            }) {\n                                let start = Instant::now();\n                                debug!(\"Config file changed, reloading...\");\n\n                                // Reload config\n                                if let Ok(new_config) = ConfigLoader::new().load() {\n                                    *config.write().unwrap() = new_config.clone();\n                                    let reload_time = start.elapsed();\n                                    info!(\n                                        \"Config reloaded in {}ms\",\n                                        reload_time.as_millis()\n                                    );\n\n                                    // Call callbacks\n                                    let cbs = callbacks.read().unwrap();\n                                    for callback in cbs.iter() {\n                                        callback(\u0026new_config);\n                                    }\n                                } else {\n                                    error!(\"Failed to reload config\");\n                                }\n                            }\n                        }\n                    }\n                    Err(e) =\u003e error!(\"Watch error: {:?}\", e),\n                }\n            },\n        )?;\n\n        // Watch config directories\n        for path in \u0026self.watch_paths {\n            if let Some(parent) = path.parent() {\n                if parent.exists() {\n                    watcher.watch(parent, RecursiveMode::NonRecursive)?;\n                    info!(\"Watching config directory: {}\", parent.display());\n                }\n            }\n        }\n\n        self.running.store(true, Ordering::SeqCst);\n        self._watcher = Some(watcher);\n\n        info!(\"Config watcher started\");\n        Ok(())\n    }\n\n    /// Stop watching for changes\n    pub fn stop(\u0026mut self) {\n        self.running.store(false, Ordering::SeqCst);\n        self._watcher = None;\n        info!(\"Config watcher stopped\");\n    }\n\n    /// Register a callback for config changes\n    pub fn on_change(\u0026self, callback: ConfigChangeCallback) {\n        self.callbacks.write().unwrap().push(callback);\n    }\n\n    /// Get current configuration\n    pub fn get_config(\u0026self) -\u003e ScarabConfig {\n        self.config.read().unwrap().clone()\n    }\n\n    /// Manually reload configuration\n    pub fn reload(\u0026self) -\u003e Result\u003c()\u003e {\n        let start = Instant::now();\n        let new_config = self.loader.load()?;\n        *self.config.write().unwrap() = new_config.clone();\n\n        let reload_time = start.elapsed();\n        info!(\"Config manually reloaded in {}ms\", reload_time.as_millis());\n\n        // Call callbacks\n        let callbacks = self.callbacks.read().unwrap();\n        for callback in callbacks.iter() {\n            callback(\u0026new_config);\n        }\n\n        Ok(())\n    }\n\n    /// Get paths to watch\n    fn get_watch_paths(_loader: \u0026ConfigLoader) -\u003e Vec\u003cPathBuf\u003e {\n        let mut paths = vec![ConfigLoader::default_config_path()];\n\n        // Add local config if it exists\n        if let Ok(Some(local_path)) = Self::find_local_config() {\n            paths.push(local_path);\n        }\n\n        paths\n    }\n\n    /// Find local config file in directory tree\n    fn find_local_config() -\u003e Result\u003cOption\u003cPathBuf\u003e\u003e {\n        let mut current = std::env::current_dir()?;\n\n        loop {\n            let config_path = current.join(\".scarab.toml\");\n            if config_path.exists() {\n                return Ok(Some(config_path));\n            }\n\n            if !current.pop() {\n                break;\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Get reload statistics (for testing/debugging)\n    pub fn is_running(\u0026self) -\u003e bool {\n        self.running.load(Ordering::SeqCst)\n    }\n}\n\nimpl Drop for ConfigWatcher {\n    fn drop(\u0026mut self) {\n        self.stop();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::atomic::AtomicUsize;\n\n    #[test]\n    fn test_create_watcher() {\n        let config = ScarabConfig::default();\n        let watcher = ConfigWatcher::new(config);\n        assert!(watcher.is_ok());\n    }\n\n    #[test]\n    fn test_get_config() {\n        let mut config = ScarabConfig::default();\n        config.font.size = 18.0;\n\n        let watcher = ConfigWatcher::new(config).unwrap();\n        let retrieved = watcher.get_config();\n        assert_eq!(retrieved.font.size, 18.0);\n    }\n\n    #[test]\n    fn test_callback_registration() {\n        let config = ScarabConfig::default();\n        let watcher = ConfigWatcher::new(config).unwrap();\n\n        let counter = Arc::new(AtomicUsize::new(0));\n        let counter_clone = Arc::clone(\u0026counter);\n\n        watcher.on_change(Box::new(move |_| {\n            counter_clone.fetch_add(1, Ordering::SeqCst);\n        }));\n\n        // Manually trigger reload\n        let new_config = ScarabConfig::default();\n        *watcher.config.write().unwrap() = new_config.clone();\n\n        let callbacks = watcher.callbacks.read().unwrap();\n        for callback in callbacks.iter() {\n            callback(\u0026new_config);\n        }\n\n        assert_eq!(counter.load(Ordering::SeqCst), 1);\n    }\n\n    #[test]\n    fn test_start_stop() {\n        let config = ScarabConfig::default();\n        let mut watcher = ConfigWatcher::new(config).unwrap();\n\n        assert!(!watcher.is_running());\n\n        // Start watching\n        let result = watcher.start();\n        // May fail if config dir doesn't exist, that's okay for this test\n        if result.is_ok() {\n            assert!(watcher.is_running());\n\n            watcher.stop();\n            assert!(!watcher.is_running());\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":6}},{"line":31,"address":[],"length":0,"stats":{"Line":24}},{"line":32,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":18}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":37,"address":[],"length":0,"stats":{"Line":12}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":24}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":7}},{"line":116,"address":[],"length":0,"stats":{"Line":14}},{"line":117,"address":[],"length":0,"stats":{"Line":14}},{"line":118,"address":[],"length":0,"stats":{"Line":7}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":6}},{"line":151,"address":[],"length":0,"stats":{"Line":18}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":6}},{"line":163,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":96}},{"line":167,"address":[],"length":0,"stats":{"Line":48}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":48}},{"line":172,"address":[],"length":0,"stats":{"Line":6}},{"line":176,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":6}},{"line":186,"address":[],"length":0,"stats":{"Line":6}},{"line":187,"address":[],"length":0,"stats":{"Line":12}}],"covered":47,"coverable":83},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-config","tests","integration_tests.rs"],"content":"//! Integration tests for scarab-config\n\nuse scarab_config::prelude::*;\nuse std::fs;\nuse tempfile::TempDir;\n\n#[test]\nfn test_default_config_is_valid() {\n    let config = ScarabConfig::default();\n    assert!(ConfigValidator::validate(\u0026config).is_ok());\n}\n\n#[test]\nfn test_load_nonexistent_config_returns_default() {\n    let loader = ConfigLoader::new();\n    let config = loader.load().unwrap();\n\n    // Should not fail, should return defaults\n    assert_eq!(config.font.size, 14.0);\n    assert_eq!(config.terminal.scrollback_lines, 10_000);\n}\n\n#[test]\nfn test_save_and_load_config() {\n    let temp_dir = TempDir::new().unwrap();\n    let config_path = temp_dir.path().join(\"config.toml\");\n\n    let loader = ConfigLoader::with_path(config_path.clone());\n\n    let mut config = ScarabConfig::default();\n    config.font.size = 16.0;\n    config.terminal.scrollback_lines = 20_000;\n    config.colors.opacity = 0.9;\n\n    // Save\n    loader.save_global(\u0026config).unwrap();\n    assert!(config_path.exists());\n\n    // Load\n    let loaded = ConfigLoader::from_file(\u0026config_path).unwrap();\n    assert_eq!(loaded.font.size, 16.0);\n    assert_eq!(loaded.terminal.scrollback_lines, 20_000);\n    assert_eq!(loaded.colors.opacity, 0.9);\n}\n\n#[test]\nfn test_config_merge() {\n    let mut base = ScarabConfig::default();\n    base.font.size = 14.0;\n    base.terminal.scrollback_lines = 10_000;\n\n    let mut override_config = ScarabConfig::default();\n    override_config.font.size = 18.0;\n    // Don't change scrollback\n\n    base.merge(override_config);\n\n    assert_eq!(base.font.size, 18.0);\n    assert_eq!(base.terminal.scrollback_lines, 10_000);\n}\n\n#[test]\nfn test_validate_font_size() {\n    let mut config = ScarabConfig::default();\n\n    // Valid\n    config.font.size = 12.0;\n    assert!(ConfigValidator::validate(\u0026config).is_ok());\n\n    // Too small\n    config.font.size = 4.0;\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n\n    // Too large\n    config.font.size = 100.0;\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n}\n\n#[test]\nfn test_validate_scrollback() {\n    let mut config = ScarabConfig::default();\n\n    // Valid\n    config.terminal.scrollback_lines = 10_000;\n    assert!(ConfigValidator::validate(\u0026config).is_ok());\n\n    // Too small\n    config.terminal.scrollback_lines = 50;\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n\n    // Too large\n    config.terminal.scrollback_lines = 200_000;\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n}\n\n#[test]\nfn test_validate_colors() {\n    let mut config = ScarabConfig::default();\n\n    // Valid color\n    config.colors.foreground = Some(\"#ff5555\".to_string());\n    assert!(ConfigValidator::validate(\u0026config).is_ok());\n\n    // Invalid color (no #)\n    config.colors.foreground = Some(\"ff5555\".to_string());\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n\n    // Invalid color (wrong length)\n    config.colors.foreground = Some(\"#ff55\".to_string());\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n\n    // Invalid color (non-hex)\n    config.colors.foreground = Some(\"#gggggg\".to_string());\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n}\n\n#[test]\nfn test_auto_fix() {\n    let mut config = ScarabConfig::default();\n    config.font.size = 100.0;\n    config.terminal.scrollback_lines = 200_000;\n    config.colors.opacity = 1.5;\n\n    let fixed = ConfigValidator::auto_fix(config);\n\n    assert_eq!(fixed.font.size, 72.0);\n    assert_eq!(fixed.terminal.scrollback_lines, 100_000);\n    assert_eq!(fixed.colors.opacity, 1.0);\n}\n\n#[test]\nfn test_toml_serialization() {\n    let config = ScarabConfig::default();\n\n    // Serialize to TOML\n    let toml = toml::to_string_pretty(\u0026config).unwrap();\n    assert!(toml.contains(\"[terminal]\"));\n    assert!(toml.contains(\"[font]\"));\n    assert!(toml.contains(\"[colors]\"));\n\n    // Deserialize back\n    let parsed: ScarabConfig = toml::from_str(\u0026toml).unwrap();\n    assert_eq!(parsed.font.size, config.font.size);\n    assert_eq!(parsed.terminal.scrollback_lines, config.terminal.scrollback_lines);\n}\n\n#[test]\nfn test_local_config_override() {\n    let temp_dir = TempDir::new().unwrap();\n\n    // Create global config\n    let global_path = temp_dir.path().join(\"global.toml\");\n    let mut global_config = ScarabConfig::default();\n    global_config.font.size = 14.0;\n\n    let toml = toml::to_string_pretty(\u0026global_config).unwrap();\n    fs::write(\u0026global_path, toml).unwrap();\n\n    // Create local config with override\n    let local_path = temp_dir.path().join(\"local.toml\");\n    let mut local_config = ScarabConfig::default();\n    local_config.font.size = 18.0;\n\n    let toml = toml::to_string_pretty(\u0026local_config).unwrap();\n    fs::write(\u0026local_path, toml).unwrap();\n\n    // Load and merge\n    let global = ConfigLoader::from_file(\u0026global_path).unwrap();\n    let local = ConfigLoader::from_file(\u0026local_path).unwrap();\n\n    let mut merged = global;\n    merged.merge(local);\n\n    assert_eq!(merged.font.size, 18.0);\n}\n\n#[test]\nfn test_color_palette_validation() {\n    let config = ScarabConfig::default();\n    assert!(ConfigValidator::validate(\u0026config).is_ok());\n\n    // All default palette colors should be valid\n    let palette = \u0026config.colors.palette;\n    assert!(palette.black.starts_with('#'));\n    assert!(palette.red.starts_with('#'));\n    assert!(palette.green.starts_with('#'));\n}\n\n#[test]\nfn test_keybindings_custom() {\n    let mut config = ScarabConfig::default();\n    config.keybindings.custom.insert(\n        \"my_action\".to_string(),\n        \"Ctrl+Alt+X\".to_string(),\n    );\n\n    let toml = toml::to_string_pretty(\u0026config).unwrap();\n    let parsed: ScarabConfig = toml::from_str(\u0026toml).unwrap();\n\n    assert_eq!(\n        parsed.keybindings.custom.get(\"my_action\").unwrap(),\n        \"Ctrl+Alt+X\"\n    );\n}\n\n#[test]\nfn test_plugin_config() {\n    let mut config = ScarabConfig::default();\n    config.plugins.enabled.push(\"auto-notify\".to_string());\n\n    let plugin_cfg = serde_json::json!({\n        \"keywords\": [\"ERROR\", \"FAIL\"],\n        \"min_runtime\": 30\n    });\n\n    config.plugins.config.insert(\"auto-notify\".to_string(), plugin_cfg);\n\n    let toml = toml::to_string_pretty(\u0026config).unwrap();\n    let parsed: ScarabConfig = toml::from_str(\u0026toml).unwrap();\n\n    assert!(parsed.plugins.enabled.contains(\u0026\"auto-notify\".to_string()));\n    assert!(parsed.plugins.config.contains_key(\"auto-notify\"));\n}\n\n#[test]\nfn test_config_watcher_creation() {\n    let config = ScarabConfig::default();\n    let watcher = ConfigWatcher::new(config);\n    assert!(watcher.is_ok());\n}\n\n#[test]\nfn test_config_watcher_get_config() {\n    let mut config = ScarabConfig::default();\n    config.font.size = 18.0;\n\n    let watcher = ConfigWatcher::new(config).unwrap();\n    let retrieved = watcher.get_config();\n\n    assert_eq!(retrieved.font.size, 18.0);\n}\n\n#[test]\nfn test_ensure_default_config() {\n    let temp_dir = TempDir::new().unwrap();\n    let config_path = temp_dir.path().join(\"scarab/config.toml\");\n\n    let loader = ConfigLoader::with_path(config_path.clone());\n\n    // Should create the file\n    let path = loader.ensure_default_config().unwrap();\n    assert!(path.exists());\n\n    // Should be valid config\n    let loaded = ConfigLoader::from_file(\u0026path).unwrap();\n    assert!(ConfigValidator::validate(\u0026loaded).is_ok());\n}\n\n#[test]\nfn test_error_help_text() {\n    let err = ConfigError::InvalidFontSize(100.0);\n    let help = err.help_text();\n    assert!(help.contains(\"6.0 to 72.0\"));\n    assert!(help.contains(\"Suggestion\"));\n\n    let err = ConfigError::InvalidColor(\"GGGGGG\".to_string());\n    let help = err.help_text();\n    assert!(help.contains(\"#RRGGBB\"));\n}\n\n#[test]\nfn test_opacity_validation() {\n    let mut config = ScarabConfig::default();\n\n    config.colors.opacity = 0.5;\n    assert!(ConfigValidator::validate(\u0026config).is_ok());\n\n    config.colors.opacity = -0.1;\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n\n    config.colors.opacity = 1.5;\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n}\n\n#[test]\nfn test_line_height_validation() {\n    let mut config = ScarabConfig::default();\n\n    config.font.line_height = 1.2;\n    assert!(ConfigValidator::validate(\u0026config).is_ok());\n\n    config.font.line_height = 0.3;\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n\n    config.font.line_height = 5.0;\n    assert!(ConfigValidator::validate(\u0026config).is_err());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","ipc.rs"],"content":"use anyhow::{Context, Result};\nuse scarab_protocol::{ControlMessage, SOCKET_PATH, MAX_MESSAGE_SIZE, MAX_CLIENTS};\nuse crate::session::{SessionManager, handle_session_command};\nuse std::path::Path;\nuse std::sync::Arc;\nuse tokio::io::AsyncReadExt;\nuse tokio::net::{UnixListener, UnixStream};\nuse tokio::sync::{mpsc, RwLock};\nuse portable_pty::PtySize;\n\n/// Handle to send commands to PTY\n/// Using channels for thread-safe communication\n#[derive(Clone)]\npub struct PtyHandle {\n    input_tx: mpsc::UnboundedSender\u003cVec\u003cu8\u003e\u003e,\n    resize_tx: mpsc::Sender\u003cPtySize\u003e,\n}\n\nimpl PtyHandle {\n    pub fn new(\n        input_tx: mpsc::UnboundedSender\u003cVec\u003cu8\u003e\u003e,\n        resize_tx: mpsc::Sender\u003cPtySize\u003e,\n    ) -\u003e Self {\n        Self {\n            input_tx,\n            resize_tx,\n        }\n    }\n\n    pub async fn write_input(\u0026self, data: \u0026[u8]) -\u003e Result\u003c()\u003e {\n        self.input_tx\n            .send(data.to_vec())\n            .context(\"Failed to send input to PTY channel\")?;\n        Ok(())\n    }\n\n    pub async fn resize(\u0026self, cols: u16, rows: u16) -\u003e Result\u003c()\u003e {\n        self.resize_tx\n            .send(PtySize {\n                rows,\n                cols,\n                pixel_width: 0,\n                pixel_height: 0,\n            })\n            .await\n            .context(\"Failed to send resize event to PTY\")?;\n        Ok(())\n    }\n}\n\n/// IPC server managing multiple client connections\npub struct IpcServer {\n    listener: UnixListener,\n    pty_handle: PtyHandle,\n    session_manager: Arc\u003cSessionManager\u003e,\n    client_counter: Arc\u003cRwLock\u003cu64\u003e\u003e,\n}\n\nimpl IpcServer {\n    /// Create new IPC server, removing stale socket if exists\n    pub async fn new(pty_handle: PtyHandle, session_manager: Arc\u003cSessionManager\u003e) -\u003e Result\u003cSelf\u003e {\n        // Remove existing socket if present\n        if Path::new(SOCKET_PATH).exists() {\n            std::fs::remove_file(SOCKET_PATH)\n                .context(\"Failed to remove stale socket\")?;\n        }\n\n        let listener = UnixListener::bind(SOCKET_PATH)\n            .context(\"Failed to bind Unix socket\")?;\n\n        // Set socket permissions to 700 (owner only)\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            std::fs::set_permissions(\n                SOCKET_PATH,\n                std::fs::Permissions::from_mode(0o700),\n            )\n            .context(\"Failed to set socket permissions\")?;\n        }\n\n        println!(\"IPC server listening on: {}\", SOCKET_PATH);\n\n        Ok(Self {\n            listener,\n            pty_handle,\n            session_manager,\n            client_counter: Arc::new(RwLock::new(0)),\n        })\n    }\n\n    /// Accept client connections in a loop\n    pub async fn accept_loop(self) -\u003e Result\u003c()\u003e {\n        let active_clients = Arc::new(RwLock::new(0usize));\n\n        loop {\n            match self.listener.accept().await {\n                Ok((stream, _addr)) =\u003e {\n                    let client_count = {\n                        let mut count = active_clients.write().await;\n                        *count += 1;\n                        *count\n                    };\n\n                    if client_count \u003e MAX_CLIENTS {\n                        eprintln!(\"Max clients ({}) reached, rejecting connection\", MAX_CLIENTS);\n                        let mut count = active_clients.write().await;\n                        *count -= 1;\n                        continue;\n                    }\n\n                    let client_id = {\n                        let mut counter = self.client_counter.write().await;\n                        *counter += 1;\n                        *counter\n                    };\n\n                    println!(\"Client {} connected (active: {})\", client_id, client_count);\n\n                    let pty_handle = self.pty_handle.clone();\n                    let session_manager = self.session_manager.clone();\n                    let active_clients = active_clients.clone();\n\n                    tokio::spawn(async move {\n                        if let Err(e) = handle_client(stream, client_id, pty_handle, session_manager).await {\n                            eprintln!(\"Client {} error: {}\", client_id, e);\n                        }\n\n                        let mut count = active_clients.write().await;\n                        *count -= 1;\n                        println!(\"Client {} disconnected (active: {})\", client_id, *count);\n                    });\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"Failed to accept client: {}\", e);\n                }\n            }\n        }\n    }\n}\n\n/// Handle individual client connection\nasync fn handle_client(\n    mut stream: UnixStream,\n    client_id: u64,\n    pty_handle: PtyHandle,\n    session_manager: Arc\u003cSessionManager\u003e,\n) -\u003e Result\u003c()\u003e {\n    let mut buffer = vec![0u8; MAX_MESSAGE_SIZE];\n\n    loop {\n        // Read message length prefix (4 bytes)\n        let len = match stream.read_u32().await {\n            Ok(len) =\u003e len as usize,\n            Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof =\u003e {\n                // Client disconnected gracefully\n                break;\n            }\n            Err(e) =\u003e {\n                return Err(e).context(\"Failed to read message length\");\n            }\n        };\n\n        if len == 0 || len \u003e MAX_MESSAGE_SIZE {\n            anyhow::bail!(\"Invalid message length: {}\", len);\n        }\n\n        // Read message data\n        stream.read_exact(\u0026mut buffer[..len]).await\n            .context(\"Failed to read message data\")?;\n\n        // Deserialize with rkyv\n        let msg = match rkyv::from_bytes::\u003cControlMessage\u003e(\u0026buffer[..len]) {\n            Ok(msg) =\u003e msg,\n            Err(e) =\u003e {\n                eprintln!(\"Failed to deserialize ControlMessage: {:?}\", e);\n                anyhow::bail!(\"Deserialization error\");\n            }\n        };\n\n        // Handle message\n        if let Err(e) = handle_message(msg, \u0026pty_handle, \u0026session_manager, client_id).await {\n            eprintln!(\"Client {} message handling error: {}\", client_id, e);\n            // Don't disconnect on individual message errors\n        }\n    }\n\n    Ok(())\n}\n\n/// Process a control message\nasync fn handle_message(\n    msg: ControlMessage,\n    pty_handle: \u0026PtyHandle,\n    session_manager: \u0026Arc\u003cSessionManager\u003e,\n    client_id: u64,\n) -\u003e Result\u003c()\u003e {\n    // Try to handle as session command first\n    if let Ok(Some(response)) = handle_session_command(msg.clone(), session_manager, client_id).await {\n        log::info!(\"Session command response: {:?}\", response);\n        // TODO: Send response back to client (requires bidirectional communication)\n        return Ok(());\n    }\n\n    // Handle non-session commands\n    match msg {\n        ControlMessage::Resize { cols, rows } =\u003e {\n            println!(\"Client {} resize: {}x{}\", client_id, cols, rows);\n            pty_handle.resize(cols, rows).await?;\n        }\n        ControlMessage::Input { data } =\u003e {\n            // Validate input size to prevent abuse\n            if data.len() \u003e MAX_MESSAGE_SIZE {\n                anyhow::bail!(\"Input data too large: {} bytes\", data.len());\n            }\n            pty_handle.write_input(\u0026data).await?;\n        }\n        ControlMessage::LoadPlugin { path } =\u003e {\n            println!(\"Client {} loading plugin: {}\", client_id, path);\n            // TODO: Implement plugin loading\n            eprintln!(\"Plugin loading not yet implemented\");\n        }\n        ControlMessage::Ping { timestamp } =\u003e {\n            println!(\"Client {} ping: {}\", client_id, timestamp);\n            // Could respond with pong if bidirectional communication is needed\n        }\n        ControlMessage::Disconnect { client_id: id } =\u003e {\n            println!(\"Client {} requesting disconnect\", id);\n            // Client will disconnect when this function returns\n        }\n        // Session commands are already handled above, but add catch-all for completeness\n        ControlMessage::SessionCreate { .. }\n        | ControlMessage::SessionDelete { .. }\n        | ControlMessage::SessionList\n        | ControlMessage::SessionAttach { .. }\n        | ControlMessage::SessionDetach { .. }\n        | ControlMessage::SessionRename { .. } =\u003e {\n            // Already handled by handle_session_command\n        }\n    }\n\n    Ok(())\n}\n\n/// Cleanup socket on server shutdown\nimpl Drop for IpcServer {\n    fn drop(\u0026mut self) {\n        if Path::new(SOCKET_PATH).exists() {\n            let _ = std::fs::remove_file(SOCKET_PATH);\n            println!(\"Cleaned up socket: {}\", SOCKET_PATH);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","lib.rs"],"content":"// Expose session module for testing\npub mod session;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","main.rs"],"content":"use portable_pty::{CommandBuilder, NativePtySystem, PtySize, PtySystem};\nuse anyhow::Result;\nuse std::io::Read;\nuse std::sync::atomic::AtomicU64;\nuse std::sync::{Arc, Mutex};\nuse tokio::sync::mpsc;\nuse shared_memory::ShmemConf;\nuse scarab_protocol::{SharedState, SHMEM_PATH};\n\nmod ipc;\nmod vte;\nmod session;\n\nuse ipc::{IpcServer, PtyHandle};\nuse session::SessionManager;\n\n#[cfg(test)]\nmod tests;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    env_logger::init();\n    println!(\"Starting Scarab Daemon...\");\n\n    // 1. Initialize Session Manager\n    let home_dir = std::env::var(\"HOME\").unwrap_or_else(|_| \".\".to_string());\n    let db_path = std::path::PathBuf::from(home_dir)\n        .join(\".local/share/scarab/sessions.db\");\n\n    let session_manager = std::sync::Arc::new(SessionManager::new(db_path)?);\n\n    // Restore sessions from previous daemon runs\n    session_manager.restore_sessions()?;\n    println!(\"Session Manager: Active ({} sessions)\", session_manager.session_count());\n\n    // Create default session if none exist\n    if session_manager.session_count() == 0 {\n        let session_id = session_manager.create_session(\"default\".to_string(), 80, 24)?;\n        println!(\"Created default session: {}\", session_id);\n    }\n\n    // 2. Setup PTY System (legacy - will be per-session)\n    let pty_system = NativePtySystem::default();\n    let pair = pty_system.openpty(PtySize {\n        rows: 24,\n        cols: 80,\n        pixel_width: 0,\n        pixel_height: 0,\n    })?;\n\n    let cmd = CommandBuilder::new(\"bash\");\n    let _child = pair.slave.spawn_command(cmd)?;\n\n    // Important: Release slave handle in parent process\n    drop(pair.slave);\n\n    let reader = pair.master.try_clone_reader()?;\n    let reader = Arc::new(Mutex::new(reader));\n    let writer = pair.master.take_writer()?;\n\n    // 2. Initialize Shared Memory\n    let shmem = ShmemConf::new()\n        .size(std::mem::size_of::\u003cSharedState\u003e())\n        .os_id(SHMEM_PATH)\n        .create()?;\n\n    println!(\"Created shared memory at: {}\", SHMEM_PATH);\n\n    // Initialize shared state with zeroed memory\n    let shared_ptr = shmem.as_ptr() as *mut SharedState;\n    unsafe {\n        std::ptr::write_bytes(shared_ptr, 0, 1);\n    }\n\n    let sequence_counter = Arc::new(AtomicU64::new(0));\n\n    // Initialize VTE parser\n    let mut terminal_state = vte::TerminalState::new(shared_ptr, sequence_counter.clone());\n    println!(\"VTE Parser: Active\");\n    println!(\"Scrollback buffer: 10,000 lines\");\n\n    // 3. Setup IPC Control Channel with channels for thread safety\n    let (resize_tx, mut resize_rx) = mpsc::channel::\u003cPtySize\u003e(32);\n    let (input_tx, mut input_rx) = mpsc::unbounded_channel::\u003cVec\u003cu8\u003e\u003e();\n    let pty_handle = PtyHandle::new(input_tx, resize_tx);\n\n    let ipc_server = IpcServer::new(pty_handle.clone(), session_manager.clone()).await?;\n\n    // Spawn IPC server task\n    tokio::spawn(async move {\n        if let Err(e) = ipc_server.accept_loop().await {\n            eprintln!(\"IPC server error: {}\", e);\n        }\n    });\n\n    // Spawn PTY writer task to handle input from IPC\n    let mut writer = writer;\n    tokio::spawn(async move {\n        use std::io::Write;\n        while let Some(data) = input_rx.recv().await {\n            if let Err(e) = writer.write_all(\u0026data) {\n                eprintln!(\"PTY write error: {}\", e);\n                break;\n            }\n            if let Err(e) = writer.flush() {\n                eprintln!(\"PTY flush error: {}\", e);\n                break;\n            }\n        }\n    });\n\n    println!(\"Daemon initialized. Listening for input...\");\n\n    // 4. Main Loop with PTY reading and resize handling\n    loop {\n        tokio::select! {\n            // Handle PTY output\n            read_result = tokio::task::spawn_blocking({\n                let reader_clone = Arc::clone(\u0026reader);\n                move || {\n                    let mut buf = [0u8; 4096];\n                    let mut reader_lock = reader_clone.lock().unwrap();\n                    reader_lock.read(\u0026mut buf).map(|n| (n, buf))\n                }\n            }) =\u003e {\n                match read_result? {\n                    Ok((n, buf)) if n \u003e 0 =\u003e {\n                        let data = \u0026buf[..n];\n\n                        // Debug output (can be disabled in production)\n                        if cfg!(debug_assertions) {\n                            print!(\"{}\", String::from_utf8_lossy(data));\n                        }\n\n                        // Process output through VTE parser\n                        // This will:\n                        // 1. Parse ANSI escape sequences\n                        // 2. Update grid cells with proper colors and attributes\n                        // 3. Handle cursor positioning\n                        // 4. Manage scrollback buffer\n                        // 5. Atomically update shared state\n                        terminal_state.process_output(data);\n                    }\n                    Ok(_) =\u003e break, // EOF\n                    Err(e) =\u003e {\n                        eprintln!(\"PTY Error: {}\", e);\n                        break;\n                    }\n                }\n            }\n\n            // Handle resize events from IPC\n            Some(pty_size) = resize_rx.recv() =\u003e {\n                println!(\"Resizing PTY to {}x{}\", pty_size.cols, pty_size.rows);\n                if let Err(e) = pair.master.resize(pty_size) {\n                    eprintln!(\"Failed to resize PTY: {}\", e);\n                }\n            }\n        }\n    }\n\n    // Cleanup shared memory\n    drop(shmem);\n    println!(\"Daemon shutting down...\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","plugin_manager.rs"],"content":"//! Plugin lifecycle management and hook dispatch\n\nuse scarab_plugin_api::{\n    Action, Plugin, PluginConfig, PluginContext, PluginDiscovery, PluginError, PluginInfo,\n    PluginMetadata, Result,\n};\nuse std::{\n    collections::HashMap,\n    panic::{catch_unwind, AssertUnwindSafe},\n    path::{Path, PathBuf},\n    sync::Arc,\n    time::Duration,\n};\nuse tokio::time::timeout;\n\n/// Plugin wrapper with failure tracking\nstruct ManagedPlugin {\n    /// The actual plugin instance\n    plugin: Box\u003cdyn Plugin\u003e,\n    /// Plugin configuration\n    config: PluginConfig,\n    /// Number of consecutive failures\n    failure_count: u32,\n    /// Whether plugin is currently enabled\n    enabled: bool,\n    /// Maximum failures before auto-disable\n    max_failures: u32,\n}\n\nimpl ManagedPlugin {\n    fn new(plugin: Box\u003cdyn Plugin\u003e, config: PluginConfig) -\u003e Self {\n        Self {\n            plugin,\n            config,\n            failure_count: 0,\n            enabled: true,\n            max_failures: 3,\n        }\n    }\n\n    /// Record a failure and potentially disable the plugin\n    fn record_failure(\u0026mut self) {\n        self.failure_count += 1;\n        if self.failure_count \u003e= self.max_failures {\n            log::error!(\n                \"Plugin '{}' disabled after {} consecutive failures\",\n                self.plugin.metadata().name,\n                self.failure_count\n            );\n            self.enabled = false;\n        }\n    }\n\n    /// Record successful execution\n    fn record_success(\u0026mut self) {\n        self.failure_count = 0;\n    }\n\n    /// Get plugin info\n    fn info(\u0026self) -\u003e PluginInfo {\n        let meta = self.plugin.metadata();\n        PluginInfo {\n            name: meta.name.clone(),\n            version: meta.version.clone(),\n            description: meta.description.clone(),\n            author: meta.author.clone(),\n            homepage: meta.homepage.clone(),\n            api_version: meta.api_version.clone(),\n            min_scarab_version: meta.min_scarab_version.clone(),\n            enabled: self.enabled,\n            failure_count: self.failure_count,\n        }\n    }\n}\n\n/// Plugin manager for loading, managing, and dispatching to plugins\npub struct PluginManager {\n    /// Loaded plugins\n    plugins: Vec\u003cManagedPlugin\u003e,\n    /// Plugin discovery\n    discovery: PluginDiscovery,\n    /// Hook execution timeout (milliseconds)\n    hook_timeout: Duration,\n    /// Plugin context\n    context: Arc\u003cPluginContext\u003e,\n}\n\nimpl PluginManager {\n    /// Create new plugin manager\n    pub fn new(context: Arc\u003cPluginContext\u003e) -\u003e Self {\n        Self {\n            plugins: Vec::new(),\n            discovery: PluginDiscovery::new(),\n            hook_timeout: Duration::from_millis(1000),\n            context,\n        }\n    }\n\n    /// Set hook execution timeout\n    pub fn with_timeout(mut self, timeout_ms: u64) -\u003e Self {\n        self.hook_timeout = Duration::from_millis(timeout_ms);\n        self\n    }\n\n    /// Load plugins from configuration file\n    pub async fn load_from_config(\u0026mut self, config_path: Option\u003c\u0026Path\u003e) -\u003e Result\u003cusize\u003e {\n        let configs = self.discovery.load_config(config_path)?;\n        let mut loaded = 0;\n\n        for config in configs {\n            if !config.enabled {\n                log::info!(\"Skipping disabled plugin: {}\", config.name);\n                continue;\n            }\n\n            match self.load_plugin_from_config(config).await {\n                Ok(_) =\u003e loaded += 1,\n                Err(e) =\u003e log::error!(\"Failed to load plugin: {}\", e),\n            }\n        }\n\n        log::info!(\"Loaded {} plugins\", loaded);\n        Ok(loaded)\n    }\n\n    /// Discover and load all plugins from search paths\n    pub async fn discover_and_load(\u0026mut self) -\u003e Result\u003cusize\u003e {\n        let plugin_files = self.discovery.discover();\n        let mut loaded = 0;\n\n        for path in plugin_files {\n            // Create minimal config for discovered plugin\n            let config = PluginConfig {\n                name: path\n                    .file_stem()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"unknown\")\n                    .to_string(),\n                path: path.clone(),\n                enabled: true,\n                config: Default::default(),\n            };\n\n            match self.load_plugin_from_config(config).await {\n                Ok(_) =\u003e loaded += 1,\n                Err(e) =\u003e log::warn!(\"Failed to load plugin from {:?}: {}\", path, e),\n            }\n        }\n\n        Ok(loaded)\n    }\n\n    /// Load a single plugin from configuration\n    async fn load_plugin_from_config(\u0026mut self, config: PluginConfig) -\u003e Result\u003c()\u003e {\n        let path = config.expanded_path();\n\n        // For now, we'll create a placeholder for actual plugin loading\n        // In a real implementation, this would:\n        // 1. Load the .fzb bytecode and execute in fusabi-vm\n        // 2. Load the .fsx script and run in fusabi-interpreter\n        // 3. Create a Plugin trait object from the loaded code\n\n        log::info!(\"Loading plugin: {} from {:?}\", config.name, path);\n\n        // Check if file exists\n        if !path.exists() {\n            return Err(PluginError::NotFound(format!(\"{:?}\", path)));\n        }\n\n        // TODO: Actual plugin loading based on file extension\n        // For now, we'll just validate the path\n        match path.extension().and_then(|e| e.to_str()) {\n            Some(\"fzb\") =\u003e {\n                log::debug!(\"Would load compiled plugin: {:?}\", path);\n            }\n            Some(\"fsx\") =\u003e {\n                log::debug!(\"Would load script plugin: {:?}\", path);\n            }\n            _ =\u003e {\n                return Err(PluginError::LoadError(format!(\n                    \"Unsupported plugin format: {:?}\",\n                    path\n                )))\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Manually register a plugin\n    pub async fn register_plugin(\u0026mut self, mut plugin: Box\u003cdyn Plugin\u003e) -\u003e Result\u003c()\u003e {\n        let metadata = plugin.metadata();\n\n        // Check API compatibility\n        if !metadata.is_compatible(scarab_plugin_api::API_VERSION) {\n            return Err(PluginError::VersionIncompatible {\n                required: scarab_plugin_api::API_VERSION.to_string(),\n                actual: metadata.api_version.clone(),\n            });\n        }\n\n        log::info!(\"Registering plugin: {} v{}\", metadata.name, metadata.version);\n\n        // Call on_load with timeout and panic catching\n        let mut ctx = (*self.context).clone();\n        let result = self\n            .call_with_safety(\n                \u0026metadata.name,\n                async move { plugin.on_load(\u0026mut ctx).await },\n            )\n            .await;\n\n        match result {\n            Ok(_) =\u003e {\n                let config = PluginConfig {\n                    name: metadata.name.clone(),\n                    path: PathBuf::new(),\n                    enabled: true,\n                    config: Default::default(),\n                };\n                self.plugins.push(ManagedPlugin::new(plugin, config));\n                log::info!(\"Plugin registered successfully: {}\", metadata.name);\n                Ok(())\n            }\n            Err(e) =\u003e {\n                log::error!(\"Failed to initialize plugin: {}\", e);\n                Err(e)\n            }\n        }\n    }\n\n    /// Dispatch output hook to all enabled plugins\n    pub async fn dispatch_output(\u0026mut self, line: \u0026str) -\u003e Result\u003cString\u003e {\n        let mut data = line.to_string();\n\n        for managed in \u0026mut self.plugins {\n            if !managed.enabled {\n                continue;\n            }\n\n            let plugin_name = managed.plugin.metadata().name.clone();\n            let current_data = data.clone();\n            let ctx = self.context.clone();\n\n            let result = self\n                .call_with_safety(\n                    \u0026plugin_name,\n                    managed.plugin.on_output(\u0026current_data, \u0026ctx),\n                )\n                .await;\n\n            match result {\n                Ok(Action::Continue) =\u003e {\n                    managed.record_success();\n                }\n                Ok(Action::Stop) =\u003e {\n                    managed.record_success();\n                    break;\n                }\n                Ok(Action::Modify(new_data)) =\u003e {\n                    managed.record_success();\n                    data = String::from_utf8(new_data).unwrap_or(data);\n                }\n                Err(e) =\u003e {\n                    log::error!(\"Plugin '{}' output hook failed: {}\", plugin_name, e);\n                    managed.record_failure();\n                }\n            }\n        }\n\n        Ok(data)\n    }\n\n    /// Dispatch input hook to all enabled plugins\n    pub async fn dispatch_input(\u0026mut self, input: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        let mut data = input.to_vec();\n\n        for managed in \u0026mut self.plugins {\n            if !managed.enabled {\n                continue;\n            }\n\n            let plugin_name = managed.plugin.metadata().name.clone();\n            let current_data = data.clone();\n            let ctx = self.context.clone();\n\n            let result = self\n                .call_with_safety(\n                    \u0026plugin_name,\n                    managed.plugin.on_input(\u0026current_data, \u0026ctx),\n                )\n                .await;\n\n            match result {\n                Ok(Action::Continue) =\u003e {\n                    managed.record_success();\n                }\n                Ok(Action::Stop) =\u003e {\n                    managed.record_success();\n                    break;\n                }\n                Ok(Action::Modify(new_data)) =\u003e {\n                    managed.record_success();\n                    data = new_data;\n                }\n                Err(e) =\u003e {\n                    log::error!(\"Plugin '{}' input hook failed: {}\", plugin_name, e);\n                    managed.record_failure();\n                }\n            }\n        }\n\n        Ok(data)\n    }\n\n    /// Dispatch resize event to all enabled plugins\n    pub async fn dispatch_resize(\u0026mut self, cols: u16, rows: u16) -\u003e Result\u003c()\u003e {\n        for managed in \u0026mut self.plugins {\n            if !managed.enabled {\n                continue;\n            }\n\n            let plugin_name = managed.plugin.metadata().name.clone();\n            let ctx = self.context.clone();\n\n            let result = self\n                .call_with_safety(\u0026plugin_name, managed.plugin.on_resize(cols, rows, \u0026ctx))\n                .await;\n\n            match result {\n                Ok(_) =\u003e managed.record_success(),\n                Err(e) =\u003e {\n                    log::error!(\"Plugin '{}' resize hook failed: {}\", plugin_name, e);\n                    managed.record_failure();\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get information about all loaded plugins\n    pub fn list_plugins(\u0026self) -\u003e Vec\u003cPluginInfo\u003e {\n        self.plugins.iter().map(|p| p.info()).collect()\n    }\n\n    /// Get count of enabled plugins\n    pub fn enabled_count(\u0026self) -\u003e usize {\n        self.plugins.iter().filter(|p| p.enabled).count()\n    }\n\n    /// Unload all plugins\n    pub async fn unload_all(\u0026mut self) -\u003e Result\u003c()\u003e {\n        log::info!(\"Unloading {} plugins\", self.plugins.len());\n\n        for managed in \u0026mut self.plugins {\n            let plugin_name = managed.plugin.metadata().name.clone();\n            let result = self\n                .call_with_safety(\u0026plugin_name, managed.plugin.on_unload())\n                .await;\n\n            if let Err(e) = result {\n                log::error!(\"Error unloading plugin '{}': {}\", plugin_name, e);\n            }\n        }\n\n        self.plugins.clear();\n        Ok(())\n    }\n\n    /// Call plugin method with timeout and panic catching\n    async fn call_with_safety\u003cF, T\u003e(\u0026self, plugin_name: \u0026str, future: F) -\u003e Result\u003cT\u003e\n    where\n        F: std::future::Future\u003cOutput = Result\u003cT\u003e\u003e + Send + 'static,\n        T: Send + 'static,\n    {\n        // Wrap in panic catching\n        let panic_result = catch_unwind(AssertUnwindSafe(|| {\n            tokio::runtime::Handle::current().block_on(async {\n                // Apply timeout\n                match timeout(self.hook_timeout, future).await {\n                    Ok(result) =\u003e result,\n                    Err(_) =\u003e Err(PluginError::Timeout(self.hook_timeout.as_millis() as u64)),\n                }\n            })\n        }));\n\n        match panic_result {\n            Ok(result) =\u003e result,\n            Err(panic) =\u003e {\n                let msg = if let Some(s) = panic.downcast_ref::\u003c\u0026str\u003e() {\n                    s.to_string()\n                } else if let Some(s) = panic.downcast_ref::\u003cString\u003e() {\n                    s.clone()\n                } else {\n                    \"Unknown panic\".to_string()\n                };\n                Err(PluginError::Panic(format!(\n                    \"Plugin '{}' panicked: {}\",\n                    plugin_name, msg\n                )))\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use scarab_plugin_api::context::SharedState;\n    use std::sync::Arc;\n\n    // Mock plugin for testing\n    struct MockPlugin {\n        metadata: PluginMetadata,\n        should_panic: bool,\n    }\n\n    #[async_trait::async_trait]\n    impl Plugin for MockPlugin {\n        fn metadata(\u0026self) -\u003e \u0026PluginMetadata {\n            \u0026self.metadata\n        }\n\n        async fn on_output(\u0026mut self, line: \u0026str, _ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n            if self.should_panic {\n                panic!(\"Intentional panic\");\n            }\n            if line.contains(\"MODIFY\") {\n                Ok(Action::Modify(b\"MODIFIED\".to_vec()))\n            } else if line.contains(\"STOP\") {\n                Ok(Action::Stop)\n            } else {\n                Ok(Action::Continue)\n            }\n        }\n    }\n\n    fn create_test_context() -\u003e Arc\u003cPluginContext\u003e {\n        let state = Arc::new(parking_lot::Mutex::new(SharedState::new(80, 24)));\n        Arc::new(PluginContext::new(\n            Default::default(),\n            state,\n            \"test-plugin\",\n        ))\n    }\n\n    #[tokio::test]\n    async fn test_plugin_registration() {\n        let ctx = create_test_context();\n        let mut manager = PluginManager::new(ctx);\n\n        let plugin = Box::new(MockPlugin {\n            metadata: PluginMetadata::new(\"test\", \"1.0.0\", \"Test plugin\", \"Test Author\"),\n            should_panic: false,\n        });\n\n        assert!(manager.register_plugin(plugin).await.is_ok());\n        assert_eq!(manager.enabled_count(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_output_dispatch() {\n        let ctx = create_test_context();\n        let mut manager = PluginManager::new(ctx);\n\n        let plugin = Box::new(MockPlugin {\n            metadata: PluginMetadata::new(\"test\", \"1.0.0\", \"Test plugin\", \"Test Author\"),\n            should_panic: false,\n        });\n\n        manager.register_plugin(plugin).await.unwrap();\n\n        let result = manager.dispatch_output(\"test\").await.unwrap();\n        assert_eq!(result, \"test\");\n\n        let result = manager.dispatch_output(\"MODIFY this\").await.unwrap();\n        assert_eq!(result, \"MODIFIED\");\n    }\n\n    #[tokio::test]\n    async fn test_panic_handling() {\n        let ctx = create_test_context();\n        let mut manager = PluginManager::new(ctx);\n\n        let plugin = Box::new(MockPlugin {\n            metadata: PluginMetadata::new(\"test\", \"1.0.0\", \"Test plugin\", \"Test Author\"),\n            should_panic: true,\n        });\n\n        manager.register_plugin(plugin).await.unwrap();\n\n        // Should not crash, plugin should be disabled after failures\n        for _ in 0..5 {\n            let _ = manager.dispatch_output(\"test\").await;\n        }\n\n        assert_eq!(manager.enabled_count(), 0);\n    }\n}\n","traces":[{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","profiling.rs"],"content":"//! Profiling infrastructure for performance analysis\n//!\n//! This module provides profiling utilities using Tracy and puffin\n//! to help identify performance bottlenecks and optimize critical paths.\n\nuse std::sync::atomic::{AtomicBool, AtomicU64, Ordering};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\n// Re-export profiling macros for convenience\n#[cfg(feature = \"profiling\")]\npub use profiling::{function, scope};\n\n// If profiling is disabled, provide no-op macros\n#[cfg(not(feature = \"profiling\"))]\n#[macro_export]\nmacro_rules! function {\n    () =\u003e {};\n}\n\n#[cfg(not(feature = \"profiling\"))]\n#[macro_export]\nmacro_rules! scope {\n    ($name:expr) =\u003e {};\n    ($name:expr, $data:expr) =\u003e {};\n}\n\n/// Performance metrics collector\npub struct MetricsCollector {\n    // Frame timing metrics\n    frame_times: Arc\u003cAtomicU64\u003e,\n    frame_count: Arc\u003cAtomicU64\u003e,\n\n    // VTE parsing metrics\n    vte_parse_time_ns: Arc\u003cAtomicU64\u003e,\n    vte_parse_count: Arc\u003cAtomicU64\u003e,\n    vte_bytes_processed: Arc\u003cAtomicU64\u003e,\n\n    // Rendering metrics\n    render_time_ns: Arc\u003cAtomicU64\u003e,\n    render_count: Arc\u003cAtomicU64\u003e,\n    draw_calls: Arc\u003cAtomicU64\u003e,\n\n    // Memory metrics\n    allocated_bytes: Arc\u003cAtomicU64\u003e,\n    gpu_memory_bytes: Arc\u003cAtomicU64\u003e,\n\n    // IPC metrics\n    ipc_messages_sent: Arc\u003cAtomicU64\u003e,\n    ipc_messages_received: Arc\u003cAtomicU64\u003e,\n    ipc_bytes_transferred: Arc\u003cAtomicU64\u003e,\n\n    // Shared memory metrics\n    shmem_sync_time_ns: Arc\u003cAtomicU64\u003e,\n    shmem_sync_count: Arc\u003cAtomicU64\u003e,\n\n    collection_enabled: Arc\u003cAtomicBool\u003e,\n}\n\nimpl MetricsCollector {\n    pub fn new() -\u003e Self {\n        Self {\n            frame_times: Arc::new(AtomicU64::new(0)),\n            frame_count: Arc::new(AtomicU64::new(0)),\n            vte_parse_time_ns: Arc::new(AtomicU64::new(0)),\n            vte_parse_count: Arc::new(AtomicU64::new(0)),\n            vte_bytes_processed: Arc::new(AtomicU64::new(0)),\n            render_time_ns: Arc::new(AtomicU64::new(0)),\n            render_count: Arc::new(AtomicU64::new(0)),\n            draw_calls: Arc::new(AtomicU64::new(0)),\n            allocated_bytes: Arc::new(AtomicU64::new(0)),\n            gpu_memory_bytes: Arc::new(AtomicU64::new(0)),\n            ipc_messages_sent: Arc::new(AtomicU64::new(0)),\n            ipc_messages_received: Arc::new(AtomicU64::new(0)),\n            ipc_bytes_transferred: Arc::new(AtomicU64::new(0)),\n            shmem_sync_time_ns: Arc::new(AtomicU64::new(0)),\n            shmem_sync_count: Arc::new(AtomicU64::new(0)),\n            collection_enabled: Arc::new(AtomicBool::new(true)),\n        }\n    }\n\n    pub fn enable(\u0026self) {\n        self.collection_enabled.store(true, Ordering::Relaxed);\n    }\n\n    pub fn disable(\u0026self) {\n        self.collection_enabled.store(false, Ordering::Relaxed);\n    }\n\n    pub fn is_enabled(\u0026self) -\u003e bool {\n        self.collection_enabled.load(Ordering::Relaxed)\n    }\n\n    // Frame timing\n    pub fn record_frame_time(\u0026self, duration: Duration) {\n        if self.is_enabled() {\n            self.frame_times.fetch_add(duration.as_nanos() as u64, Ordering::Relaxed);\n            self.frame_count.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n\n    // VTE parsing\n    pub fn record_vte_parse(\u0026self, duration: Duration, bytes: usize) {\n        if self.is_enabled() {\n            self.vte_parse_time_ns.fetch_add(duration.as_nanos() as u64, Ordering::Relaxed);\n            self.vte_parse_count.fetch_add(1, Ordering::Relaxed);\n            self.vte_bytes_processed.fetch_add(bytes as u64, Ordering::Relaxed);\n        }\n    }\n\n    // Rendering\n    pub fn record_render(\u0026self, duration: Duration, draw_calls: u32) {\n        if self.is_enabled() {\n            self.render_time_ns.fetch_add(duration.as_nanos() as u64, Ordering::Relaxed);\n            self.render_count.fetch_add(1, Ordering::Relaxed);\n            self.draw_calls.fetch_add(draw_calls as u64, Ordering::Relaxed);\n        }\n    }\n\n    // Memory\n    pub fn set_allocated_bytes(\u0026self, bytes: usize) {\n        if self.is_enabled() {\n            self.allocated_bytes.store(bytes as u64, Ordering::Relaxed);\n        }\n    }\n\n    pub fn set_gpu_memory(\u0026self, bytes: usize) {\n        if self.is_enabled() {\n            self.gpu_memory_bytes.store(bytes as u64, Ordering::Relaxed);\n        }\n    }\n\n    // IPC\n    pub fn record_ipc_send(\u0026self, bytes: usize) {\n        if self.is_enabled() {\n            self.ipc_messages_sent.fetch_add(1, Ordering::Relaxed);\n            self.ipc_bytes_transferred.fetch_add(bytes as u64, Ordering::Relaxed);\n        }\n    }\n\n    pub fn record_ipc_receive(\u0026self, bytes: usize) {\n        if self.is_enabled() {\n            self.ipc_messages_received.fetch_add(1, Ordering::Relaxed);\n            self.ipc_bytes_transferred.fetch_add(bytes as u64, Ordering::Relaxed);\n        }\n    }\n\n    // Shared memory\n    pub fn record_shmem_sync(\u0026self, duration: Duration) {\n        if self.is_enabled() {\n            self.shmem_sync_time_ns.fetch_add(duration.as_nanos() as u64, Ordering::Relaxed);\n            self.shmem_sync_count.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n\n    /// Get current performance report\n    pub fn report(\u0026self) -\u003e PerformanceReport {\n        let frame_count = self.frame_count.load(Ordering::Relaxed);\n        let frame_time_total = self.frame_times.load(Ordering::Relaxed);\n        let avg_frame_time_ms = if frame_count \u003e 0 {\n            (frame_time_total / frame_count) as f64 / 1_000_000.0\n        } else {\n            0.0\n        };\n\n        let vte_count = self.vte_parse_count.load(Ordering::Relaxed);\n        let vte_time_total = self.vte_parse_time_ns.load(Ordering::Relaxed);\n        let avg_vte_time_us = if vte_count \u003e 0 {\n            (vte_time_total / vte_count) as f64 / 1_000.0\n        } else {\n            0.0\n        };\n\n        let render_count = self.render_count.load(Ordering::Relaxed);\n        let render_time_total = self.render_time_ns.load(Ordering::Relaxed);\n        let avg_render_time_ms = if render_count \u003e 0 {\n            (render_time_total / render_count) as f64 / 1_000_000.0\n        } else {\n            0.0\n        };\n\n        let shmem_count = self.shmem_sync_count.load(Ordering::Relaxed);\n        let shmem_time_total = self.shmem_sync_time_ns.load(Ordering::Relaxed);\n        let avg_shmem_time_us = if shmem_count \u003e 0 {\n            (shmem_time_total / shmem_count) as f64 / 1_000.0\n        } else {\n            0.0\n        };\n\n        PerformanceReport {\n            avg_frame_time_ms,\n            avg_vte_parse_time_us,\n            vte_bytes_per_sec: self.vte_bytes_processed.load(Ordering::Relaxed) as f64,\n            avg_render_time_ms,\n            draw_calls_per_frame: if render_count \u003e 0 {\n                self.draw_calls.load(Ordering::Relaxed) as f64 / render_count as f64\n            } else {\n                0.0\n            },\n            allocated_mb: self.allocated_bytes.load(Ordering::Relaxed) as f64 / 1_048_576.0,\n            gpu_memory_mb: self.gpu_memory_bytes.load(Ordering::Relaxed) as f64 / 1_048_576.0,\n            ipc_messages_per_sec: 0.0, // Will calculate based on time window\n            avg_shmem_sync_time_us,\n        }\n    }\n\n    /// Reset all metrics\n    pub fn reset(\u0026self) {\n        self.frame_times.store(0, Ordering::Relaxed);\n        self.frame_count.store(0, Ordering::Relaxed);\n        self.vte_parse_time_ns.store(0, Ordering::Relaxed);\n        self.vte_parse_count.store(0, Ordering::Relaxed);\n        self.vte_bytes_processed.store(0, Ordering::Relaxed);\n        self.render_time_ns.store(0, Ordering::Relaxed);\n        self.render_count.store(0, Ordering::Relaxed);\n        self.draw_calls.store(0, Ordering::Relaxed);\n        self.ipc_messages_sent.store(0, Ordering::Relaxed);\n        self.ipc_messages_received.store(0, Ordering::Relaxed);\n        self.ipc_bytes_transferred.store(0, Ordering::Relaxed);\n        self.shmem_sync_time_ns.store(0, Ordering::Relaxed);\n        self.shmem_sync_count.store(0, Ordering::Relaxed);\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct PerformanceReport {\n    pub avg_frame_time_ms: f64,\n    pub avg_vte_parse_time_us: f64,\n    pub vte_bytes_per_sec: f64,\n    pub avg_render_time_ms: f64,\n    pub draw_calls_per_frame: f64,\n    pub allocated_mb: f64,\n    pub gpu_memory_mb: f64,\n    pub ipc_messages_per_sec: f64,\n    pub avg_shmem_sync_time_us: f64,\n}\n\nimpl PerformanceReport {\n    pub fn print_summary(\u0026self) {\n        println!(\"=== Performance Report ===\");\n        println!(\"Frame Time:        {:.2} ms\", self.avg_frame_time_ms);\n        println!(\"VTE Parse:         {:.2} s\", self.avg_vte_parse_time_us);\n        println!(\"VTE Throughput:    {:.2} KB/s\", self.vte_bytes_per_sec / 1024.0);\n        println!(\"Render Time:       {:.2} ms\", self.avg_render_time_ms);\n        println!(\"Draw Calls/Frame:  {:.1}\", self.draw_calls_per_frame);\n        println!(\"Memory:            {:.2} MB\", self.allocated_mb);\n        println!(\"GPU Memory:        {:.2} MB\", self.gpu_memory_mb);\n        println!(\"IPC Messages/sec:  {:.0}\", self.ipc_messages_per_sec);\n        println!(\"Shmem Sync:        {:.2} s\", self.avg_shmem_sync_time_us);\n    }\n\n    pub fn check_targets(\u0026self) -\u003e bool {\n        // Check if we meet performance targets\n        let mut success = true;\n\n        if self.avg_frame_time_ms \u003e 50.0 {\n            println!(\" Frame time {:.2}ms exceeds target of 50ms\", self.avg_frame_time_ms);\n            success = false;\n        } else {\n            println!(\" Frame time {:.2}ms meets target\", self.avg_frame_time_ms);\n        }\n\n        // Estimate CPU usage from timing (rough approximation)\n        // Assuming 60 FPS target, we have 16.67ms per frame\n        let frame_budget_ms = 16.67;\n        let cpu_usage_vte = (self.avg_vte_parse_time_us / 1000.0) / frame_budget_ms * 100.0;\n        let cpu_usage_render = self.avg_render_time_ms / frame_budget_ms * 100.0;\n        let cpu_usage_shmem = (self.avg_shmem_sync_time_us / 1000.0) / frame_budget_ms * 100.0;\n\n        if cpu_usage_vte \u003e 2.0 {\n            println!(\" VTE CPU usage {:.2}% exceeds target of 2%\", cpu_usage_vte);\n            success = false;\n        } else {\n            println!(\" VTE CPU usage {:.2}% meets target\", cpu_usage_vte);\n        }\n\n        if cpu_usage_render \u003e 3.0 {\n            println!(\" Render CPU usage {:.2}% exceeds target of 3%\", cpu_usage_render);\n            success = false;\n        } else {\n            println!(\" Render CPU usage {:.2}% meets target\", cpu_usage_render);\n        }\n\n        if cpu_usage_shmem \u003e 0.5 {\n            println!(\" Shmem CPU usage {:.2}% exceeds target of 0.5%\", cpu_usage_shmem);\n            success = false;\n        } else {\n            println!(\" Shmem CPU usage {:.2}% meets target\", cpu_usage_shmem);\n        }\n\n        if self.allocated_mb \u003e 100.0 {\n            println!(\" Memory usage {:.2}MB exceeds target of 100MB\", self.allocated_mb);\n            success = false;\n        } else {\n            println!(\" Memory usage {:.2}MB meets target\", self.allocated_mb);\n        }\n\n        if self.gpu_memory_mb \u003e 150.0 {\n            println!(\" GPU memory {:.2}MB exceeds target of 150MB\", self.gpu_memory_mb);\n            success = false;\n        } else {\n            println!(\" GPU memory {:.2}MB meets target\", self.gpu_memory_mb);\n        }\n\n        success\n    }\n}\n\n/// Profiling timer for measuring execution time\npub struct Timer {\n    start: Instant,\n    name: \u0026'static str,\n}\n\nimpl Timer {\n    pub fn new(name: \u0026'static str) -\u003e Self {\n        Self {\n            start: Instant::now(),\n            name,\n        }\n    }\n\n    pub fn elapsed(\u0026self) -\u003e Duration {\n        self.start.elapsed()\n    }\n}\n\nimpl Drop for Timer {\n    fn drop(\u0026mut self) {\n        let elapsed = self.start.elapsed();\n        log::trace!(\"{} took {:?}\", self.name, elapsed);\n    }\n}\n\n/// Initialize profiling infrastructure\npub fn init_profiling() {\n    #[cfg(feature = \"tracy\")]\n    {\n        // Tracy client is automatically initialized on first use\n        log::info!(\"Tracy profiling enabled\");\n    }\n\n    #[cfg(feature = \"puffin-profiling\")]\n    {\n        puffin::set_scopes_on(true);\n        log::info!(\"Puffin profiling enabled\");\n    }\n\n    #[cfg(not(feature = \"profiling\"))]\n    {\n        log::info!(\"Profiling disabled (compile with --features profiling to enable)\");\n    }\n}\n\n/// Macro for timing a block of code\n#[macro_export]\nmacro_rules! time_block {\n    ($name:expr, $block:expr) =\u003e {{\n        let _timer = $crate::profiling::Timer::new($name);\n        let result = $block;\n        result\n    }};\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","session","commands.rs"],"content":"use super::{SessionManager, ClientId};\nuse anyhow::Result;\nuse scarab_protocol::{ControlMessage, SessionResponse, SessionInfo};\nuse std::sync::Arc;\n\n/// Handle session-related control messages\npub async fn handle_session_command(\n    msg: ControlMessage,\n    session_manager: \u0026Arc\u003cSessionManager\u003e,\n    client_id: ClientId,\n) -\u003e Result\u003cOption\u003cSessionResponse\u003e\u003e {\n    match msg {\n        ControlMessage::SessionCreate { name } =\u003e {\n            log::info!(\"Client {} creating session: {}\", client_id, name);\n\n            match session_manager.create_session(name.to_string(), 80, 24) {\n                Ok(id) =\u003e {\n                    let session = session_manager.get_session(\u0026id).unwrap();\n                    Ok(Some(SessionResponse::Created {\n                        id: id.to_string().into(),\n                        name: session.name.clone().into(),\n                    }))\n                }\n                Err(e) =\u003e Ok(Some(SessionResponse::Error {\n                    message: format!(\"Failed to create session: {}\", e).into(),\n                })),\n            }\n        }\n\n        ControlMessage::SessionDelete { id } =\u003e {\n            log::info!(\"Client {} deleting session: {}\", client_id, id);\n\n            match session_manager.delete_session(\u0026id.to_string()) {\n                Ok(_) =\u003e Ok(Some(SessionResponse::Deleted {\n                    id: id.clone(),\n                })),\n                Err(e) =\u003e Ok(Some(SessionResponse::Error {\n                    message: format!(\"Failed to delete session: {}\", e).into(),\n                })),\n            }\n        }\n\n        ControlMessage::SessionList =\u003e {\n            log::info!(\"Client {} listing sessions\", client_id);\n\n            let sessions = session_manager.list_sessions();\n            let session_infos: Vec\u003cSessionInfo\u003e = sessions\n                .into_iter()\n                .map(|(id, name, created_at, last_attached, attached_clients)| SessionInfo {\n                    id: id.into(),\n                    name: name.into(),\n                    created_at,\n                    last_attached,\n                    attached_clients: attached_clients as u32,\n                })\n                .collect();\n\n            Ok(Some(SessionResponse::List {\n                sessions: session_infos.into(),\n            }))\n        }\n\n        ControlMessage::SessionAttach { id } =\u003e {\n            log::info!(\"Client {} attaching to session: {}\", client_id, id);\n\n            match session_manager.attach_client(\u0026id.to_string(), client_id) {\n                Ok(_) =\u003e Ok(Some(SessionResponse::Attached {\n                    id: id.clone(),\n                })),\n                Err(e) =\u003e Ok(Some(SessionResponse::Error {\n                    message: format!(\"Failed to attach to session: {}\", e).into(),\n                })),\n            }\n        }\n\n        ControlMessage::SessionDetach { id } =\u003e {\n            log::info!(\"Client {} detaching from session: {}\", client_id, id);\n\n            match session_manager.detach_client(\u0026id.to_string(), client_id) {\n                Ok(_) =\u003e Ok(Some(SessionResponse::Detached {\n                    id: id.clone(),\n                })),\n                Err(e) =\u003e Ok(Some(SessionResponse::Error {\n                    message: format!(\"Failed to detach from session: {}\", e).into(),\n                })),\n            }\n        }\n\n        ControlMessage::SessionRename { id, new_name } =\u003e {\n            log::info!(\"Client {} renaming session {} to {}\", client_id, id, new_name);\n\n            match session_manager.rename_session(\u0026id.to_string(), new_name.to_string()) {\n                Ok(_) =\u003e Ok(Some(SessionResponse::Renamed {\n                    id: id.clone(),\n                    new_name: new_name.clone(),\n                })),\n                Err(e) =\u003e Ok(Some(SessionResponse::Error {\n                    message: format!(\"Failed to rename session: {}\", e).into(),\n                })),\n            }\n        }\n\n        _ =\u003e {\n            // Not a session command\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_session_commands() {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().join(\"test.db\");\n\n        let manager = Arc::new(SessionManager::new(db_path).unwrap());\n\n        // Create session\n        let response = handle_session_command(\n            ControlMessage::SessionCreate {\n                name: \"test\".to_string().into(),\n            },\n            \u0026manager,\n            1,\n        )\n        .await\n        .unwrap();\n\n        assert!(matches!(response, Some(SessionResponse::Created { .. })));\n\n        // List sessions\n        let response = handle_session_command(\n            ControlMessage::SessionList,\n            \u0026manager,\n            1,\n        )\n        .await\n        .unwrap();\n\n        if let Some(SessionResponse::List { sessions }) = response {\n            assert_eq!(sessions.len(), 1);\n        } else {\n            panic!(\"Expected List response\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","session","manager.rs"],"content":"use super::{SessionId, ClientId, GridState, SessionStore};\nuse anyhow::{Result, bail};\nuse portable_pty::{CommandBuilder, NativePtySystem, PtyPair, PtySize, PtySystem};\nuse parking_lot::RwLock;\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse uuid::Uuid;\n\n/// A single terminal session with PTY and state\npub struct Session {\n    pub id: SessionId,\n    pub name: String,\n    pub pty_master: Arc\u003cRwLock\u003cOption\u003cBox\u003cdyn portable_pty::MasterPty + Send + Sync\u003e\u003e\u003e\u003e,\n    pub grid_state: Arc\u003cRwLock\u003cGridState\u003e\u003e,\n    pub created_at: SystemTime,\n    pub last_attached: Arc\u003cRwLock\u003cSystemTime\u003e\u003e,\n    pub attached_clients: Arc\u003cRwLock\u003cHashSet\u003cClientId\u003e\u003e\u003e,\n}\n\n// Session is Sync because all interior mutability is behind locks\nunsafe impl Sync for Session {}\n\nimpl Session {\n    /// Create a new session with a PTY\n    pub fn new(name: String, cols: u16, rows: u16) -\u003e Result\u003cSelf\u003e {\n        let pty_system = NativePtySystem::default();\n        let pair = pty_system.openpty(PtySize {\n            rows,\n            cols,\n            pixel_width: 0,\n            pixel_height: 0,\n        })?;\n\n        // Spawn shell in PTY\n        let cmd = CommandBuilder::new(\"bash\");\n        let _child = pair.slave.spawn_command(cmd)?;\n\n        // Extract master and slave separately to avoid partial move\n        let master: Box\u003cdyn portable_pty::MasterPty + Send + Sync\u003e =\n            unsafe { std::mem::transmute(pair.master) };\n        let _slave = pair.slave;\n        // Slave is dropped here, released in parent process\n\n        let id = Uuid::new_v4().to_string();\n        let now = SystemTime::now();\n\n        Ok(Self {\n            id,\n            name,\n            pty_master: Arc::new(RwLock::new(Some(master))),\n            grid_state: Arc::new(RwLock::new(GridState::new(cols, rows))),\n            created_at: now,\n            last_attached: Arc::new(RwLock::new(now)),\n            attached_clients: Arc::new(RwLock::new(HashSet::new())),\n        })\n    }\n\n    /// Restore session from persisted data (without PTY initially)\n    pub fn restore(\n        id: SessionId,\n        name: String,\n        created_at: SystemTime,\n        last_attached: SystemTime,\n    ) -\u003e Self {\n        Self {\n            id,\n            name,\n            pty_master: Arc::new(RwLock::new(None)),\n            grid_state: Arc::new(RwLock::new(GridState::new(80, 24))),\n            created_at,\n            last_attached: Arc::new(RwLock::new(last_attached)),\n            attached_clients: Arc::new(RwLock::new(HashSet::new())),\n        }\n    }\n\n    /// Attach a client to this session\n    pub fn attach_client(\u0026self, client_id: ClientId) {\n        let mut clients = self.attached_clients.write();\n        clients.insert(client_id);\n        *self.last_attached.write() = SystemTime::now();\n    }\n\n    /// Detach a client from this session\n    pub fn detach_client(\u0026self, client_id: ClientId) {\n        let mut clients = self.attached_clients.write();\n        clients.remove(\u0026client_id);\n    }\n\n    /// Check if session has any attached clients\n    pub fn has_attached_clients(\u0026self) -\u003e bool {\n        !self.attached_clients.read().is_empty()\n    }\n\n    /// Get attached client count\n    pub fn attached_client_count(\u0026self) -\u003e usize {\n        self.attached_clients.read().len()\n    }\n\n    /// Resize the PTY\n    pub fn resize(\u0026self, cols: u16, rows: u16) -\u003e Result\u003c()\u003e {\n        if let Some(ref master) = *self.pty_master.read() {\n            master.resize(PtySize {\n                rows,\n                cols,\n                pixel_width: 0,\n                pixel_height: 0,\n            })?;\n\n            let mut state = self.grid_state.write();\n            state.cols = cols;\n            state.rows = rows;\n        }\n        Ok(())\n    }\n\n    /// Get PTY master for reading/writing\n    pub fn pty_master(\u0026self) -\u003e Arc\u003cRwLock\u003cOption\u003cBox\u003cdyn portable_pty::MasterPty + Send + Sync\u003e\u003e\u003e\u003e {\n        Arc::clone(\u0026self.pty_master)\n    }\n}\n\n/// Manages multiple sessions\npub struct SessionManager {\n    sessions: Arc\u003cRwLock\u003cHashMap\u003cSessionId, Arc\u003cSession\u003e\u003e\u003e\u003e,\n    store: SessionStore,\n    default_session_id: Arc\u003cRwLock\u003cOption\u003cSessionId\u003e\u003e\u003e,\n}\n\nimpl SessionManager {\n    /// Create a new session manager\n    pub fn new(db_path: std::path::PathBuf) -\u003e Result\u003cSelf\u003e {\n        let store = SessionStore::new(db_path)?;\n\n        Ok(Self {\n            sessions: Arc::new(RwLock::new(HashMap::new())),\n            store,\n            default_session_id: Arc::new(RwLock::new(None)),\n        })\n    }\n\n    /// Initialize from persisted sessions\n    pub fn restore_sessions(\u0026self) -\u003e Result\u003c()\u003e {\n        let persisted = self.store.load_sessions()?;\n\n        let mut sessions = self.sessions.write();\n        for session in persisted {\n            let session = Arc::new(session);\n            sessions.insert(session.id.clone(), session);\n        }\n\n        log::info!(\"Restored {} sessions from storage\", sessions.len());\n        Ok(())\n    }\n\n    /// Create a new session\n    pub fn create_session(\u0026self, name: String, cols: u16, rows: u16) -\u003e Result\u003cSessionId\u003e {\n        let session = Session::new(name.clone(), cols, rows)?;\n        let id = session.id.clone();\n\n        // Persist to database\n        self.store.save_session(\u0026session)?;\n\n        // Add to active sessions\n        let mut sessions = self.sessions.write();\n        sessions.insert(id.clone(), Arc::new(session));\n\n        // Set as default if first session\n        if sessions.len() == 1 {\n            *self.default_session_id.write() = Some(id.clone());\n        }\n\n        log::info!(\"Created session: {} ({})\", name, id);\n        Ok(id)\n    }\n\n    /// Delete a session\n    pub fn delete_session(\u0026self, id: \u0026SessionId) -\u003e Result\u003c()\u003e {\n        let mut sessions = self.sessions.write();\n\n        if let Some(session) = sessions.remove(id) {\n            // Check if any clients are attached\n            if session.has_attached_clients() {\n                bail!(\"Cannot delete session with attached clients\");\n            }\n\n            // Remove from database\n            self.store.delete_session(id)?;\n\n            // Clear default if this was it\n            let mut default_id = self.default_session_id.write();\n            if default_id.as_ref() == Some(id) {\n                *default_id = sessions.keys().next().cloned();\n            }\n\n            log::info!(\"Deleted session: {}\", id);\n            Ok(())\n        } else {\n            bail!(\"Session not found: {}\", id)\n        }\n    }\n\n    /// Get a session by ID\n    pub fn get_session(\u0026self, id: \u0026SessionId) -\u003e Option\u003cArc\u003cSession\u003e\u003e {\n        self.sessions.read().get(id).cloned()\n    }\n\n    /// Get default session (or first available)\n    pub fn get_default_session(\u0026self) -\u003e Option\u003cArc\u003cSession\u003e\u003e {\n        let sessions = self.sessions.read();\n\n        if let Some(id) = self.default_session_id.read().as_ref() {\n            sessions.get(id).cloned()\n        } else {\n            sessions.values().next().cloned()\n        }\n    }\n\n    /// List all sessions\n    pub fn list_sessions(\u0026self) -\u003e Vec\u003c(SessionId, String, u64, u64, usize)\u003e {\n        let sessions = self.sessions.read();\n        sessions\n            .values()\n            .map(|s| {\n                let created = s.created_at\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs();\n                let last_attached = s.last_attached.read()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs();\n                let client_count = s.attached_client_count();\n\n                (s.id.clone(), s.name.clone(), created, last_attached, client_count)\n            })\n            .collect()\n    }\n\n    /// Attach a client to a session\n    pub fn attach_client(\u0026self, session_id: \u0026SessionId, client_id: ClientId) -\u003e Result\u003c()\u003e {\n        if let Some(session) = self.get_session(session_id) {\n            session.attach_client(client_id);\n\n            // Update persistence\n            self.store.update_last_attached(session_id)?;\n\n            log::info!(\"Client {} attached to session {}\", client_id, session_id);\n            Ok(())\n        } else {\n            bail!(\"Session not found: {}\", session_id)\n        }\n    }\n\n    /// Detach a client from a session\n    pub fn detach_client(\u0026self, session_id: \u0026SessionId, client_id: ClientId) -\u003e Result\u003c()\u003e {\n        if let Some(session) = self.get_session(session_id) {\n            session.detach_client(client_id);\n            log::info!(\"Client {} detached from session {}\", client_id, session_id);\n            Ok(())\n        } else {\n            bail!(\"Session not found: {}\", session_id)\n        }\n    }\n\n    /// Rename a session\n    pub fn rename_session(\u0026self, session_id: \u0026SessionId, new_name: String) -\u003e Result\u003c()\u003e {\n        let sessions = self.sessions.read();\n\n        if let Some(_session) = sessions.get(session_id) {\n            // Update in persistence layer (in-memory name would need RwLock wrapper for full mutability)\n            self.store.rename_session(session_id, \u0026new_name)?;\n            log::info!(\"Renamed session {} to {}\", session_id, new_name);\n            Ok(())\n        } else {\n            bail!(\"Session not found: {}\", session_id)\n        }\n    }\n\n    /// Get session count\n    pub fn session_count(\u0026self) -\u003e usize {\n        self.sessions.read().len()\n    }\n\n    /// Cleanup sessions with no attached clients (optional maintenance)\n    pub fn cleanup_detached_sessions(\u0026self, max_age_secs: u64) -\u003e Result\u003cusize\u003e {\n        let _now = SystemTime::now();\n        let sessions_to_delete: Vec\u003cSessionId\u003e = {\n            let sessions = self.sessions.read();\n            sessions\n                .values()\n                .filter(|s| {\n                    !s.has_attached_clients()\n                        \u0026\u0026 s.last_attached.read()\n                            .elapsed()\n                            .map(|d| d.as_secs() \u003e max_age_secs)\n                            .unwrap_or(false)\n                })\n                .map(|s| s.id.clone())\n                .collect()\n        };\n\n        let count = sessions_to_delete.len();\n        for id in sessions_to_delete {\n            self.delete_session(\u0026id)?;\n        }\n\n        Ok(count)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_session_lifecycle() {\n        let session = Session::new(\"test\".to_string(), 80, 24).unwrap();\n        assert_eq!(session.name, \"test\");\n        assert_eq!(session.attached_client_count(), 0);\n\n        session.attach_client(1);\n        assert_eq!(session.attached_client_count(), 1);\n        assert!(session.has_attached_clients());\n\n        session.detach_client(1);\n        assert_eq!(session.attached_client_count(), 0);\n        assert!(!session.has_attached_clients());\n    }\n\n    #[test]\n    fn test_session_manager_create_delete() {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().join(\"sessions.db\");\n\n        let manager = SessionManager::new(db_path).unwrap();\n\n        let id = manager.create_session(\"test\".to_string(), 80, 24).unwrap();\n        assert_eq!(manager.session_count(), 1);\n\n        manager.delete_session(\u0026id).unwrap();\n        assert_eq!(manager.session_count(), 0);\n    }\n\n    #[test]\n    fn test_session_attach_detach() {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().join(\"sessions.db\");\n\n        let manager = SessionManager::new(db_path).unwrap();\n        let id = manager.create_session(\"test\".to_string(), 80, 24).unwrap();\n\n        manager.attach_client(\u0026id, 1).unwrap();\n        let session = manager.get_session(\u0026id).unwrap();\n        assert!(session.has_attached_clients());\n\n        manager.detach_client(\u0026id, 1).unwrap();\n        assert!(!session.has_attached_clients());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","session","mod.rs"],"content":"mod manager;\nmod store;\nmod commands;\n\npub use manager::{SessionManager, Session};\npub use store::SessionStore;\npub use commands::handle_session_command;\n\n/// Client identifier\npub type ClientId = u64;\n\n/// Session identifier (UUID)\npub type SessionId = String;\n\n/// Grid state for session (placeholder for now, should match VTE state)\n#[derive(Clone, Debug)]\npub struct GridState {\n    pub cols: u16,\n    pub rows: u16,\n    // Additional state will be integrated with VTE\n}\n\nimpl GridState {\n    pub fn new(cols: u16, rows: u16) -\u003e Self {\n        Self { cols, rows }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","session","store.rs"],"content":"use super::{Session, SessionId};\nuse anyhow::{Context, Result};\nuse rusqlite::{params, Connection, OptionalExtension};\nuse std::path::PathBuf;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n/// SQLite-based session persistence\npub struct SessionStore {\n    db_path: PathBuf,\n}\n\n// Explicitly mark SessionStore as Send since Connection is not Send\n// but we never send connections across threads (only the path)\nunsafe impl Send for SessionStore {}\n\nimpl SessionStore {\n    /// Create a new session store with database at given path\n    pub fn new(db_path: PathBuf) -\u003e Result\u003cSelf\u003e {\n        // Ensure parent directory exists\n        if let Some(parent) = db_path.parent() {\n            std::fs::create_dir_all(parent)\n                .context(\"Failed to create database directory\")?;\n        }\n\n        let store = Self { db_path };\n\n        // Initialize database schema\n        store.init_schema()?;\n\n        Ok(store)\n    }\n\n    /// Get database connection\n    fn connect(\u0026self) -\u003e Result\u003cConnection\u003e {\n        Connection::open(\u0026self.db_path)\n            .context(\"Failed to open database connection\")\n    }\n\n    /// Initialize database schema\n    fn init_schema(\u0026self) -\u003e Result\u003c()\u003e {\n        let conn = self.connect()?;\n\n        conn.execute(\n            \"CREATE TABLE IF NOT EXISTS sessions (\n                id TEXT PRIMARY KEY,\n                name TEXT NOT NULL,\n                created_at INTEGER NOT NULL,\n                last_attached INTEGER NOT NULL,\n                cols INTEGER NOT NULL DEFAULT 80,\n                rows INTEGER NOT NULL DEFAULT 24\n            )\",\n            [],\n        )?;\n\n        // Index for faster lookups by name\n        conn.execute(\n            \"CREATE INDEX IF NOT EXISTS idx_sessions_name ON sessions(name)\",\n            [],\n        )?;\n\n        log::info!(\"Session database initialized at: {:?}\", self.db_path);\n        Ok(())\n    }\n\n    /// Save a session to the database\n    pub fn save_session(\u0026self, session: \u0026Session) -\u003e Result\u003c()\u003e {\n        let conn = self.connect()?;\n\n        let created_at = session.created_at\n            .duration_since(UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_secs() as i64;\n\n        let last_attached = session.last_attached.read()\n            .duration_since(UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_secs() as i64;\n\n        let grid_state = session.grid_state.read();\n\n        conn.execute(\n            \"INSERT OR REPLACE INTO sessions (id, name, created_at, last_attached, cols, rows)\n             VALUES (?1, ?2, ?3, ?4, ?5, ?6)\",\n            params![\n                \u0026session.id,\n                \u0026session.name,\n                created_at,\n                last_attached,\n                grid_state.cols as i64,\n                grid_state.rows as i64,\n            ],\n        )?;\n\n        Ok(())\n    }\n\n    /// Load all sessions from the database\n    pub fn load_sessions(\u0026self) -\u003e Result\u003cVec\u003cSession\u003e\u003e {\n        let conn = self.connect()?;\n\n        let mut stmt = conn.prepare(\n            \"SELECT id, name, created_at, last_attached FROM sessions ORDER BY last_attached DESC\"\n        )?;\n\n        let sessions = stmt.query_map([], |row| {\n            let id: String = row.get(0)?;\n            let name: String = row.get(1)?;\n            let created_at: i64 = row.get(2)?;\n            let last_attached: i64 = row.get(3)?;\n\n            Ok((id, name, created_at, last_attached))\n        })?\n        .filter_map(|r| r.ok())\n        .map(|(id, name, created_at, last_attached)| {\n            let created = UNIX_EPOCH + std::time::Duration::from_secs(created_at as u64);\n            let attached = UNIX_EPOCH + std::time::Duration::from_secs(last_attached as u64);\n\n            Session::restore(id, name, created, attached)\n        })\n        .collect();\n\n        Ok(sessions)\n    }\n\n    /// Delete a session from the database\n    pub fn delete_session(\u0026self, id: \u0026SessionId) -\u003e Result\u003c()\u003e {\n        let conn = self.connect()?;\n\n        conn.execute(\"DELETE FROM sessions WHERE id = ?1\", params![id])?;\n\n        log::info!(\"Deleted session from storage: {}\", id);\n        Ok(())\n    }\n\n    /// Update last attached timestamp\n    pub fn update_last_attached(\u0026self, id: \u0026SessionId) -\u003e Result\u003c()\u003e {\n        let conn = self.connect()?;\n\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_secs() as i64;\n\n        conn.execute(\n            \"UPDATE sessions SET last_attached = ?1 WHERE id = ?2\",\n            params![now, id],\n        )?;\n\n        Ok(())\n    }\n\n    /// Rename a session\n    pub fn rename_session(\u0026self, id: \u0026SessionId, new_name: \u0026str) -\u003e Result\u003c()\u003e {\n        let conn = self.connect()?;\n\n        conn.execute(\n            \"UPDATE sessions SET name = ?1 WHERE id = ?2\",\n            params![new_name, id],\n        )?;\n\n        log::info!(\"Renamed session {} to {}\", id, new_name);\n        Ok(())\n    }\n\n    /// Get session by ID\n    pub fn get_session(\u0026self, id: \u0026SessionId) -\u003e Result\u003cOption\u003cSession\u003e\u003e {\n        let conn = self.connect()?;\n\n        let result = conn.query_row(\n            \"SELECT id, name, created_at, last_attached FROM sessions WHERE id = ?1\",\n            params![id],\n            |row| {\n                let id: String = row.get(0)?;\n                let name: String = row.get(1)?;\n                let created_at: i64 = row.get(2)?;\n                let last_attached: i64 = row.get(3)?;\n\n                Ok((id, name, created_at, last_attached))\n            },\n        )\n        .optional()?;\n\n        if let Some((id, name, created_at, last_attached)) = result {\n            let created = UNIX_EPOCH + std::time::Duration::from_secs(created_at as u64);\n            let attached = UNIX_EPOCH + std::time::Duration::from_secs(last_attached as u64);\n\n            Ok(Some(Session::restore(id, name, created, attached)))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Get session count\n    pub fn session_count(\u0026self) -\u003e Result\u003cusize\u003e {\n        let conn = self.connect()?;\n\n        let count: i64 = conn.query_row(\n            \"SELECT COUNT(*) FROM sessions\",\n            [],\n            |row| row.get(0),\n        )?;\n\n        Ok(count as usize)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_session_store_lifecycle() {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().join(\"test.db\");\n\n        let store = SessionStore::new(db_path).unwrap();\n\n        // Create and save a session\n        let session = Session::new(\"test\".to_string(), 80, 24).unwrap();\n        store.save_session(\u0026session).unwrap();\n\n        // Load sessions\n        let sessions = store.load_sessions().unwrap();\n        assert_eq!(sessions.len(), 1);\n        assert_eq!(sessions[0].name, \"test\");\n\n        // Delete session\n        store.delete_session(\u0026session.id).unwrap();\n        let sessions = store.load_sessions().unwrap();\n        assert_eq!(sessions.len(), 0);\n    }\n\n    #[test]\n    fn test_session_rename() {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().join(\"test.db\");\n\n        let store = SessionStore::new(db_path).unwrap();\n\n        let session = Session::new(\"old_name\".to_string(), 80, 24).unwrap();\n        store.save_session(\u0026session).unwrap();\n\n        store.rename_session(\u0026session.id, \"new_name\").unwrap();\n\n        let loaded = store.get_session(\u0026session.id).unwrap().unwrap();\n        assert_eq!(loaded.name, \"new_name\");\n    }\n\n    #[test]\n    fn test_last_attached_update() {\n        let temp_dir = TempDir::new().unwrap();\n        let db_path = temp_dir.path().join(\"test.db\");\n\n        let store = SessionStore::new(db_path).unwrap();\n\n        let session = Session::new(\"test\".to_string(), 80, 24).unwrap();\n        let id = session.id.clone();\n        store.save_session(\u0026session).unwrap();\n\n        // Get initial timestamp from DB (which has second precision)\n        let initial_loaded = store.get_session(\u0026id).unwrap().unwrap();\n        let initial_attached = *initial_loaded.last_attached.read();\n\n        // Wait for at least 1 second (SQLite stores timestamps with second precision)\n        std::thread::sleep(std::time::Duration::from_secs(1));\n\n        store.update_last_attached(\u0026id).unwrap();\n\n        // Verify timestamp was updated in DB\n        let loaded = store.get_session(\u0026id).unwrap().unwrap();\n        let loaded_attached = *loaded.last_attached.read();\n\n        // The loaded timestamp should be at least 1 second later\n        assert!(\n            loaded_attached \u003e initial_attached,\n            \"Expected loaded timestamp ({:?}) to be later than initial ({:?})\",\n            loaded_attached, initial_attached\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","tests","mod.rs"],"content":"// Test module for scarab-daemon\nmod vte_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","tests","vte_tests.rs"],"content":"/// Comprehensive unit tests for VTE parser integration\n///\n/// Tests cover:\n/// - Basic text printing\n/// - ANSI color codes (8, 16, 256 colors)\n/// - Cursor movement and positioning\n/// - Screen clearing and line clearing\n/// - Text attributes (bold, italic, underline, inverse)\n/// - Scrollback buffer\n/// - UTF-8 multibyte characters\n/// - Edge cases and error handling\n\n#[cfg(test)]\nmod tests {\n    use crate::vte::*;\n    use scarab_protocol::{SharedState, Cell, GRID_WIDTH, GRID_HEIGHT, BUFFER_SIZE};\n    use std::sync::atomic::{AtomicU64, Ordering};\n    use std::sync::Arc;\n\n    /// Helper to create a test terminal state\n    fn create_test_terminal() -\u003e (*mut SharedState, TerminalState, Box\u003cSharedState\u003e) {\n        let mut state = Box::new(unsafe { std::mem::zeroed::\u003cSharedState\u003e() });\n        let ptr = state.as_mut() as *mut SharedState;\n        let sequence_counter = Arc::new(AtomicU64::new(0));\n        let terminal = TerminalState::new(ptr, sequence_counter);\n        (ptr, terminal, state)\n    }\n\n    /// Helper to get cell content at position\n    fn get_cell(state: \u0026SharedState, x: usize, y: usize) -\u003e \u0026Cell {\n        let idx = y * GRID_WIDTH + x;\n        \u0026state.cells[idx]\n    }\n\n    #[test]\n    fn test_basic_text_printing() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Print \"Hello\"\n        terminal.process_output(b\"Hello\");\n\n        // Verify characters were written\n        assert_eq!(get_cell(\u0026state, 0, 0).char_codepoint, 'H' as u32);\n        assert_eq!(get_cell(\u0026state, 1, 0).char_codepoint, 'e' as u32);\n        assert_eq!(get_cell(\u0026state, 2, 0).char_codepoint, 'l' as u32);\n        assert_eq!(get_cell(\u0026state, 3, 0).char_codepoint, 'l' as u32);\n        assert_eq!(get_cell(\u0026state, 4, 0).char_codepoint, 'o' as u32);\n\n        // Cursor should be at position 5\n        assert_eq!(state.cursor_x, 5);\n        assert_eq!(state.cursor_y, 0);\n    }\n\n    #[test]\n    fn test_newline_and_carriage_return() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Print \"Line1\\nLine2\\n\"\n        terminal.process_output(b\"Line1\\nLine2\\n\");\n\n        // Verify first line\n        assert_eq!(get_cell(\u0026state, 0, 0).char_codepoint, 'L' as u32);\n        assert_eq!(get_cell(\u0026state, 4, 0).char_codepoint, '1' as u32);\n\n        // Verify second line\n        assert_eq!(get_cell(\u0026state, 0, 1).char_codepoint, 'L' as u32);\n        assert_eq!(get_cell(\u0026state, 4, 1).char_codepoint, '2' as u32);\n\n        // Cursor should be on line 3\n        assert_eq!(state.cursor_y, 2);\n    }\n\n    #[test]\n    fn test_carriage_return() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Print \"Hello\\rWorld\"\n        terminal.process_output(b\"Hello\\rWorld\");\n\n        // \"World\" should overwrite \"Hello\" at the beginning\n        assert_eq!(get_cell(\u0026state, 0, 0).char_codepoint, 'W' as u32);\n        assert_eq!(get_cell(\u0026state, 1, 0).char_codepoint, 'o' as u32);\n        assert_eq!(get_cell(\u0026state, 2, 0).char_codepoint, 'r' as u32);\n        assert_eq!(get_cell(\u0026state, 3, 0).char_codepoint, 'l' as u32);\n        assert_eq!(get_cell(\u0026state, 4, 0).char_codepoint, 'd' as u32);\n\n        // Cursor should be at position 5\n        assert_eq!(state.cursor_x, 5);\n    }\n\n    #[test]\n    fn test_ansi_colors() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Red text\n        terminal.process_output(b\"\\x1b[31mRed\\x1b[0m\");\n\n        // Check that \"Red\" has red foreground color\n        let red_cell = get_cell(\u0026state, 0, 0);\n        assert_eq!(red_cell.char_codepoint, 'R' as u32);\n        assert_eq!(red_cell.fg, 0xFFCD0000); // Red color\n\n        // After reset, should use default color\n        terminal.process_output(b\"Normal\");\n        let normal_cell = get_cell(\u0026state, 3, 0);\n        assert_eq!(normal_cell.fg, 0xFFCCCCCC); // Default foreground\n    }\n\n    #[test]\n    fn test_bright_colors() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Bright red text\n        terminal.process_output(b\"\\x1b[91mBrightRed\\x1b[0m\");\n\n        // Check bright red color\n        let cell = get_cell(\u0026state, 0, 0);\n        assert_eq!(cell.fg, 0xFFFF0000); // Bright red\n    }\n\n    #[test]\n    fn test_256_colors() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // 256-color mode (color index 196 = bright red)\n        terminal.process_output(b\"\\x1b[38;5;196mColor\\x1b[0m\");\n\n        // Verify the character was written\n        let cell = get_cell(\u0026state, 0, 0);\n        assert_eq!(cell.char_codepoint, 'C' as u32);\n        // Color should be non-default\n        assert_ne!(cell.fg, 0xFFCCCCCC);\n    }\n\n    #[test]\n    fn test_background_colors() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Blue background\n        terminal.process_output(b\"\\x1b[44mBlue BG\\x1b[0m\");\n\n        // Check background color\n        let cell = get_cell(\u0026state, 0, 0);\n        assert_eq!(cell.bg, 0xFF0000EE); // Blue background\n    }\n\n    #[test]\n    fn test_text_attributes() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Bold text\n        terminal.process_output(b\"\\x1b[1mBold\\x1b[0m\");\n        let bold_cell = get_cell(\u0026state, 0, 0);\n        assert_eq!(bold_cell.flags \u0026 FLAG_BOLD, FLAG_BOLD);\n\n        // Italic text\n        terminal.process_output(b\" \\x1b[3mItalic\\x1b[0m\");\n        let italic_cell = get_cell(\u0026state, 5, 0);\n        assert_eq!(italic_cell.flags \u0026 FLAG_ITALIC, FLAG_ITALIC);\n\n        // Underline text\n        terminal.process_output(b\" \\x1b[4mUnder\\x1b[0m\");\n        let under_cell = get_cell(\u0026state, 12, 0);\n        assert_eq!(under_cell.flags \u0026 FLAG_UNDERLINE, FLAG_UNDERLINE);\n    }\n\n    #[test]\n    fn test_cursor_movement() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Move cursor to position (5, 3)\n        terminal.process_output(b\"\\x1b[4;6H\");\n\n        assert_eq!(state.cursor_x, 5);\n        assert_eq!(state.cursor_y, 3);\n\n        // Write at that position\n        terminal.process_output(b\"X\");\n        let cell = get_cell(\u0026state, 5, 3);\n        assert_eq!(cell.char_codepoint, 'X' as u32);\n    }\n\n    #[test]\n    fn test_cursor_up_down_left_right() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Start at (0, 0), move down 5 times\n        terminal.process_output(b\"\\x1b[5B\");\n        assert_eq!(state.cursor_y, 5);\n\n        // Move right 10 times\n        terminal.process_output(b\"\\x1b[10C\");\n        assert_eq!(state.cursor_x, 10);\n\n        // Move up 2 times\n        terminal.process_output(b\"\\x1b[2A\");\n        assert_eq!(state.cursor_y, 3);\n\n        // Move left 5 times\n        terminal.process_output(b\"\\x1b[5D\");\n        assert_eq!(state.cursor_x, 5);\n    }\n\n    #[test]\n    fn test_clear_screen() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Fill screen with text\n        terminal.process_output(b\"Hello World\");\n\n        // Clear screen\n        terminal.process_output(b\"\\x1b[2J\");\n\n        // All cells should be empty\n        for y in 0..GRID_HEIGHT {\n            for x in 0..GRID_WIDTH {\n                let cell = get_cell(\u0026state, x, y);\n                assert_eq!(cell.char_codepoint, 0);\n            }\n        }\n\n        // Cursor should be at origin\n        assert_eq!(state.cursor_x, 0);\n        assert_eq!(state.cursor_y, 0);\n    }\n\n    #[test]\n    fn test_clear_line() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Write a line\n        terminal.process_output(b\"Hello World\");\n\n        // Move cursor back\n        terminal.process_output(b\"\\x1b[6D\");\n\n        // Clear to end of line\n        terminal.process_output(b\"\\x1b[K\");\n\n        // \"Hello \" should remain, \"World\" should be cleared\n        assert_eq!(get_cell(\u0026state, 0, 0).char_codepoint, 'H' as u32);\n        assert_eq!(get_cell(\u0026state, 5, 0).char_codepoint, ' ' as u32);\n        assert_eq!(get_cell(\u0026state, 6, 0).char_codepoint, 0);\n    }\n\n    #[test]\n    fn test_save_restore_cursor() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Move to (10, 5)\n        terminal.process_output(b\"\\x1b[6;11H\");\n\n        // Save cursor position\n        terminal.process_output(b\"\\x1b[s\");\n\n        // Move elsewhere\n        terminal.process_output(b\"\\x1b[1;1H\");\n        assert_eq!(state.cursor_x, 0);\n        assert_eq!(state.cursor_y, 0);\n\n        // Restore cursor\n        terminal.process_output(b\"\\x1b[u\");\n        assert_eq!(state.cursor_x, 10);\n        assert_eq!(state.cursor_y, 5);\n    }\n\n    #[test]\n    fn test_line_wrapping() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Create a string longer than screen width\n        let long_text = \"A\".repeat(GRID_WIDTH + 10);\n        terminal.process_output(long_text.as_bytes());\n\n        // First line should be full\n        for x in 0..GRID_WIDTH {\n            assert_eq!(get_cell(\u0026state, x, 0).char_codepoint, 'A' as u32);\n        }\n\n        // Text should wrap to second line\n        for x in 0..10 {\n            assert_eq!(get_cell(\u0026state, x, 1).char_codepoint, 'A' as u32);\n        }\n    }\n\n    #[test]\n    fn test_scrolling() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Fill screen with numbered lines\n        for i in 0..GRID_HEIGHT + 5 {\n            terminal.process_output(format!(\"Line {}\\n\", i).as_bytes());\n        }\n\n        // First line should contain \"Line 5\" (lines 0-4 scrolled off)\n        assert_eq!(get_cell(\u0026state, 0, 0).char_codepoint, 'L' as u32);\n\n        // Cursor should be near bottom\n        assert!(state.cursor_y \u003e= GRID_HEIGHT as u16 - 10);\n    }\n\n    #[test]\n    fn test_utf8_characters() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Test various UTF-8 characters\n        terminal.process_output(\"Hello ! \".as_bytes());\n\n        // Verify ASCII characters\n        assert_eq!(get_cell(\u0026state, 0, 0).char_codepoint, 'H' as u32);\n\n        // Verify UTF-8 characters were stored\n        // Note: The actual positions may vary due to character width handling\n        let mut has_chinese = false;\n        for x in 0..20 {\n            let codepoint = get_cell(\u0026state, x, 0).char_codepoint;\n            if codepoint == '' as u32 || codepoint == '' as u32 {\n                has_chinese = true;\n                break;\n            }\n        }\n        assert!(has_chinese, \"Should contain Chinese characters\");\n    }\n\n    #[test]\n    fn test_tab_character() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Tab should advance to next tab stop (every 8 columns)\n        terminal.process_output(b\"A\\tB\");\n\n        assert_eq!(get_cell(\u0026state, 0, 0).char_codepoint, 'A' as u32);\n        assert_eq!(get_cell(\u0026state, 8, 0).char_codepoint, 'B' as u32);\n    }\n\n    #[test]\n    fn test_backspace() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        terminal.process_output(b\"Hello\\x08\\x08World\");\n\n        // \"World\" should overwrite last 2 chars of \"Hello\"\n        assert_eq!(get_cell(\u0026state, 0, 0).char_codepoint, 'H' as u32);\n        assert_eq!(get_cell(\u0026state, 1, 0).char_codepoint, 'e' as u32);\n        assert_eq!(get_cell(\u0026state, 2, 0).char_codepoint, 'l' as u32);\n        assert_eq!(get_cell(\u0026state, 3, 0).char_codepoint, 'W' as u32);\n    }\n\n    #[test]\n    fn test_combined_attributes() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Bold + Red + Underline\n        terminal.process_output(b\"\\x1b[1;31;4mBoldRedUnder\\x1b[0m\");\n\n        let cell = get_cell(\u0026state, 0, 0);\n        assert_eq!(cell.flags \u0026 FLAG_BOLD, FLAG_BOLD);\n        assert_eq!(cell.flags \u0026 FLAG_UNDERLINE, FLAG_UNDERLINE);\n        assert_eq!(cell.fg, 0xFFCD0000); // Red\n    }\n\n    #[test]\n    fn test_inverse_attribute() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Inverse text (swap fg/bg)\n        terminal.process_output(b\"\\x1b[7mInverse\\x1b[0m\");\n\n        let cell = get_cell(\u0026state, 0, 0);\n        assert_eq!(cell.flags \u0026 FLAG_INVERSE, FLAG_INVERSE);\n    }\n\n    #[test]\n    fn test_partial_escape_sequences() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Send escape sequence in chunks\n        terminal.process_output(b\"\\x1b\");\n        terminal.process_output(b\"[\");\n        terminal.process_output(b\"31\");\n        terminal.process_output(b\"m\");\n        terminal.process_output(b\"Red\");\n\n        let cell = get_cell(\u0026state, 0, 0);\n        assert_eq!(cell.char_codepoint, 'R' as u32);\n        assert_eq!(cell.fg, 0xFFCD0000); // Red\n    }\n\n    #[test]\n    fn test_dirty_flag_and_sequence() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        let initial_seq = state.sequence_number;\n\n        // Process some output\n        terminal.process_output(b\"Test\");\n\n        // Dirty flag should be set\n        assert_eq!(state.dirty_flag, 1);\n\n        // Sequence number should have incremented\n        assert!(state.sequence_number \u003e initial_seq);\n    }\n\n    #[test]\n    fn test_cursor_bounds_checking() {\n        let (_, mut terminal, state) = create_test_terminal();\n\n        // Try to move cursor beyond screen bounds\n        terminal.process_output(format!(\"\\x1b[1000;1000H\").as_bytes());\n\n        // Cursor should be clamped to screen size\n        assert!(state.cursor_x \u003c GRID_WIDTH as u16);\n        assert!(state.cursor_y \u003c GRID_HEIGHT as u16);\n    }\n\n    #[test]\n    fn test_large_output_performance() {\n        let (_, mut terminal, _state) = create_test_terminal();\n\n        // Generate large output (simulate scrolling)\n        let large_text = \"A\".repeat(100_000);\n\n        // This should not panic or cause performance issues\n        terminal.process_output(large_text.as_bytes());\n\n        // Test completed successfully if we reach here\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","src","vte.rs"],"content":"/// VTE (Virtual Terminal Emulator) Parser Integration\n///\n/// This module implements the VTE parser to handle ANSI escape sequences\n/// and update the SharedState grid with proper terminal emulation.\n///\n/// Features:\n/// - Parse ANSI/VT100 escape sequences\n/// - Handle cursor positioning and scrolling\n/// - Support colors and text attributes\n/// - UTF-8 multibyte character handling\n/// - Scrollback buffer (10k lines)\n\nuse vte::{Parser, Perform};\nuse scarab_protocol::{SharedState, Cell, GRID_WIDTH, GRID_HEIGHT};\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\nuse std::collections::VecDeque;\n\n/// Maximum scrollback buffer size (10,000 lines)\nconst SCROLLBACK_SIZE: usize = 10_000;\n\n/// Default colors\nconst DEFAULT_FG: u32 = 0xFFCCCCCC; // Light gray\nconst DEFAULT_BG: u32 = 0xFF000000; // Black\n\n/// Text attribute flags\npub const FLAG_BOLD: u8 = 1 \u003c\u003c 0;\npub const FLAG_ITALIC: u8 = 1 \u003c\u003c 1;\npub const FLAG_UNDERLINE: u8 = 1 \u003c\u003c 2;\npub const FLAG_INVERSE: u8 = 1 \u003c\u003c 3;\npub const FLAG_DIM: u8 = 1 \u003c\u003c 4;\n\n/// Current text attributes for rendering\n#[derive(Clone, Copy, Debug)]\nstruct TextAttributes {\n    fg: u32,\n    bg: u32,\n    flags: u8,\n}\n\nimpl Default for TextAttributes {\n    fn default() -\u003e Self {\n        Self {\n            fg: DEFAULT_FG,\n            bg: DEFAULT_BG,\n            flags: 0,\n        }\n    }\n}\n\n/// Terminal state manager that implements the VTE Perform trait\npub struct TerminalState {\n    /// Pointer to shared memory state\n    shared_ptr: *mut SharedState,\n    /// VTE parser instance\n    parser: Parser,\n    /// Current cursor position (0-indexed)\n    cursor_x: u16,\n    cursor_y: u16,\n    /// Current text attributes\n    attrs: TextAttributes,\n    /// Scrollback buffer (stores lines that scrolled off the top)\n    scrollback: VecDeque\u003cVec\u003cCell\u003e\u003e,\n    /// Sequence counter for atomic updates\n    sequence_counter: Arc\u003cAtomicU64\u003e,\n    /// Saved cursor position (for DECSC/DECRC)\n    saved_cursor: (u16, u16),\n    saved_attrs: TextAttributes,\n}\n\nimpl TerminalState {\n    /// Create a new terminal state manager\n    pub fn new(shared_ptr: *mut SharedState, sequence_counter: Arc\u003cAtomicU64\u003e) -\u003e Self {\n        Self {\n            shared_ptr,\n            parser: Parser::new(),\n            cursor_x: 0,\n            cursor_y: 0,\n            attrs: TextAttributes::default(),\n            scrollback: VecDeque::with_capacity(SCROLLBACK_SIZE),\n            sequence_counter,\n            saved_cursor: (0, 0),\n            saved_attrs: TextAttributes::default(),\n        }\n    }\n\n    /// Process PTY output through the VTE parser\n    pub fn process_output(\u0026mut self, data: \u0026[u8]) {\n        // Take ownership of the parser temporarily to satisfy borrow checker\n        let mut parser = std::mem::replace(\u0026mut self.parser, vte::Parser::new());\n\n        for byte in data {\n            parser.advance(self, *byte);\n        }\n\n        // Restore the parser\n        self.parser = parser;\n        self.mark_dirty();\n    }\n\n    /// Mark shared state as dirty and increment sequence number\n    fn mark_dirty(\u0026mut self) {\n        unsafe {\n            let state = \u0026mut *self.shared_ptr;\n            state.dirty_flag = 1;\n            state.cursor_x = self.cursor_x;\n            state.cursor_y = self.cursor_y;\n            let new_seq = self.sequence_counter.fetch_add(1, Ordering::SeqCst) + 1;\n            state.sequence_number = new_seq;\n        }\n    }\n\n    /// Write a character at the current cursor position\n    fn write_char(\u0026mut self, c: char) {\n        if self.cursor_x \u003e= GRID_WIDTH as u16 {\n            // Handle line wrapping\n            self.cursor_x = 0;\n            self.cursor_y += 1;\n        }\n\n        if self.cursor_y \u003e= GRID_HEIGHT as u16 {\n            // Scroll up\n            self.scroll_up(1);\n        }\n\n        let index = (self.cursor_y as usize * GRID_WIDTH) + self.cursor_x as usize;\n\n        unsafe {\n            let state = \u0026mut *self.shared_ptr;\n            if index \u003c state.cells.len() {\n                state.cells[index] = Cell {\n                    char_codepoint: c as u32,\n                    fg: self.attrs.fg,\n                    bg: self.attrs.bg,\n                    flags: self.attrs.flags,\n                    _padding: [0; 3],\n                };\n            }\n        }\n\n        self.cursor_x += 1;\n    }\n\n    /// Scroll the screen up by n lines\n    fn scroll_up(\u0026mut self, lines: usize) {\n        unsafe {\n            let state = \u0026mut *self.shared_ptr;\n\n            // Save scrolled lines to scrollback buffer\n            for i in 0..lines {\n                if i \u003e= GRID_HEIGHT {\n                    break;\n                }\n                let mut line = Vec::with_capacity(GRID_WIDTH);\n                for x in 0..GRID_WIDTH {\n                    let idx = i * GRID_WIDTH + x;\n                    line.push(state.cells[idx]);\n                }\n                self.scrollback.push_back(line);\n\n                // Limit scrollback buffer size\n                if self.scrollback.len() \u003e SCROLLBACK_SIZE {\n                    self.scrollback.pop_front();\n                }\n            }\n\n            // Shift grid content up\n            for y in 0..(GRID_HEIGHT - lines) {\n                for x in 0..GRID_WIDTH {\n                    let src_idx = (y + lines) * GRID_WIDTH + x;\n                    let dst_idx = y * GRID_WIDTH + x;\n                    state.cells[dst_idx] = state.cells[src_idx];\n                }\n            }\n\n            // Clear the bottom lines\n            for y in (GRID_HEIGHT - lines)..GRID_HEIGHT {\n                for x in 0..GRID_WIDTH {\n                    let idx = y * GRID_WIDTH + x;\n                    state.cells[idx] = Cell {\n                        char_codepoint: 0,\n                        fg: DEFAULT_FG,\n                        bg: DEFAULT_BG,\n                        flags: 0,\n                        _padding: [0; 3],\n                    };\n                }\n            }\n\n            // Adjust cursor position\n            if self.cursor_y \u003e= lines as u16 {\n                self.cursor_y -= lines as u16;\n            } else {\n                self.cursor_y = 0;\n            }\n        }\n    }\n\n    /// Clear the screen\n    fn clear_screen(\u0026mut self) {\n        unsafe {\n            let state = \u0026mut *self.shared_ptr;\n            for cell in state.cells.iter_mut() {\n                *cell = Cell {\n                    char_codepoint: 0,\n                    fg: DEFAULT_FG,\n                    bg: DEFAULT_BG,\n                    flags: 0,\n                    _padding: [0; 3],\n                };\n            }\n        }\n        self.cursor_x = 0;\n        self.cursor_y = 0;\n    }\n\n    /// Clear from cursor to end of line\n    fn clear_to_eol(\u0026mut self) {\n        unsafe {\n            let state = \u0026mut *self.shared_ptr;\n            for x in self.cursor_x as usize..GRID_WIDTH {\n                let idx = self.cursor_y as usize * GRID_WIDTH + x;\n                state.cells[idx] = Cell {\n                    char_codepoint: 0,\n                    fg: DEFAULT_FG,\n                    bg: DEFAULT_BG,\n                    flags: 0,\n                    _padding: [0; 3],\n                };\n            }\n        }\n    }\n\n    /// Set SGR (Select Graphic Rendition) attributes\n    fn set_sgr(\u0026mut self, params: \u0026[i64]) {\n        if params.is_empty() {\n            // Reset all attributes\n            self.attrs = TextAttributes::default();\n            return;\n        }\n\n        let mut i = 0;\n        while i \u003c params.len() {\n            match params[i] {\n                0 =\u003e self.attrs = TextAttributes::default(),\n                1 =\u003e self.attrs.flags |= FLAG_BOLD,\n                2 =\u003e self.attrs.flags |= FLAG_DIM,\n                3 =\u003e self.attrs.flags |= FLAG_ITALIC,\n                4 =\u003e self.attrs.flags |= FLAG_UNDERLINE,\n                7 =\u003e self.attrs.flags |= FLAG_INVERSE,\n                22 =\u003e self.attrs.flags \u0026= !(FLAG_BOLD | FLAG_DIM),\n                23 =\u003e self.attrs.flags \u0026= !FLAG_ITALIC,\n                24 =\u003e self.attrs.flags \u0026= !FLAG_UNDERLINE,\n                27 =\u003e self.attrs.flags \u0026= !FLAG_INVERSE,\n\n                // Foreground colors (30-37, 90-97)\n                30..=37 =\u003e self.attrs.fg = ansi_color_to_rgba(params[i] as u8 - 30),\n                90..=97 =\u003e self.attrs.fg = ansi_bright_color_to_rgba(params[i] as u8 - 90),\n\n                // Background colors (40-47, 100-107)\n                40..=47 =\u003e self.attrs.bg = ansi_color_to_rgba(params[i] as u8 - 40),\n                100..=107 =\u003e self.attrs.bg = ansi_bright_color_to_rgba(params[i] as u8 - 100),\n\n                // 256-color mode (38;5;n for fg, 48;5;n for bg)\n                38 | 48 =\u003e {\n                    if i + 2 \u003c params.len() \u0026\u0026 params[i + 1] == 5 {\n                        let color = color_256_to_rgba(params[i + 2] as u8);\n                        if params[i] == 38 {\n                            self.attrs.fg = color;\n                        } else {\n                            self.attrs.bg = color;\n                        }\n                        i += 2;\n                    }\n                }\n\n                // Default colors\n                39 =\u003e self.attrs.fg = DEFAULT_FG,\n                49 =\u003e self.attrs.bg = DEFAULT_BG,\n\n                _ =\u003e {} // Ignore unknown codes\n            }\n            i += 1;\n        }\n    }\n}\n\nimpl Perform for TerminalState {\n    fn print(\u0026mut self, c: char) {\n        self.write_char(c);\n    }\n\n    fn execute(\u0026mut self, byte: u8) {\n        match byte {\n            0x08 =\u003e {\n                // Backspace\n                if self.cursor_x \u003e 0 {\n                    self.cursor_x -= 1;\n                }\n            }\n            0x09 =\u003e {\n                // Tab (move to next tab stop, typically 8 spaces)\n                self.cursor_x = ((self.cursor_x / 8) + 1) * 8;\n                if self.cursor_x \u003e= GRID_WIDTH as u16 {\n                    self.cursor_x = 0;\n                    self.cursor_y += 1;\n                }\n            }\n            0x0A =\u003e {\n                // Line Feed\n                self.cursor_y += 1;\n                if self.cursor_y \u003e= GRID_HEIGHT as u16 {\n                    self.scroll_up(1);\n                }\n            }\n            0x0D =\u003e {\n                // Carriage Return\n                self.cursor_x = 0;\n            }\n            _ =\u003e {}\n        }\n    }\n\n    fn hook(\u0026mut self, _params: \u0026vte::Params, _intermediates: \u0026[u8], _ignore: bool, _action: char) {}\n\n    fn put(\u0026mut self, _byte: u8) {}\n\n    fn unhook(\u0026mut self) {}\n\n    fn osc_dispatch(\u0026mut self, _params: \u0026[\u0026[u8]], _bell_terminated: bool) {}\n\n    fn csi_dispatch(\n        \u0026mut self,\n        params: \u0026vte::Params,\n        _intermediates: \u0026[u8],\n        _ignore: bool,\n        action: char,\n    ) {\n        let params: Vec\u003ci64\u003e = params.iter().map(|p| p[0] as i64).collect();\n\n        match action {\n            'A' =\u003e {\n                // Cursor Up\n                let n = params.get(0).copied().unwrap_or(1).max(1) as u16;\n                self.cursor_y = self.cursor_y.saturating_sub(n);\n            }\n            'B' =\u003e {\n                // Cursor Down\n                let n = params.get(0).copied().unwrap_or(1).max(1) as u16;\n                self.cursor_y = (self.cursor_y + n).min(GRID_HEIGHT as u16 - 1);\n            }\n            'C' =\u003e {\n                // Cursor Forward\n                let n = params.get(0).copied().unwrap_or(1).max(1) as u16;\n                self.cursor_x = (self.cursor_x + n).min(GRID_WIDTH as u16 - 1);\n            }\n            'D' =\u003e {\n                // Cursor Back\n                let n = params.get(0).copied().unwrap_or(1).max(1) as u16;\n                self.cursor_x = self.cursor_x.saturating_sub(n);\n            }\n            'H' | 'f' =\u003e {\n                // Cursor Position\n                let row = params.get(0).copied().unwrap_or(1).max(1) as u16 - 1;\n                let col = params.get(1).copied().unwrap_or(1).max(1) as u16 - 1;\n                self.cursor_y = row.min(GRID_HEIGHT as u16 - 1);\n                self.cursor_x = col.min(GRID_WIDTH as u16 - 1);\n            }\n            'J' =\u003e {\n                // Erase in Display\n                let n = params.get(0).copied().unwrap_or(0);\n                match n {\n                    0 =\u003e {\n                        // Clear from cursor to end of screen\n                        self.clear_to_eol();\n                        for y in (self.cursor_y as usize + 1)..GRID_HEIGHT {\n                            for x in 0..GRID_WIDTH {\n                                unsafe {\n                                    let state = \u0026mut *self.shared_ptr;\n                                    let idx = y * GRID_WIDTH + x;\n                                    state.cells[idx] = Cell::default();\n                                }\n                            }\n                        }\n                    }\n                    1 =\u003e {\n                        // Clear from cursor to beginning of screen\n                        for y in 0..self.cursor_y as usize {\n                            for x in 0..GRID_WIDTH {\n                                unsafe {\n                                    let state = \u0026mut *self.shared_ptr;\n                                    let idx = y * GRID_WIDTH + x;\n                                    state.cells[idx] = Cell::default();\n                                }\n                            }\n                        }\n                    }\n                    2 =\u003e {\n                        // Clear entire screen\n                        self.clear_screen();\n                    }\n                    _ =\u003e {}\n                }\n            }\n            'K' =\u003e {\n                // Erase in Line\n                let n = params.get(0).copied().unwrap_or(0);\n                match n {\n                    0 =\u003e self.clear_to_eol(),\n                    1 =\u003e {\n                        // Clear from beginning of line to cursor\n                        unsafe {\n                            let state = \u0026mut *self.shared_ptr;\n                            for x in 0..=self.cursor_x as usize {\n                                let idx = self.cursor_y as usize * GRID_WIDTH + x;\n                                state.cells[idx] = Cell::default();\n                            }\n                        }\n                    }\n                    2 =\u003e {\n                        // Clear entire line\n                        unsafe {\n                            let state = \u0026mut *self.shared_ptr;\n                            for x in 0..GRID_WIDTH {\n                                let idx = self.cursor_y as usize * GRID_WIDTH + x;\n                                state.cells[idx] = Cell::default();\n                            }\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n            'm' =\u003e {\n                // SGR (Select Graphic Rendition)\n                self.set_sgr(\u0026params);\n            }\n            's' =\u003e {\n                // Save cursor position (DECSC)\n                self.saved_cursor = (self.cursor_x, self.cursor_y);\n                self.saved_attrs = self.attrs;\n            }\n            'u' =\u003e {\n                // Restore cursor position (DECRC)\n                self.cursor_x = self.saved_cursor.0;\n                self.cursor_y = self.saved_cursor.1;\n                self.attrs = self.saved_attrs;\n            }\n            _ =\u003e {}\n        }\n    }\n\n    fn esc_dispatch(\u0026mut self, _intermediates: \u0026[u8], _ignore: bool, _byte: u8) {}\n}\n\n/// Convert ANSI color index (0-7) to RGBA\nfn ansi_color_to_rgba(index: u8) -\u003e u32 {\n    match index {\n        0 =\u003e 0xFF000000, // Black\n        1 =\u003e 0xFFCD0000, // Red\n        2 =\u003e 0xFF00CD00, // Green\n        3 =\u003e 0xFFCDCD00, // Yellow\n        4 =\u003e 0xFF0000EE, // Blue\n        5 =\u003e 0xFFCD00CD, // Magenta\n        6 =\u003e 0xFF00CDCD, // Cyan\n        7 =\u003e 0xFFE5E5E5, // White\n        _ =\u003e DEFAULT_FG,\n    }\n}\n\n/// Convert ANSI bright color index (0-7) to RGBA\nfn ansi_bright_color_to_rgba(index: u8) -\u003e u32 {\n    match index {\n        0 =\u003e 0xFF7F7F7F, // Bright Black (Gray)\n        1 =\u003e 0xFFFF0000, // Bright Red\n        2 =\u003e 0xFF00FF00, // Bright Green\n        3 =\u003e 0xFFFFFF00, // Bright Yellow\n        4 =\u003e 0xFF5C5CFF, // Bright Blue\n        5 =\u003e 0xFFFF00FF, // Bright Magenta\n        6 =\u003e 0xFF00FFFF, // Bright Cyan\n        7 =\u003e 0xFFFFFFFF, // Bright White\n        _ =\u003e DEFAULT_FG,\n    }\n}\n\n/// Convert 256-color palette index to RGBA\nfn color_256_to_rgba(index: u8) -\u003e u32 {\n    match index {\n        // 0-15: Standard ANSI colors\n        0..=7 =\u003e ansi_color_to_rgba(index),\n        8..=15 =\u003e ansi_bright_color_to_rgba(index - 8),\n\n        // 16-231: 6x6x6 color cube\n        16..=231 =\u003e {\n            let idx = index - 16;\n            let r = (idx / 36) * 51;\n            let g = ((idx % 36) / 6) * 51;\n            let b = (idx % 6) * 51;\n            0xFF000000 | ((r as u32) \u003c\u003c 16) | ((g as u32) \u003c\u003c 8) | (b as u32)\n        }\n\n        // 232-255: Grayscale\n        232..=255 =\u003e {\n            let gray = 8 + (index - 232) * 10;\n            0xFF000000 | ((gray as u32) \u003c\u003c 16) | ((gray as u32) \u003c\u003c 8) | (gray as u32)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ansi_color_conversion() {\n        assert_eq!(ansi_color_to_rgba(0), 0xFF000000); // Black\n        assert_eq!(ansi_color_to_rgba(1), 0xFFCD0000); // Red\n        assert_eq!(ansi_color_to_rgba(7), 0xFFE5E5E5); // White\n    }\n\n    #[test]\n    fn test_256_color_conversion() {\n        // Test standard colors\n        assert_eq!(color_256_to_rgba(0), ansi_color_to_rgba(0));\n\n        // Test grayscale\n        let gray = color_256_to_rgba(232);\n        assert!(gray != 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","tests","ipc_integration.rs"],"content":"use anyhow::Result;\nuse scarab_protocol::{ControlMessage, SOCKET_PATH, MAX_MESSAGE_SIZE};\nuse std::time::Duration;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::UnixStream;\nuse tokio::time::{sleep, timeout};\n\n/// Helper function to connect to daemon with timeout\nasync fn connect_with_timeout() -\u003e Result\u003cUnixStream\u003e {\n    timeout(Duration::from_secs(5), UnixStream::connect(SOCKET_PATH))\n        .await?\n        .map_err(Into::into)\n}\n\n/// Helper function to send a message\nasync fn send_message(stream: \u0026mut UnixStream, msg: ControlMessage) -\u003e Result\u003c()\u003e {\n    let bytes = rkyv::to_bytes::\u003c_, MAX_MESSAGE_SIZE\u003e(\u0026msg)?;\n    let len = bytes.len();\n\n    stream.write_u32(len as u32).await?;\n    stream.write_all(\u0026bytes).await?;\n    stream.flush().await?;\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_single_client_connection() -\u003e Result\u003c()\u003e {\n    // This test assumes daemon is running\n    let stream = connect_with_timeout().await?;\n    assert!(stream.peer_addr().is_ok());\n    println!(\" Single client connected successfully\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_send_resize_message() -\u003e Result\u003c()\u003e {\n    let mut stream = connect_with_timeout().await?;\n\n    let msg = ControlMessage::Resize {\n        cols: 120,\n        rows: 40,\n    };\n\n    send_message(\u0026mut stream, msg).await?;\n    println!(\" Resize message sent successfully\");\n\n    // Give daemon time to process\n    sleep(Duration::from_millis(100)).await;\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_send_input_message() -\u003e Result\u003c()\u003e {\n    let mut stream = connect_with_timeout().await?;\n\n    let msg = ControlMessage::Input {\n        data: b\"echo 'Hello from test'\\n\".to_vec(),\n    };\n\n    send_message(\u0026mut stream, msg).await?;\n    println!(\" Input message sent successfully\");\n\n    sleep(Duration::from_millis(100)).await;\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_multiple_messages() -\u003e Result\u003c()\u003e {\n    let mut stream = connect_with_timeout().await?;\n\n    // Send multiple messages in sequence\n    for i in 0..10 {\n        let msg = ControlMessage::Input {\n            data: format!(\"test message {}\\n\", i).into_bytes(),\n        };\n        send_message(\u0026mut stream, msg).await?;\n    }\n\n    println!(\" Multiple messages sent successfully\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_multiple_concurrent_clients() -\u003e Result\u003c()\u003e {\n    let mut handles = vec![];\n\n    // Connect multiple clients\n    for i in 0..5 {\n        let handle = tokio::spawn(async move {\n            let mut stream = connect_with_timeout().await?;\n\n            let msg = ControlMessage::Ping {\n                timestamp: std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)?\n                    .as_millis() as u64,\n            };\n\n            send_message(\u0026mut stream, msg).await?;\n\n            println!(\" Client {} connected and sent ping\", i);\n\n            sleep(Duration::from_millis(500)).await;\n\n            Ok::\u003c_, anyhow::Error\u003e(())\n        });\n\n        handles.push(handle);\n    }\n\n    // Wait for all clients\n    for handle in handles {\n        handle.await??;\n    }\n\n    println!(\" Multiple concurrent clients test passed\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_graceful_disconnect() -\u003e Result\u003c()\u003e {\n    let stream = connect_with_timeout().await?;\n\n    // Simply drop the stream\n    drop(stream);\n\n    // Verify we can reconnect\n    let _stream2 = connect_with_timeout().await?;\n\n    println!(\" Graceful disconnect test passed\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_message_roundtrip_latency() -\u003e Result\u003c()\u003e {\n    let mut stream = connect_with_timeout().await?;\n\n    let iterations = 100;\n    let mut total_duration = Duration::from_nanos(0);\n\n    for _ in 0..iterations {\n        let start = std::time::Instant::now();\n\n        let msg = ControlMessage::Ping {\n            timestamp: std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)?\n                .as_millis() as u64,\n        };\n\n        send_message(\u0026mut stream, msg).await?;\n\n        let duration = start.elapsed();\n        total_duration += duration;\n    }\n\n    let avg_latency = total_duration / iterations;\n\n    println!(\" Average message latency: {:?}\", avg_latency);\n\n    // Verify we're under 1ms requirement\n    assert!(avg_latency \u003c Duration::from_millis(1),\n            \"Average latency {}s exceeds 1ms requirement\", avg_latency.as_micros());\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_large_input_message() -\u003e Result\u003c()\u003e {\n    let mut stream = connect_with_timeout().await?;\n\n    // Send a large but valid input message\n    let large_input = vec![b'a'; 4096];\n    let msg = ControlMessage::Input {\n        data: large_input,\n    };\n\n    send_message(\u0026mut stream, msg).await?;\n    println!(\" Large input message sent successfully\");\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_rapid_resize_events() -\u003e Result\u003c()\u003e {\n    let mut stream = connect_with_timeout().await?;\n\n    // Simulate rapid window resizing\n    for i in 0..20 {\n        let cols = 80 + (i * 5);\n        let rows = 24 + (i * 2);\n\n        let msg = ControlMessage::Resize { cols, rows };\n        send_message(\u0026mut stream, msg).await?;\n\n        // Small delay to simulate realistic resize events\n        sleep(Duration::from_millis(10)).await;\n    }\n\n    println!(\" Rapid resize events handled successfully\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_stress_test_single_client() -\u003e Result\u003c()\u003e {\n    let mut stream = connect_with_timeout().await?;\n\n    // Send 1000 messages as fast as possible\n    for i in 0..1000 {\n        let msg = ControlMessage::Input {\n            data: format!(\"{}\", i % 10).into_bytes(),\n        };\n\n        send_message(\u0026mut stream, msg).await?;\n    }\n\n    println!(\" Stress test: 1000 messages sent successfully\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-daemon","tests","session_integration.rs"],"content":"use scarab_daemon::session::{SessionManager, Session};\nuse tempfile::TempDir;\nuse std::time::Duration;\n\n#[test]\nfn test_session_creation_and_persistence() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    // Create manager and session\n    let manager = SessionManager::new(db_path.clone()).unwrap();\n    let id1 = manager.create_session(\"session1\".to_string(), 80, 24).unwrap();\n    let id2 = manager.create_session(\"session2\".to_string(), 100, 30).unwrap();\n\n    assert_eq!(manager.session_count(), 2);\n\n    // Create new manager instance to test persistence\n    let manager2 = SessionManager::new(db_path).unwrap();\n    manager2.restore_sessions().unwrap();\n\n    assert_eq!(manager2.session_count(), 2);\n\n    let session = manager2.get_session(\u0026id1).unwrap();\n    assert_eq!(session.name, \"session1\");\n}\n\n#[test]\nfn test_session_attach_detach() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    let manager = SessionManager::new(db_path).unwrap();\n    let id = manager.create_session(\"test\".to_string(), 80, 24).unwrap();\n\n    // Attach multiple clients\n    manager.attach_client(\u0026id, 1).unwrap();\n    manager.attach_client(\u0026id, 2).unwrap();\n    manager.attach_client(\u0026id, 3).unwrap();\n\n    let session = manager.get_session(\u0026id).unwrap();\n    assert_eq!(session.attached_client_count(), 3);\n\n    // Detach one client\n    manager.detach_client(\u0026id, 2).unwrap();\n    assert_eq!(session.attached_client_count(), 2);\n\n    // Cannot delete session with attached clients\n    assert!(manager.delete_session(\u0026id).is_err());\n\n    // Detach remaining clients\n    manager.detach_client(\u0026id, 1).unwrap();\n    manager.detach_client(\u0026id, 3).unwrap();\n\n    // Now deletion should work\n    assert!(manager.delete_session(\u0026id).is_ok());\n}\n\n#[test]\nfn test_session_listing() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    let manager = SessionManager::new(db_path).unwrap();\n\n    let _id1 = manager.create_session(\"alpha\".to_string(), 80, 24).unwrap();\n    let _id2 = manager.create_session(\"beta\".to_string(), 100, 30).unwrap();\n    let _id3 = manager.create_session(\"gamma\".to_string(), 120, 40).unwrap();\n\n    let sessions = manager.list_sessions();\n    assert_eq!(sessions.len(), 3);\n\n    let names: Vec\u003cString\u003e = sessions.iter().map(|(_, name, _, _, _)| name.clone()).collect();\n    assert!(names.contains(\u0026\"alpha\".to_string()));\n    assert!(names.contains(\u0026\"beta\".to_string()));\n    assert!(names.contains(\u0026\"gamma\".to_string()));\n}\n\n#[test]\nfn test_session_rename() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    let manager = SessionManager::new(db_path.clone()).unwrap();\n    let id = manager.create_session(\"old_name\".to_string(), 80, 24).unwrap();\n\n    manager.rename_session(\u0026id, \"new_name\".to_string()).unwrap();\n\n    // Verify rename persisted\n    let manager2 = SessionManager::new(db_path).unwrap();\n    manager2.restore_sessions().unwrap();\n\n    let session = manager2.get_session(\u0026id).unwrap();\n    assert_eq!(session.name, \"new_name\");\n}\n\n#[test]\nfn test_default_session() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    let manager = SessionManager::new(db_path).unwrap();\n\n    // No default when empty\n    assert!(manager.get_default_session().is_none());\n\n    let id1 = manager.create_session(\"first\".to_string(), 80, 24).unwrap();\n\n    // First session becomes default\n    let default = manager.get_default_session().unwrap();\n    assert_eq!(default.id, id1);\n\n    let _id2 = manager.create_session(\"second\".to_string(), 80, 24).unwrap();\n\n    // Default should still be first session\n    let default = manager.get_default_session().unwrap();\n    assert_eq!(default.id, id1);\n}\n\n#[test]\nfn test_session_cleanup_detached() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    let manager = SessionManager::new(db_path).unwrap();\n\n    let id1 = manager.create_session(\"attached\".to_string(), 80, 24).unwrap();\n    let id2 = manager.create_session(\"detached_old\".to_string(), 80, 24).unwrap();\n\n    // Attach client to first session\n    manager.attach_client(\u0026id1, 1).unwrap();\n\n    // Wait briefly\n    std::thread::sleep(Duration::from_millis(100));\n\n    // Cleanup sessions older than 0 seconds (should only remove detached ones)\n    let removed = manager.cleanup_detached_sessions(0).unwrap();\n\n    assert_eq!(removed, 1);\n    assert_eq!(manager.session_count(), 1);\n    assert!(manager.get_session(\u0026id1).is_some());\n    assert!(manager.get_session(\u0026id2).is_none());\n}\n\n#[test]\nfn test_concurrent_session_operations() {\n    use std::sync::Arc;\n    use std::thread;\n\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    let manager = Arc::new(SessionManager::new(db_path).unwrap());\n\n    // Create sessions concurrently\n    let mut handles = vec![];\n\n    for i in 0..10 {\n        let manager_clone = Arc::clone(\u0026manager);\n        let handle = thread::spawn(move || {\n            manager_clone\n                .create_session(format!(\"session_{}\", i), 80, 24)\n                .unwrap();\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    assert_eq!(manager.session_count(), 10);\n}\n\n#[test]\nfn test_session_resurrection() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    // First daemon instance\n    {\n        let manager = SessionManager::new(db_path.clone()).unwrap();\n        let _id1 = manager.create_session(\"persistent1\".to_string(), 80, 24).unwrap();\n        let _id2 = manager.create_session(\"persistent2\".to_string(), 100, 30).unwrap();\n\n        assert_eq!(manager.session_count(), 2);\n    } // Manager dropped, simulating daemon shutdown\n\n    // Second daemon instance - should resurrect sessions\n    {\n        let manager = SessionManager::new(db_path).unwrap();\n        manager.restore_sessions().unwrap();\n\n        assert_eq!(manager.session_count(), 2);\n\n        let sessions = manager.list_sessions();\n        let names: Vec\u003cString\u003e = sessions.iter().map(|(_, name, _, _, _)| name.clone()).collect();\n\n        assert!(names.contains(\u0026\"persistent1\".to_string()));\n        assert!(names.contains(\u0026\"persistent2\".to_string()));\n    }\n}\n\n#[test]\nfn test_session_memory_efficiency() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    let manager = SessionManager::new(db_path).unwrap();\n\n    // Create 50+ sessions to test scalability\n    for i in 0..60 {\n        manager.create_session(format!(\"session_{}\", i), 80, 24).unwrap();\n    }\n\n    assert_eq!(manager.session_count(), 60);\n\n    // Verify all sessions are accessible\n    let sessions = manager.list_sessions();\n    assert_eq!(sessions.len(), 60);\n}\n\n#[tokio::test]\nasync fn test_session_attach_performance() {\n    use std::time::Instant;\n\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"sessions.db\");\n\n    let manager = SessionManager::new(db_path).unwrap();\n    let id1 = manager.create_session(\"perf_test\".to_string(), 80, 24).unwrap();\n    let id2 = manager.create_session(\"perf_test2\".to_string(), 80, 24).unwrap();\n\n    // Measure session switch time\n    manager.attach_client(\u0026id1, 1).unwrap();\n\n    let start = Instant::now();\n    manager.detach_client(\u0026id1, 1).unwrap();\n    manager.attach_client(\u0026id2, 1).unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\"Session switch time: {:?}\", elapsed);\n\n    // Should be well under 10ms target\n    assert!(elapsed.as_millis() \u003c 10, \"Session switch took {:?}, expected \u003c10ms\", elapsed);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-platform","src","ipc","mod.rs"],"content":"//! Cross-platform IPC implementation\n//!\n//! This module provides a unified interface for Inter-Process Communication\n//! using Unix domain sockets on Unix-like systems and Named Pipes on Windows.\n\nuse anyhow::Result;\nuse std::io::{Read, Write};\n\n#[cfg(unix)]\nmod unix;\n#[cfg(windows)]\nmod windows;\n\n#[cfg(unix)]\npub use unix::{IpcClient, IpcListener, IpcStream};\n\n#[cfg(windows)]\npub use windows::{IpcClient, IpcListener, IpcStream};\n\n/// Common IPC traits\npub trait IpcConnection: Read + Write + Send {\n    /// Check if the connection is still active\n    fn is_connected(\u0026self) -\u003e bool;\n\n    /// Get the connection ID\n    fn id(\u0026self) -\u003e String;\n\n    /// Shutdown the connection\n    fn shutdown(\u0026mut self) -\u003e Result\u003c()\u003e;\n}\n\n/// IPC server trait\npub trait IpcServer {\n    type Stream: IpcConnection;\n\n    /// Accept a new connection\n    fn accept(\u0026self) -\u003e Result\u003cSelf::Stream\u003e;\n\n    /// Get the server address/name\n    fn address(\u0026self) -\u003e String;\n\n    /// Shutdown the server\n    fn shutdown(\u0026mut self) -\u003e Result\u003c()\u003e;\n}\n\n/// IPC configuration\n#[derive(Debug, Clone)]\npub struct IpcConfig {\n    /// Buffer size for read/write operations\n    pub buffer_size: usize,\n    /// Timeout for connection attempts (in milliseconds)\n    pub connect_timeout: u64,\n    /// Timeout for read operations (in milliseconds)\n    pub read_timeout: Option\u003cu64\u003e,\n    /// Timeout for write operations (in milliseconds)\n    pub write_timeout: Option\u003cu64\u003e,\n    /// Maximum number of pending connections\n    pub max_connections: u32,\n}\n\nimpl Default for IpcConfig {\n    fn default() -\u003e Self {\n        Self {\n            buffer_size: 8192,\n            connect_timeout: 5000,\n            read_timeout: None,\n            write_timeout: None,\n            max_connections: 128,\n        }\n    }\n}\n\n/// Create platform-specific IPC server\npub fn create_server(name: \u0026str, config: \u0026IpcConfig) -\u003e Result\u003cimpl IpcServer\u003e {\n    #[cfg(unix)]\n    {\n        unix::IpcListener::new(name, config)\n    }\n    #[cfg(windows)]\n    {\n        windows::IpcListener::new(name, config)\n    }\n}\n\n/// Create platform-specific IPC client\npub fn create_client(name: \u0026str, config: \u0026IpcConfig) -\u003e Result\u003cimpl IpcConnection\u003e {\n    #[cfg(unix)]\n    {\n        unix::IpcClient::connect(name, config)\n    }\n    #[cfg(windows)]\n    {\n        windows::IpcClient::connect(name, config)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = IpcConfig::default();\n        assert_eq!(config.buffer_size, 8192);\n        assert_eq!(config.connect_timeout, 5000);\n        assert_eq!(config.max_connections, 128);\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-platform","src","ipc","unix.rs"],"content":"//! Unix domain socket implementation for IPC\n\nuse super::{IpcConfig, IpcConnection, IpcServer};\nuse anyhow::{Context, Result};\nuse std::io::{Read, Write};\nuse std::os::unix::net::{UnixListener as StdUnixListener, UnixStream as StdUnixStream};\nuse std::path::{Path, PathBuf};\nuse std::time::Duration;\n\n/// Unix domain socket stream\npub struct IpcStream {\n    stream: StdUnixStream,\n    id: String,\n}\n\nimpl IpcStream {\n    fn new(stream: StdUnixStream) -\u003e Self {\n        let id = format!(\"unix-{:p}\", \u0026stream);\n        Self { stream, id }\n    }\n}\n\nimpl Read for IpcStream {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e std::io::Result\u003cusize\u003e {\n        self.stream.read(buf)\n    }\n}\n\nimpl Write for IpcStream {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e std::io::Result\u003cusize\u003e {\n        self.stream.write(buf)\n    }\n\n    fn flush(\u0026mut self) -\u003e std::io::Result\u003c()\u003e {\n        self.stream.flush()\n    }\n}\n\nimpl IpcConnection for IpcStream {\n    fn is_connected(\u0026self) -\u003e bool {\n        self.stream.peer_addr().is_ok()\n    }\n\n    fn id(\u0026self) -\u003e String {\n        self.id.clone()\n    }\n\n    fn shutdown(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.stream\n            .shutdown(std::net::Shutdown::Both)\n            .context(\"Failed to shutdown Unix socket\")\n    }\n}\n\nunsafe impl Send for IpcStream {}\n\n/// Unix domain socket listener\npub struct IpcListener {\n    listener: StdUnixListener,\n    path: PathBuf,\n}\n\nimpl IpcListener {\n    pub fn new(name: \u0026str, config: \u0026IpcConfig) -\u003e Result\u003cSelf\u003e {\n        let path = if name.starts_with('/') {\n            PathBuf::from(name)\n        } else {\n            crate::CurrentPlatform::runtime_dir()?.join(format!(\"{}.sock\", name))\n        };\n\n        // Remove existing socket file if it exists\n        if path.exists() {\n            std::fs::remove_file(\u0026path).ok();\n        }\n\n        // Create parent directory if needed\n        if let Some(parent) = path.parent() {\n            std::fs::create_dir_all(parent)\n                .with_context(|| format!(\"Failed to create directory: {:?}\", parent))?;\n        }\n\n        let listener = StdUnixListener::bind(\u0026path)\n            .with_context(|| format!(\"Failed to bind Unix socket: {:?}\", path))?;\n\n        // Set permissions to 600 (owner read/write only)\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            let metadata = std::fs::metadata(\u0026path)?;\n            let mut permissions = metadata.permissions();\n            permissions.set_mode(0o600);\n            std::fs::set_permissions(\u0026path, permissions)?;\n        }\n\n        Ok(Self { listener, path })\n    }\n}\n\nimpl IpcServer for IpcListener {\n    type Stream = IpcStream;\n\n    fn accept(\u0026self) -\u003e Result\u003cSelf::Stream\u003e {\n        let (stream, _addr) = self\n            .listener\n            .accept()\n            .context(\"Failed to accept Unix socket connection\")?;\n        Ok(IpcStream::new(stream))\n    }\n\n    fn address(\u0026self) -\u003e String {\n        self.path.display().to_string()\n    }\n\n    fn shutdown(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // Remove the socket file\n        if self.path.exists() {\n            std::fs::remove_file(\u0026self.path)\n                .context(\"Failed to remove Unix socket file\")?;\n        }\n        Ok(())\n    }\n}\n\nimpl Drop for IpcListener {\n    fn drop(\u0026mut self) {\n        self.shutdown().ok();\n    }\n}\n\n/// Unix domain socket client\npub struct IpcClient;\n\nimpl IpcClient {\n    pub fn connect(name: \u0026str, config: \u0026IpcConfig) -\u003e Result\u003cIpcStream\u003e {\n        let path = if name.starts_with('/') {\n            PathBuf::from(name)\n        } else {\n            crate::CurrentPlatform::runtime_dir()?.join(format!(\"{}.sock\", name))\n        };\n\n        let stream = if let Some(timeout) = config.read_timeout {\n            let stream = StdUnixStream::connect_timeout(\u0026path, Duration::from_millis(timeout))\n                .with_context(|| format!(\"Failed to connect to Unix socket: {:?}\", path))?;\n            stream\n        } else {\n            StdUnixStream::connect(\u0026path)\n                .with_context(|| format!(\"Failed to connect to Unix socket: {:?}\", path))?\n        };\n\n        // Set timeouts if configured\n        if let Some(timeout) = config.read_timeout {\n            stream.set_read_timeout(Some(Duration::from_millis(timeout)))?;\n        }\n        if let Some(timeout) = config.write_timeout {\n            stream.set_write_timeout(Some(Duration::from_millis(timeout)))?;\n        }\n\n        Ok(IpcStream::new(stream))\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-platform","src","lib.rs"],"content":"//! Platform abstraction layer for Scarab terminal emulator\n//!\n//! This module provides platform-specific implementations for:\n//! - File paths (config, data, cache)\n//! - IPC mechanisms (Unix sockets vs Named Pipes)\n//! - Graphics backend selection\n//! - System integration\n\nuse anyhow::Result;\nuse std::path::PathBuf;\n\n#[cfg(target_os = \"macos\")]\nmod macos;\n#[cfg(target_os = \"linux\")]\nmod linux;\n#[cfg(target_os = \"windows\")]\nmod windows;\n\npub mod ipc;\n\n/// Platform-specific behavior trait\npub trait Platform: Send + Sync {\n    /// Get the default socket/pipe path for IPC\n    fn socket_path() -\u003e Result\u003cPathBuf\u003e;\n\n    /// Get the configuration directory path\n    fn config_dir() -\u003e Result\u003cPathBuf\u003e;\n\n    /// Get the data directory path\n    fn data_dir() -\u003e Result\u003cPathBuf\u003e;\n\n    /// Get the cache directory path\n    fn cache_dir() -\u003e Result\u003cPathBuf\u003e;\n\n    /// Get the runtime directory path (for temporary files)\n    fn runtime_dir() -\u003e Result\u003cPathBuf\u003e;\n\n    /// Get platform name for display\n    fn platform_name() -\u003e \u0026'static str;\n\n    /// Check if running in a container/VM\n    fn is_virtualized() -\u003e bool {\n        false\n    }\n\n    /// Get recommended graphics backend\n    fn graphics_backend() -\u003e GraphicsBackend;\n\n    /// Platform-specific initialization\n    fn init() -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\n/// Graphics backend options\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum GraphicsBackend {\n    Metal,\n    Vulkan,\n    DirectX12,\n    OpenGL,\n    Auto,\n}\n\n/// Current platform implementation\n#[cfg(target_os = \"macos\")]\npub type CurrentPlatform = macos::MacPlatform;\n\n#[cfg(target_os = \"linux\")]\npub type CurrentPlatform = linux::LinuxPlatform;\n\n#[cfg(target_os = \"windows\")]\npub type CurrentPlatform = windows::WindowsPlatform;\n\n/// Get the current platform\npub fn current_platform() -\u003e \u0026'static dyn Platform {\n    \u0026CurrentPlatform\n}\n\n/// Platform detection utilities\npub mod detect {\n    use super::*;\n\n    /// Detect if running under WSL\n    #[cfg(target_os = \"linux\")]\n    pub fn is_wsl() -\u003e bool {\n        std::path::Path::new(\"/proc/sys/fs/binfmt_misc/WSLInterop\").exists()\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    pub fn is_wsl() -\u003e bool {\n        false\n    }\n\n    /// Detect if running under X11\n    #[cfg(target_os = \"linux\")]\n    pub fn is_x11() -\u003e bool {\n        std::env::var(\"DISPLAY\").is_ok()\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    pub fn is_x11() -\u003e bool {\n        false\n    }\n\n    /// Detect if running under Wayland\n    #[cfg(target_os = \"linux\")]\n    pub fn is_wayland() -\u003e bool {\n        std::env::var(\"WAYLAND_DISPLAY\").is_ok()\n    }\n\n    #[cfg(not(target_os = \"linux\"))]\n    pub fn is_wayland() -\u003e bool {\n        false\n    }\n}","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-platform","src","linux.rs"],"content":"//! Linux platform implementation\n\nuse crate::{detect, GraphicsBackend, Platform};\nuse anyhow::{Context, Result};\nuse std::path::PathBuf;\n\npub struct LinuxPlatform;\n\nimpl Platform for LinuxPlatform {\n    fn socket_path() -\u003e Result\u003cPathBuf\u003e {\n        let runtime_dir = Self::runtime_dir()?;\n        Ok(runtime_dir.join(\"scarab.sock\"))\n    }\n\n    fn config_dir() -\u003e Result\u003cPathBuf\u003e {\n        std::env::var(\"XDG_CONFIG_HOME\")\n            .map(PathBuf::from)\n            .or_else(|_| dirs::config_dir())\n            .map(|p| p.join(\"scarab\"))\n            .context(\"Failed to get config directory\")\n    }\n\n    fn data_dir() -\u003e Result\u003cPathBuf\u003e {\n        std::env::var(\"XDG_DATA_HOME\")\n            .map(PathBuf::from)\n            .or_else(|_| dirs::data_dir())\n            .map(|p| p.join(\"scarab\"))\n            .context(\"Failed to get data directory\")\n    }\n\n    fn cache_dir() -\u003e Result\u003cPathBuf\u003e {\n        std::env::var(\"XDG_CACHE_HOME\")\n            .map(PathBuf::from)\n            .or_else(|_| dirs::cache_dir())\n            .map(|p| p.join(\"scarab\"))\n            .context(\"Failed to get cache directory\")\n    }\n\n    fn runtime_dir() -\u003e Result\u003cPathBuf\u003e {\n        std::env::var(\"XDG_RUNTIME_DIR\")\n            .map(PathBuf::from)\n            .or_else(|_| std::env::var(\"TMPDIR\").map(PathBuf::from))\n            .unwrap_or_else(|_| PathBuf::from(\"/tmp\"))\n            .join(format!(\"scarab-{}\", users::get_current_uid()))\n            .into()\n    }\n\n    fn platform_name() -\u003e \u0026'static str {\n        if detect::is_wsl() {\n            \"Linux (WSL)\"\n        } else if detect::is_wayland() {\n            \"Linux (Wayland)\"\n        } else if detect::is_x11() {\n            \"Linux (X11)\"\n        } else {\n            \"Linux\"\n        }\n    }\n\n    fn is_virtualized() -\u003e bool {\n        detect::is_wsl() || utils::is_docker() || utils::is_vm()\n    }\n\n    fn graphics_backend() -\u003e GraphicsBackend {\n        // Prefer Vulkan on Linux, fallback to OpenGL\n        if utils::has_vulkan_support() {\n            GraphicsBackend::Vulkan\n        } else {\n            GraphicsBackend::OpenGL\n        }\n    }\n\n    fn init() -\u003e Result\u003c()\u003e {\n        // Create necessary directories with proper permissions\n        let dirs = vec![\n            Self::config_dir()?,\n            Self::data_dir()?,\n            Self::cache_dir()?,\n            Self::runtime_dir()?,\n        ];\n\n        for dir in dirs {\n            std::fs::create_dir_all(\u0026dir)\n                .with_context(|| format!(\"Failed to create directory: {:?}\", dir))?;\n        }\n\n        // Set proper permissions for runtime directory (700)\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            let runtime_dir = Self::runtime_dir()?;\n            let metadata = std::fs::metadata(\u0026runtime_dir)?;\n            let mut permissions = metadata.permissions();\n            permissions.set_mode(0o700);\n            std::fs::set_permissions(\u0026runtime_dir, permissions)?;\n        }\n\n        Ok(())\n    }\n}\n\n/// Linux-specific utilities\npub mod utils {\n    use std::path::Path;\n\n    /// Check if running in Docker\n    pub fn is_docker() -\u003e bool {\n        Path::new(\"/.dockerenv\").exists()\n            || std::fs::read_to_string(\"/proc/1/cgroup\")\n                .map(|s| s.contains(\"docker\"))\n                .unwrap_or(false)\n    }\n\n    /// Check if running in a VM\n    pub fn is_vm() -\u003e bool {\n        std::fs::read_to_string(\"/sys/devices/virtual/dmi/id/product_name\")\n            .map(|s| {\n                let s = s.to_lowercase();\n                s.contains(\"virtualbox\")\n                    || s.contains(\"vmware\")\n                    || s.contains(\"qemu\")\n                    || s.contains(\"kvm\")\n            })\n            .unwrap_or(false)\n    }\n\n    /// Check if Vulkan is available\n    pub fn has_vulkan_support() -\u003e bool {\n        // Simple check for Vulkan ICD files\n        Path::new(\"/usr/share/vulkan/icd.d\").exists()\n            || Path::new(\"/etc/vulkan/icd.d\").exists()\n            || std::env::var(\"VK_ICD_FILENAMES\").is_ok()\n    }\n\n    /// Get distribution info\n    pub fn distro_info() -\u003e Option\u003cString\u003e {\n        std::fs::read_to_string(\"/etc/os-release\")\n            .ok()\n            .and_then(|content| {\n                content\n                    .lines()\n                    .find(|line| line.starts_with(\"PRETTY_NAME=\"))\n                    .map(|line| {\n                        line.trim_start_matches(\"PRETTY_NAME=\")\n                            .trim_matches('\"')\n                            .to_string()\n                    })\n            })\n    }\n}\n\n// Add users dependency for Linux\nuse std::sync::OnceLock;\n\nmod users {\n    pub fn get_current_uid() -\u003e u32 {\n        #[cfg(unix)]\n        unsafe {\n            libc::getuid()\n        }\n        #[cfg(not(unix))]\n        0\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-platform","src","macos.rs"],"content":"//! macOS platform implementation\n\nuse crate::{GraphicsBackend, Platform};\nuse anyhow::{Context, Result};\nuse std::path::PathBuf;\n\npub struct MacPlatform;\n\nimpl Platform for MacPlatform {\n    fn socket_path() -\u003e Result\u003cPathBuf\u003e {\n        let runtime_dir = Self::runtime_dir()?;\n        Ok(runtime_dir.join(\"scarab.sock\"))\n    }\n\n    fn config_dir() -\u003e Result\u003cPathBuf\u003e {\n        dirs::config_dir()\n            .map(|p| p.join(\"scarab\"))\n            .context(\"Failed to get config directory\")\n    }\n\n    fn data_dir() -\u003e Result\u003cPathBuf\u003e {\n        dirs::data_dir()\n            .map(|p| p.join(\"scarab\"))\n            .context(\"Failed to get data directory\")\n    }\n\n    fn cache_dir() -\u003e Result\u003cPathBuf\u003e {\n        dirs::cache_dir()\n            .map(|p| p.join(\"scarab\"))\n            .context(\"Failed to get cache directory\")\n    }\n\n    fn runtime_dir() -\u003e Result\u003cPathBuf\u003e {\n        std::env::var(\"TMPDIR\")\n            .map(PathBuf::from)\n            .or_else(|_| std::env::var(\"XDG_RUNTIME_DIR\").map(PathBuf::from))\n            .unwrap_or_else(|_| PathBuf::from(\"/tmp\"))\n            .join(\"scarab\")\n            .into()\n    }\n\n    fn platform_name() -\u003e \u0026'static str {\n        if cfg!(target_arch = \"aarch64\") {\n            \"macOS (Apple Silicon)\"\n        } else {\n            \"macOS (Intel)\"\n        }\n    }\n\n    fn graphics_backend() -\u003e GraphicsBackend {\n        // Always use Metal on macOS for best performance\n        GraphicsBackend::Metal\n    }\n\n    fn init() -\u003e Result\u003c()\u003e {\n        // Create necessary directories\n        let dirs = vec![\n            Self::config_dir()?,\n            Self::data_dir()?,\n            Self::cache_dir()?,\n            Self::runtime_dir()?,\n        ];\n\n        for dir in dirs {\n            std::fs::create_dir_all(\u0026dir)\n                .with_context(|| format!(\"Failed to create directory: {:?}\", dir))?;\n        }\n\n        Ok(())\n    }\n}\n\n/// macOS-specific utilities\npub mod utils {\n    use std::process::Command;\n\n    /// Check if running on Apple Silicon\n    pub fn is_apple_silicon() -\u003e bool {\n        cfg!(target_arch = \"aarch64\")\n    }\n\n    /// Get macOS version\n    pub fn macos_version() -\u003e Option\u003cString\u003e {\n        Command::new(\"sw_vers\")\n            .arg(\"-productVersion\")\n            .output()\n            .ok()\n            .and_then(|o| String::from_utf8(o.stdout).ok())\n            .map(|s| s.trim().to_string())\n    }\n\n    /// Check if running under Rosetta 2\n    pub fn is_rosetta() -\u003e bool {\n        Command::new(\"sysctl\")\n            .arg(\"-n\")\n            .arg(\"sysctl.proc_translated\")\n            .output()\n            .ok()\n            .and_then(|o| String::from_utf8(o.stdout).ok())\n            .map(|s| s.trim() == \"1\")\n            .unwrap_or(false)\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-platform","src","windows.rs"],"content":"//! Windows platform implementation\n\nuse crate::{GraphicsBackend, Platform};\nuse anyhow::{Context, Result};\nuse std::path::PathBuf;\n\npub struct WindowsPlatform;\n\nimpl Platform for WindowsPlatform {\n    fn socket_path() -\u003e Result\u003cPathBuf\u003e {\n        // Windows uses named pipes instead of Unix sockets\n        // Format: \\\\.\\pipe\\scarab\n        Ok(PathBuf::from(r\"\\\\.\\pipe\\scarab\"))\n    }\n\n    fn config_dir() -\u003e Result\u003cPathBuf\u003e {\n        dirs::config_dir()\n            .map(|p| p.join(\"Scarab\"))\n            .context(\"Failed to get config directory\")\n    }\n\n    fn data_dir() -\u003e Result\u003cPathBuf\u003e {\n        dirs::data_local_dir()\n            .map(|p| p.join(\"Scarab\"))\n            .context(\"Failed to get data directory\")\n    }\n\n    fn cache_dir() -\u003e Result\u003cPathBuf\u003e {\n        dirs::cache_dir()\n            .map(|p| p.join(\"Scarab\"))\n            .context(\"Failed to get cache directory\")\n    }\n\n    fn runtime_dir() -\u003e Result\u003cPathBuf\u003e {\n        std::env::var(\"TEMP\")\n            .or_else(|_| std::env::var(\"TMP\"))\n            .map(PathBuf::from)\n            .unwrap_or_else(|_| PathBuf::from(r\"C:\\Windows\\Temp\"))\n            .join(\"Scarab\")\n            .into()\n    }\n\n    fn platform_name() -\u003e \u0026'static str {\n        if cfg!(target_arch = \"aarch64\") {\n            \"Windows (ARM64)\"\n        } else {\n            \"Windows (x64)\"\n        }\n    }\n\n    fn is_virtualized() -\u003e bool {\n        utils::is_wsl_host() || utils::is_hyperv() || utils::is_vm()\n    }\n\n    fn graphics_backend() -\u003e GraphicsBackend {\n        // Prefer DirectX 12 on Windows, fallback to Vulkan\n        if utils::has_dx12_support() {\n            GraphicsBackend::DirectX12\n        } else if utils::has_vulkan_support() {\n            GraphicsBackend::Vulkan\n        } else {\n            GraphicsBackend::OpenGL\n        }\n    }\n\n    fn init() -\u003e Result\u003c()\u003e {\n        // Create necessary directories\n        let dirs = vec![\n            Self::config_dir()?,\n            Self::data_dir()?,\n            Self::cache_dir()?,\n            Self::runtime_dir()?,\n        ];\n\n        for dir in dirs {\n            std::fs::create_dir_all(\u0026dir)\n                .with_context(|| format!(\"Failed to create directory: {:?}\", dir))?;\n        }\n\n        Ok(())\n    }\n}\n\n/// Windows-specific utilities\npub mod utils {\n    use std::ptr::null_mut;\n    use winapi::shared::minwindef::DWORD;\n    use winapi::um::sysinfoapi::{GetSystemInfo, SYSTEM_INFO};\n    use winapi::um::winbase::GetComputerNameW;\n    use winapi::um::winnt::LPCWSTR;\n\n    /// Check if running under WSL host\n    pub fn is_wsl_host() -\u003e bool {\n        std::env::var(\"WSL_DISTRO_NAME\").is_ok()\n    }\n\n    /// Check if running under Hyper-V\n    pub fn is_hyperv() -\u003e bool {\n        // Check for Hyper-V by looking at system info\n        // This is a simplified check\n        std::process::Command::new(\"wmic\")\n            .args(\u0026[\"computersystem\", \"get\", \"model\"])\n            .output()\n            .map(|o| {\n                String::from_utf8_lossy(\u0026o.stdout)\n                    .to_lowercase()\n                    .contains(\"virtual\")\n            })\n            .unwrap_or(false)\n    }\n\n    /// Check if running in a VM\n    pub fn is_vm() -\u003e bool {\n        std::process::Command::new(\"wmic\")\n            .args(\u0026[\"computersystem\", \"get\", \"manufacturer\"])\n            .output()\n            .map(|o| {\n                let output = String::from_utf8_lossy(\u0026o.stdout).to_lowercase();\n                output.contains(\"vmware\")\n                    || output.contains(\"virtualbox\")\n                    || output.contains(\"qemu\")\n                    || output.contains(\"microsoft corporation\")\n            })\n            .unwrap_or(false)\n    }\n\n    /// Check if DirectX 12 is available\n    pub fn has_dx12_support() -\u003e bool {\n        // Check for dxgi.dll and d3d12.dll\n        std::path::Path::new(r\"C:\\Windows\\System32\\d3d12.dll\").exists()\n            \u0026\u0026 std::path::Path::new(r\"C:\\Windows\\System32\\dxgi.dll\").exists()\n    }\n\n    /// Check if Vulkan is available\n    pub fn has_vulkan_support() -\u003e bool {\n        // Check for vulkan-1.dll\n        std::path::Path::new(r\"C:\\Windows\\System32\\vulkan-1.dll\").exists()\n            || std::env::var(\"VK_ICD_FILENAMES\").is_ok()\n    }\n\n    /// Get Windows version\n    pub fn windows_version() -\u003e Option\u003cString\u003e {\n        std::process::Command::new(\"wmic\")\n            .args(\u0026[\"os\", \"get\", \"Caption\"])\n            .output()\n            .ok()\n            .and_then(|o| {\n                String::from_utf8(o.stdout)\n                    .ok()\n                    .and_then(|s| s.lines().nth(1).map(|l| l.trim().to_string()))\n            })\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-plugin-api","src","config.rs"],"content":"//! Plugin configuration loading and discovery\n\nuse crate::{\n    context::PluginConfigData,\n    error::Result,\n};\nuse serde::{Deserialize, Serialize};\nuse std::{\n    fs,\n    path::{Path, PathBuf},\n};\n\n/// Plugin configuration from TOML file\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct PluginConfig {\n    /// Plugin name\n    pub name: String,\n    /// Path to plugin file (.fzb or .fsx)\n    pub path: PathBuf,\n    /// Whether plugin is enabled\n    #[serde(default = \"default_true\")]\n    pub enabled: bool,\n    /// Plugin-specific configuration\n    #[serde(default)]\n    pub config: PluginConfigData,\n}\n\nfn default_true() -\u003e bool {\n    true\n}\n\nimpl PluginConfig {\n    /// Load plugin configuration from TOML file\n    pub fn from_file(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cVec\u003cSelf\u003e\u003e {\n        let content = fs::read_to_string(path)?;\n        let config: PluginsToml = toml::from_str(\u0026content)?;\n        Ok(config.plugin)\n    }\n\n    /// Expand path with home directory\n    pub fn expanded_path(\u0026self) -\u003e PathBuf {\n        expand_path(\u0026self.path)\n    }\n}\n\n/// Root TOML structure for plugins.toml\n#[derive(Debug, Deserialize, Serialize)]\nstruct PluginsToml {\n    plugin: Vec\u003cPluginConfig\u003e,\n}\n\n/// Plugin discovery system\npub struct PluginDiscovery {\n    /// Plugin directories to search\n    search_paths: Vec\u003cPathBuf\u003e,\n}\n\nimpl PluginDiscovery {\n    /// Create new discovery with default paths\n    pub fn new() -\u003e Self {\n        let mut search_paths = vec![\n            Self::default_plugin_dir(),\n            PathBuf::from(\"/usr/local/share/scarab/plugins\"),\n            PathBuf::from(\"/usr/share/scarab/plugins\"),\n        ];\n\n        // Add custom path from environment\n        if let Ok(custom_path) = std::env::var(\"SCARAB_PLUGIN_PATH\") {\n            search_paths.insert(0, PathBuf::from(custom_path));\n        }\n\n        Self { search_paths }\n    }\n\n    /// Get default plugin directory (~/.config/scarab/plugins)\n    pub fn default_plugin_dir() -\u003e PathBuf {\n        if let Some(home) = std::env::var_os(\"HOME\") {\n            PathBuf::from(home).join(\".config/scarab/plugins\")\n        } else {\n            PathBuf::from(\".config/scarab/plugins\")\n        }\n    }\n\n    /// Get default config file path (~/.config/scarab/plugins.toml)\n    pub fn default_config_path() -\u003e PathBuf {\n        if let Some(home) = std::env::var_os(\"HOME\") {\n            PathBuf::from(home).join(\".config/scarab/plugins.toml\")\n        } else {\n            PathBuf::from(\".config/scarab/plugins.toml\")\n        }\n    }\n\n    /// Add search path\n    pub fn add_path(\u0026mut self, path: impl Into\u003cPathBuf\u003e) {\n        self.search_paths.push(path.into());\n    }\n\n    /// Discover all plugin files in search paths\n    pub fn discover(\u0026self) -\u003e Vec\u003cPathBuf\u003e {\n        let mut plugins = Vec::new();\n\n        for dir in \u0026self.search_paths {\n            if let Ok(entries) = fs::read_dir(dir) {\n                for entry in entries.flatten() {\n                    let path = entry.path();\n                    if Self::is_plugin_file(\u0026path) {\n                        plugins.push(path);\n                    }\n                }\n            }\n        }\n\n        plugins\n    }\n\n    /// Check if file is a valid plugin file\n    fn is_plugin_file(path: \u0026Path) -\u003e bool {\n        if !path.is_file() {\n            return false;\n        }\n\n        matches!(\n            path.extension().and_then(|e| e.to_str()),\n            Some(\"fzb\") | Some(\"fsx\")\n        )\n    }\n\n    /// Load plugins from configuration file\n    pub fn load_config(\u0026self, path: Option\u003c\u0026Path\u003e) -\u003e Result\u003cVec\u003cPluginConfig\u003e\u003e {\n        let config_path = path\n            .map(PathBuf::from)\n            .unwrap_or_else(Self::default_config_path);\n\n        if !config_path.exists() {\n            return Ok(Vec::new());\n        }\n\n        PluginConfig::from_file(config_path)\n    }\n\n    /// Create default plugin directory if it doesn't exist\n    pub fn ensure_plugin_dir() -\u003e Result\u003cPathBuf\u003e {\n        let dir = Self::default_plugin_dir();\n        if !dir.exists() {\n            fs::create_dir_all(\u0026dir)?;\n        }\n        Ok(dir)\n    }\n\n    /// Create default config file with example\n    pub fn create_default_config() -\u003e Result\u003cPathBuf\u003e {\n        let config_path = Self::default_config_path();\n\n        if config_path.exists() {\n            return Ok(config_path);\n        }\n\n        // Ensure parent directory exists\n        if let Some(parent) = config_path.parent() {\n            fs::create_dir_all(parent)?;\n        }\n\n        // Create example config\n        let example_config = r#\"# Scarab Plugin Configuration\n# Place your plugin configurations here\n\n# Example plugin configuration:\n# [[plugin]]\n# name = \"auto-notify\"\n# path = \"~/.config/scarab/plugins/auto-notify.fzb\"\n# enabled = true\n#\n# [plugin.config]\n# keywords = [\"ERROR\", \"FAIL\", \"PANIC\"]\n# notification_style = \"urgent\"\n\n\"#;\n\n        fs::write(\u0026config_path, example_config)?;\n        Ok(config_path)\n    }\n}\n\nimpl Default for PluginDiscovery {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Expand ~ in path to home directory\nfn expand_path(path: \u0026Path) -\u003e PathBuf {\n    if let Some(s) = path.to_str() {\n        if let Some(stripped) = s.strip_prefix(\"~/\") {\n            if let Some(home) = std::env::var_os(\"HOME\") {\n                return PathBuf::from(home).join(stripped);\n            }\n        }\n    }\n    path.to_path_buf()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_expand_path() {\n        let path = PathBuf::from(\"~/test/path\");\n        let expanded = expand_path(\u0026path);\n        assert!(!expanded.to_string_lossy().contains('~'));\n    }\n\n    #[test]\n    fn test_is_plugin_file() {\n        // is_plugin_file checks if path.is_file() first, so we need actual files\n        // For unit testing, we just test the extension logic\n        use std::path::Path;\n\n        let has_valid_ext = |path: \u0026Path| -\u003e bool {\n            matches!(\n                path.extension().and_then(|e| e.to_str()),\n                Some(\"fzb\") | Some(\"fsx\")\n            )\n        };\n\n        assert!(has_valid_ext(Path::new(\"test.fzb\")));\n        assert!(has_valid_ext(Path::new(\"test.fsx\")));\n        assert!(!has_valid_ext(Path::new(\"test.txt\")));\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":199,"address":[],"length":0,"stats":{"Line":0}}],"covered":17,"coverable":80},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-plugin-api","src","context.rs"],"content":"//! Plugin context providing access to terminal state\n\nuse crate::{error::Result, types::Cell};\nuse parking_lot::Mutex;\nuse serde::Deserialize;\nuse std::{collections::HashMap, sync::Arc};\n\n/// Shared state accessible to plugins\n#[derive(Debug)]\npub struct SharedState {\n    /// Terminal grid cells\n    pub cells: Vec\u003cCell\u003e,\n    /// Grid width in columns\n    pub cols: u16,\n    /// Grid rows\n    pub rows: u16,\n    /// Current cursor position\n    pub cursor: (u16, u16),\n    /// Environment variables\n    pub env: HashMap\u003cString, String\u003e,\n    /// Custom plugin-specific data storage\n    pub data: HashMap\u003cString, String\u003e,\n}\n\nimpl SharedState {\n    /// Create new shared state\n    pub fn new(cols: u16, rows: u16) -\u003e Self {\n        let size = (cols as usize) * (rows as usize);\n        Self {\n            cells: vec![Cell::default(); size],\n            cols,\n            rows,\n            cursor: (0, 0),\n            env: std::env::vars().collect(),\n            data: HashMap::new(),\n        }\n    }\n\n    /// Get cell at position\n    pub fn get_cell(\u0026self, x: u16, y: u16) -\u003e Option\u003cCell\u003e {\n        if x \u003e= self.cols || y \u003e= self.rows {\n            return None;\n        }\n        let idx = (y as usize) * (self.cols as usize) + (x as usize);\n        self.cells.get(idx).copied()\n    }\n\n    /// Set cell at position\n    pub fn set_cell(\u0026mut self, x: u16, y: u16, cell: Cell) -\u003e bool {\n        if x \u003e= self.cols || y \u003e= self.rows {\n            return false;\n        }\n        let idx = (y as usize) * (self.cols as usize) + (x as usize);\n        if let Some(c) = self.cells.get_mut(idx) {\n            *c = cell;\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Get line of text\n    pub fn get_line(\u0026self, y: u16) -\u003e Option\u003cString\u003e {\n        if y \u003e= self.rows {\n            return None;\n        }\n        let start = (y as usize) * (self.cols as usize);\n        let end = start + (self.cols as usize);\n        Some(\n            self.cells[start..end]\n                .iter()\n                .map(|c| c.c)\n                .collect::\u003cString\u003e()\n                .trim_end()\n                .to_string(),\n        )\n    }\n}\n\n/// Context provided to plugins for interacting with the terminal\n#[derive(Clone)]\npub struct PluginContext {\n    /// Plugin-specific configuration\n    pub config: PluginConfigData,\n    /// Shared terminal state\n    pub state: Arc\u003cMutex\u003cSharedState\u003e\u003e,\n    /// Logger name for this plugin\n    pub logger_name: String,\n}\n\nimpl PluginContext {\n    /// Create new plugin context\n    pub fn new(\n        config: PluginConfigData,\n        state: Arc\u003cMutex\u003cSharedState\u003e\u003e,\n        logger_name: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            config,\n            state,\n            logger_name: logger_name.into(),\n        }\n    }\n\n    /// Get cell at position\n    pub fn get_cell(\u0026self, x: u16, y: u16) -\u003e Option\u003cCell\u003e {\n        self.state.lock().get_cell(x, y)\n    }\n\n    /// Set cell at position\n    pub fn set_cell(\u0026self, x: u16, y: u16, cell: Cell) -\u003e bool {\n        self.state.lock().set_cell(x, y, cell)\n    }\n\n    /// Get line of text at row\n    pub fn get_line(\u0026self, y: u16) -\u003e Option\u003cString\u003e {\n        self.state.lock().get_line(y)\n    }\n\n    /// Get terminal size\n    pub fn get_size(\u0026self) -\u003e (u16, u16) {\n        let state = self.state.lock();\n        (state.cols, state.rows)\n    }\n\n    /// Get cursor position\n    pub fn get_cursor(\u0026self) -\u003e (u16, u16) {\n        self.state.lock().cursor\n    }\n\n    /// Get environment variable\n    pub fn get_env(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n        self.state.lock().env.get(key).cloned()\n    }\n\n    /// Store plugin-specific data\n    pub fn set_data(\u0026self, key: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) {\n        self.state.lock().data.insert(key.into(), value.into());\n    }\n\n    /// Retrieve plugin-specific data\n    pub fn get_data(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n        self.state.lock().data.get(key).cloned()\n    }\n\n    /// Log a message (to be implemented with actual logging)\n    pub fn log(\u0026self, level: LogLevel, message: \u0026str) {\n        // TODO: Integrate with actual logging system\n        match level {\n            LogLevel::Error =\u003e eprintln!(\"[{}] ERROR: {}\", self.logger_name, message),\n            LogLevel::Warn =\u003e eprintln!(\"[{}] WARN: {}\", self.logger_name, message),\n            LogLevel::Info =\u003e println!(\"[{}] INFO: {}\", self.logger_name, message),\n            LogLevel::Debug =\u003e println!(\"[{}] DEBUG: {}\", self.logger_name, message),\n        }\n    }\n\n    /// Send notification to user (placeholder)\n    pub fn notify(\u0026self, message: \u0026str) {\n        // TODO: Implement actual notification system\n        println!(\"[NOTIFICATION] {}\", message);\n    }\n}\n\n/// Log levels for plugin logging\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum LogLevel {\n    Error,\n    Warn,\n    Info,\n    Debug,\n}\n\n/// Plugin-specific configuration data\n#[derive(Debug, Clone, Default, Deserialize, serde::Serialize)]\npub struct PluginConfigData {\n    #[serde(flatten)]\n    pub data: HashMap\u003cString, toml::Value\u003e,\n}\n\nimpl PluginConfigData {\n    /// Get configuration value\n    pub fn get\u003cT: for\u003c'de\u003e Deserialize\u003c'de\u003e\u003e(\u0026self, key: \u0026str) -\u003e Result\u003cT\u003e {\n        let value = self\n            .data\n            .get(key)\n            .ok_or_else(|| crate::error::PluginError::ConfigError(format!(\"Missing key: {}\", key)))?;\n        T::deserialize(value.clone())\n            .map_err(|e| crate::error::PluginError::ConfigError(e.to_string()))\n    }\n\n    /// Get optional configuration value\n    pub fn get_opt\u003cT: for\u003c'de\u003e Deserialize\u003c'de\u003e\u003e(\u0026self, key: \u0026str) -\u003e Option\u003cT\u003e {\n        self.data.get(key).and_then(|v| T::deserialize(v.clone()).ok())\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":7}},{"line":28,"address":[],"length":0,"stats":{"Line":14}},{"line":30,"address":[],"length":0,"stats":{"Line":28}},{"line":33,"address":[],"length":0,"stats":{"Line":14}},{"line":34,"address":[],"length":0,"stats":{"Line":14}},{"line":35,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":5}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":3}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":18}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":16}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":12}}],"covered":36,"coverable":66},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-plugin-api","src","error.rs"],"content":"//! Error types for plugin operations\n\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum PluginError {\n    #[error(\"Plugin failed to load: {0}\")]\n    LoadError(String),\n\n    #[error(\"Plugin version incompatible: required {required}, got {actual}\")]\n    VersionIncompatible { required: String, actual: String },\n\n    #[error(\"Plugin hook execution timed out after {0}ms\")]\n    Timeout(u64),\n\n    #[error(\"Plugin panic: {0}\")]\n    Panic(String),\n\n    #[error(\"Plugin disabled due to repeated failures\")]\n    Disabled,\n\n    #[error(\"Configuration error: {0}\")]\n    ConfigError(String),\n\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"TOML parse error: {0}\")]\n    TomlError(#[from] toml::de::Error),\n\n    #[error(\"Invalid plugin metadata: {0}\")]\n    InvalidMetadata(String),\n\n    #[error(\"Plugin not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"Other error: {0}\")]\n    Other(#[from] anyhow::Error),\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, PluginError\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-plugin-api","src","lib.rs"],"content":"//! Scarab Plugin API\n//!\n//! This crate provides the core plugin API for the Scarab terminal emulator.\n//! It defines traits, types, and utilities for building 3rd-party plugins.\n\npub mod plugin;\npub mod context;\npub mod config;\npub mod error;\npub mod types;\n\npub use plugin::{Plugin, PluginMetadata};\npub use context::PluginContext;\npub use config::{PluginConfig, PluginDiscovery};\npub use error::{PluginError, Result};\npub use types::{Action, HookType, PluginInfo};\n\n/// Current plugin API version\npub const API_VERSION: \u0026str = \"0.1.0\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-plugin-api","src","plugin.rs"],"content":"//! Core plugin trait and metadata definitions\n\nuse crate::{context::PluginContext, error::Result, types::Action};\nuse async_trait::async_trait;\n\n/// Main plugin trait that all plugins must implement\n///\n/// Plugins can hook into various events in the terminal lifecycle.\n/// All methods have default implementations that do nothing.\n#[async_trait]\npub trait Plugin: Send + Sync {\n    /// Get plugin metadata\n    fn metadata(\u0026self) -\u003e \u0026PluginMetadata;\n\n    /// Called when the plugin is loaded\n    ///\n    /// This is where plugins should initialize their state and resources.\n    async fn on_load(\u0026mut self, _ctx: \u0026mut PluginContext) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    /// Called when the plugin is being unloaded\n    ///\n    /// Plugins should clean up resources here.\n    async fn on_unload(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    /// Hook called before output is displayed to the terminal\n    ///\n    /// Plugins can modify, block, or pass through the output.\n    async fn on_output(\u0026mut self, _line: \u0026str, _ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n        Ok(Action::Continue)\n    }\n\n    /// Hook called after input is received from the user\n    ///\n    /// Plugins can intercept and modify input before it reaches the PTY.\n    async fn on_input(\u0026mut self, _input: \u0026[u8], _ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n        Ok(Action::Continue)\n    }\n\n    /// Hook called before a command is executed\n    async fn on_pre_command(\u0026mut self, _command: \u0026str, _ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n        Ok(Action::Continue)\n    }\n\n    /// Hook called after a command completes\n    async fn on_post_command(\n        \u0026mut self,\n        _command: \u0026str,\n        _exit_code: i32,\n        _ctx: \u0026PluginContext,\n    ) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    /// Hook called when terminal is resized\n    async fn on_resize(\u0026mut self, _cols: u16, _rows: u16, _ctx: \u0026PluginContext) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    /// Hook called when a client attaches to the session\n    async fn on_attach(\u0026mut self, _client_id: u64, _ctx: \u0026PluginContext) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    /// Hook called when a client detaches from the session\n    async fn on_detach(\u0026mut self, _client_id: u64, _ctx: \u0026PluginContext) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\n/// Plugin metadata\n#[derive(Debug, Clone)]\npub struct PluginMetadata {\n    /// Plugin name (must be unique)\n    pub name: String,\n    /// Plugin version (semver)\n    pub version: String,\n    /// Short description\n    pub description: String,\n    /// Author name\n    pub author: String,\n    /// Homepage URL\n    pub homepage: Option\u003cString\u003e,\n    /// API version this plugin was built against\n    pub api_version: String,\n    /// Minimum Scarab version required\n    pub min_scarab_version: String,\n}\n\nimpl PluginMetadata {\n    /// Create new plugin metadata\n    pub fn new(\n        name: impl Into\u003cString\u003e,\n        version: impl Into\u003cString\u003e,\n        description: impl Into\u003cString\u003e,\n        author: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            name: name.into(),\n            version: version.into(),\n            description: description.into(),\n            author: author.into(),\n            homepage: None,\n            api_version: crate::API_VERSION.to_string(),\n            min_scarab_version: \"0.1.0\".to_string(),\n        }\n    }\n\n    /// Set homepage URL\n    pub fn with_homepage(mut self, homepage: impl Into\u003cString\u003e) -\u003e Self {\n        self.homepage = Some(homepage.into());\n        self\n    }\n\n    /// Set API version\n    pub fn with_api_version(mut self, version: impl Into\u003cString\u003e) -\u003e Self {\n        self.api_version = version.into();\n        self\n    }\n\n    /// Set minimum Scarab version\n    pub fn with_min_scarab_version(mut self, version: impl Into\u003cString\u003e) -\u003e Self {\n        self.min_scarab_version = version.into();\n        self\n    }\n\n    /// Check if this plugin is compatible with the current API version\n    pub fn is_compatible(\u0026self, current_api_version: \u0026str) -\u003e bool {\n        use semver::Version;\n\n        let Ok(plugin_version) = Version::parse(\u0026self.api_version) else {\n            return false;\n        };\n\n        let Ok(current_version) = Version::parse(current_api_version) else {\n            return false;\n        };\n\n        // Compatible if major versions match and plugin minor \u003c= current minor\n        plugin_version.major == current_version.major\n            \u0026\u0026 plugin_version.minor \u003c= current_version.minor\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_version_compatibility() {\n        let meta = PluginMetadata::new(\"test\", \"1.0.0\", \"Test plugin\", \"Test Author\")\n            .with_api_version(\"0.1.0\");\n\n        assert!(meta.is_compatible(\"0.1.0\"));\n        assert!(meta.is_compatible(\"0.2.0\"));\n        assert!(!meta.is_compatible(\"1.0.0\"));\n        assert!(!meta.is_compatible(\"0.0.1\"));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":24}},{"line":103,"address":[],"length":0,"stats":{"Line":24}},{"line":104,"address":[],"length":0,"stats":{"Line":24}},{"line":105,"address":[],"length":0,"stats":{"Line":24}},{"line":107,"address":[],"length":0,"stats":{"Line":24}},{"line":108,"address":[],"length":0,"stats":{"Line":8}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":20}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":20}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":10}},{"line":144,"address":[],"length":0,"stats":{"Line":8}}],"covered":15,"coverable":40},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-plugin-api","src","types.rs"],"content":"//! Common types used throughout the plugin API\n\nuse serde::{Deserialize, Serialize};\n\n/// Action that a plugin hook can return\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Action {\n    /// Continue processing with next plugin\n    Continue,\n    /// Stop processing, don't call remaining plugins\n    Stop,\n    /// Modify the data and continue\n    Modify(Vec\u003cu8\u003e),\n}\n\nimpl Action {\n    /// Check if this action modifies data\n    pub fn is_modify(\u0026self) -\u003e bool {\n        matches!(self, Action::Modify(_))\n    }\n\n    /// Check if this action stops processing\n    pub fn is_stop(\u0026self) -\u003e bool {\n        matches!(self, Action::Stop)\n    }\n}\n\n/// Type of hook being executed\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum HookType {\n    /// Before output is displayed\n    PreOutput,\n    /// After input is received\n    PostInput,\n    /// Before command is executed\n    PreCommand,\n    /// After command completes\n    PostCommand,\n    /// Terminal resize event\n    OnResize,\n    /// Client attached\n    OnAttach,\n    /// Client detached\n    OnDetach,\n}\n\nimpl HookType {\n    /// Get all hook types\n    pub fn all() -\u003e \u0026'static [HookType] {\n        \u0026[\n            HookType::PreOutput,\n            HookType::PostInput,\n            HookType::PreCommand,\n            HookType::PostCommand,\n            HookType::OnResize,\n            HookType::OnAttach,\n            HookType::OnDetach,\n        ]\n    }\n\n    /// Get human-readable name\n    pub fn name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            HookType::PreOutput =\u003e \"pre-output\",\n            HookType::PostInput =\u003e \"post-input\",\n            HookType::PreCommand =\u003e \"pre-command\",\n            HookType::PostCommand =\u003e \"post-command\",\n            HookType::OnResize =\u003e \"on-resize\",\n            HookType::OnAttach =\u003e \"on-attach\",\n            HookType::OnDetach =\u003e \"on-detach\",\n        }\n    }\n}\n\n/// Information about a loaded plugin\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PluginInfo {\n    /// Plugin name\n    pub name: String,\n    /// Plugin version\n    pub version: String,\n    /// Plugin description\n    pub description: String,\n    /// Plugin author\n    pub author: String,\n    /// Plugin homepage URL\n    pub homepage: Option\u003cString\u003e,\n    /// API version required\n    pub api_version: String,\n    /// Minimum Scarab version\n    pub min_scarab_version: String,\n    /// Whether plugin is currently enabled\n    pub enabled: bool,\n    /// Number of failures\n    pub failure_count: u32,\n}\n\nimpl PluginInfo {\n    /// Create new plugin info\n    pub fn new(\n        name: impl Into\u003cString\u003e,\n        version: impl Into\u003cString\u003e,\n        description: impl Into\u003cString\u003e,\n        author: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            name: name.into(),\n            version: version.into(),\n            description: description.into(),\n            author: author.into(),\n            homepage: None,\n            api_version: crate::API_VERSION.to_string(),\n            min_scarab_version: \"0.1.0\".to_string(),\n            enabled: true,\n            failure_count: 0,\n        }\n    }\n}\n\n/// Terminal cell representation\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Cell {\n    /// Character content\n    pub c: char,\n    /// Foreground color (RGB)\n    pub fg: (u8, u8, u8),\n    /// Background color (RGB)\n    pub bg: (u8, u8, u8),\n    /// Bold flag\n    pub bold: bool,\n    /// Italic flag\n    pub italic: bool,\n    /// Underline flag\n    pub underline: bool,\n}\n\nimpl Default for Cell {\n    fn default() -\u003e Self {\n        Self {\n            c: ' ',\n            fg: (255, 255, 255),\n            bg: (0, 0, 0),\n            bold: false,\n            italic: false,\n            underline: false,\n        }\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":19,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":5}},{"line":24,"address":[],"length":0,"stats":{"Line":7}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":8}},{"line":141,"address":[],"length":0,"stats":{"Line":8}},{"line":142,"address":[],"length":0,"stats":{"Line":8}}],"covered":28,"coverable":32},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-plugin-api","tests","integration_tests.rs"],"content":"//! Integration tests for the plugin API\n\nuse scarab_plugin_api::*;\nuse std::sync::Arc;\n\n// Helper to create test context\nfn create_test_context() -\u003e Arc\u003cPluginContext\u003e {\n    let state = Arc::new(parking_lot::Mutex::new(\n        context::SharedState::new(80, 24)\n    ));\n    Arc::new(PluginContext::new(\n        context::PluginConfigData::default(),\n        state,\n        \"test-plugin\",\n    ))\n}\n\n// Mock plugin for testing\nstruct TestPlugin {\n    metadata: PluginMetadata,\n    call_count: u32,\n}\n\nimpl TestPlugin {\n    fn new() -\u003e Self {\n        Self {\n            metadata: PluginMetadata::new(\n                \"test-plugin\",\n                \"1.0.0\",\n                \"Test plugin\",\n                \"Test Author\",\n            ),\n            call_count: 0,\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl Plugin for TestPlugin {\n    fn metadata(\u0026self) -\u003e \u0026PluginMetadata {\n        \u0026self.metadata\n    }\n\n    async fn on_load(\u0026mut self, ctx: \u0026mut PluginContext) -\u003e Result\u003c()\u003e {\n        ctx.log(context::LogLevel::Info, \"Test plugin loaded\");\n        Ok(())\n    }\n\n    async fn on_output(\u0026mut self, line: \u0026str, _ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n        self.call_count += 1;\n\n        if line.contains(\"MODIFY\") {\n            Ok(Action::Modify(b\"MODIFIED\".to_vec()))\n        } else if line.contains(\"STOP\") {\n            Ok(Action::Stop)\n        } else {\n            Ok(Action::Continue)\n        }\n    }\n\n    async fn on_input(\u0026mut self, input: \u0026[u8], _ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n        if input == b\"\\x18\" {  // Ctrl+X\n            Ok(Action::Stop)\n        } else {\n            Ok(Action::Continue)\n        }\n    }\n}\n\n#[tokio::test]\nasync fn test_plugin_metadata() {\n    let plugin = TestPlugin::new();\n    let meta = plugin.metadata();\n\n    assert_eq!(meta.name, \"test-plugin\");\n    assert_eq!(meta.version, \"1.0.0\");\n    assert!(meta.is_compatible(API_VERSION));\n}\n\n#[tokio::test]\nasync fn test_plugin_load() {\n    let mut plugin = TestPlugin::new();\n    let ctx = create_test_context();\n    let mut ctx_mut = (*ctx).clone();\n\n    let result = plugin.on_load(\u0026mut ctx_mut).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_output_hook_continue() {\n    let mut plugin = TestPlugin::new();\n    let ctx = create_test_context();\n\n    let result = plugin.on_output(\"test line\", \u0026ctx).await.unwrap();\n    assert_eq!(result, Action::Continue);\n    assert_eq!(plugin.call_count, 1);\n}\n\n#[tokio::test]\nasync fn test_output_hook_modify() {\n    let mut plugin = TestPlugin::new();\n    let ctx = create_test_context();\n\n    let result = plugin.on_output(\"MODIFY this\", \u0026ctx).await.unwrap();\n    assert!(result.is_modify());\n\n    if let Action::Modify(data) = result {\n        assert_eq!(data, b\"MODIFIED\");\n    } else {\n        panic!(\"Expected Modify action\");\n    }\n}\n\n#[tokio::test]\nasync fn test_output_hook_stop() {\n    let mut plugin = TestPlugin::new();\n    let ctx = create_test_context();\n\n    let result = plugin.on_output(\"STOP here\", \u0026ctx).await.unwrap();\n    assert!(result.is_stop());\n}\n\n#[tokio::test]\nasync fn test_input_hook() {\n    let mut plugin = TestPlugin::new();\n    let ctx = create_test_context();\n\n    // Normal input\n    let result = plugin.on_input(b\"a\", \u0026ctx).await.unwrap();\n    assert_eq!(result, Action::Continue);\n\n    // Ctrl+X\n    let result = plugin.on_input(b\"\\x18\", \u0026ctx).await.unwrap();\n    assert!(result.is_stop());\n}\n\n#[test]\nfn test_version_compatibility() {\n    let meta = PluginMetadata::new(\"test\", \"1.0.0\", \"Test\", \"Author\")\n        .with_api_version(\"0.1.0\");\n\n    // Same version\n    assert!(meta.is_compatible(\"0.1.0\"));\n\n    // Newer minor version\n    assert!(meta.is_compatible(\"0.2.0\"));\n    assert!(meta.is_compatible(\"0.10.0\"));\n\n    // Older minor version\n    assert!(!meta.is_compatible(\"0.0.1\"));\n\n    // Different major version\n    assert!(!meta.is_compatible(\"1.0.0\"));\n}\n\n#[test]\nfn test_plugin_config_data() {\n    use std::collections::HashMap;\n\n    let mut data = HashMap::new();\n    data.insert(\"threshold\".to_string(), toml::Value::Integer(42));\n    data.insert(\"enabled\".to_string(), toml::Value::Boolean(true));\n\n    let config = context::PluginConfigData { data };\n\n    // Get existing value\n    let threshold: i64 = config.get(\"threshold\").unwrap();\n    assert_eq!(threshold, 42);\n\n    // Get optional existing value\n    let enabled: bool = config.get_opt(\"enabled\").unwrap();\n    assert!(enabled);\n\n    // Get missing optional value\n    let missing: Option\u003cString\u003e = config.get_opt(\"missing\");\n    assert!(missing.is_none());\n}\n\n#[test]\nfn test_plugin_discovery() {\n    let _discovery = PluginDiscovery::new();\n\n    // Test default paths\n    let plugin_dir = PluginDiscovery::default_plugin_dir();\n    assert!(plugin_dir.to_string_lossy().contains(\".config/scarab/plugins\"));\n\n    let config_path = PluginDiscovery::default_config_path();\n    assert!(config_path.to_string_lossy().contains(\".config/scarab/plugins.toml\"));\n}\n\n#[test]\nfn test_cell_default() {\n    let cell = types::Cell::default();\n    assert_eq!(cell.c, ' ');\n    assert_eq!(cell.fg, (255, 255, 255));\n    assert_eq!(cell.bg, (0, 0, 0));\n    assert!(!cell.bold);\n    assert!(!cell.italic);\n    assert!(!cell.underline);\n}\n\n#[test]\nfn test_shared_state() {\n    let mut state = context::SharedState::new(80, 24);\n\n    // Test get/set cell\n    assert!(state.get_cell(0, 0).is_some());\n    assert!(state.get_cell(80, 0).is_none());  // Out of bounds\n\n    let cell = types::Cell {\n        c: 'X',\n        fg: (255, 0, 0),\n        bg: (0, 0, 0),\n        bold: true,\n        italic: false,\n        underline: false,\n    };\n\n    assert!(state.set_cell(0, 0, cell));\n    assert!(!state.set_cell(100, 100, cell));  // Out of bounds\n\n    let retrieved = state.get_cell(0, 0).unwrap();\n    assert_eq!(retrieved.c, 'X');\n    assert_eq!(retrieved.fg, (255, 0, 0));\n    assert!(retrieved.bold);\n}\n\n#[test]\nfn test_plugin_context_data_storage() {\n    let ctx = create_test_context();\n\n    // Store data\n    ctx.set_data(\"key1\", \"value1\");\n    ctx.set_data(\"key2\", \"value2\");\n\n    // Retrieve data\n    assert_eq!(ctx.get_data(\"key1\"), Some(\"value1\".to_string()));\n    assert_eq!(ctx.get_data(\"key2\"), Some(\"value2\".to_string()));\n    assert_eq!(ctx.get_data(\"missing\"), None);\n\n    // Overwrite data\n    ctx.set_data(\"key1\", \"new_value\");\n    assert_eq!(ctx.get_data(\"key1\"), Some(\"new_value\".to_string()));\n}\n\n#[test]\nfn test_hook_type() {\n    let all_hooks = HookType::all();\n    assert_eq!(all_hooks.len(), 7);\n\n    assert_eq!(HookType::PreOutput.name(), \"pre-output\");\n    assert_eq!(HookType::PostInput.name(), \"post-input\");\n    assert_eq!(HookType::OnResize.name(), \"on-resize\");\n}\n\n#[test]\nfn test_action_checks() {\n    assert!(!Action::Continue.is_modify());\n    assert!(!Action::Continue.is_stop());\n\n    assert!(!Action::Stop.is_modify());\n    assert!(Action::Stop.is_stop());\n\n    let modify = Action::Modify(vec![1, 2, 3]);\n    assert!(modify.is_modify());\n    assert!(!modify.is_stop());\n}\n\n#[test]\nfn test_plugin_info() {\n    let info = types::PluginInfo::new(\n        \"test\",\n        \"1.0.0\",\n        \"Test plugin\",\n        \"Author\",\n    );\n\n    assert_eq!(info.name, \"test\");\n    assert_eq!(info.version, \"1.0.0\");\n    assert!(info.enabled);\n    assert_eq!(info.failure_count, 0);\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":6}},{"line":8,"address":[],"length":0,"stats":{"Line":18}},{"line":9,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":12}},{"line":12,"address":[],"length":0,"stats":{"Line":6}},{"line":13,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":27,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":2}}],"covered":13,"coverable":13},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","crates","scarab-protocol","src","lib.rs"],"content":"#![no_std]\n// This crate defines the data layout shared between Daemon and Client.\n// It must be #[repr(C)] to ensure memory layout consistency across processes.\n\nuse bytemuck::{Pod, Zeroable};\n\npub const SHMEM_PATH: \u0026str = \"/scarab_shm_v1\";\npub const GRID_WIDTH: usize = 200;\npub const GRID_HEIGHT: usize = 100;\npub const BUFFER_SIZE: usize = GRID_WIDTH * GRID_HEIGHT;\n\n#[repr(C)]\n#[derive(Copy, Clone, Pod, Zeroable)]\npub struct Cell {\n    pub char_codepoint: u32,\n    pub fg: u32,   // RGBA\n    pub bg: u32,   // RGBA\n    pub flags: u8, // Bold, Italic, etc.\n    pub _padding: [u8; 3], // Align to 16 bytes\n}\n\nimpl Default for Cell {\n    fn default() -\u003e Self {\n        Self {\n            char_codepoint: b' ' as u32,\n            fg: 0xFFFFFFFF, // White\n            bg: 0x000000FF, // Black\n            flags: 0,\n            _padding: [0; 3],\n        }\n    }\n}\n\n// A double-buffered grid state living in shared memory\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct SharedState {\n    pub sequence_number: u64, // Atomic sequence for synchronization\n    pub dirty_flag: u8,\n    pub _padding1: [u8; 1],   // Align to u16 boundary\n    pub cursor_x: u16,\n    pub cursor_y: u16,\n    pub _padding2: [u8; 2],   // Align to u64 boundary for cells array\n    // Fixed size buffer for the \"visible\" screen.\n    // In production, use offset pointers to a larger ring buffer.\n    pub cells: [Cell; BUFFER_SIZE],\n}\n\n// Manual implementations needed for large arrays\nunsafe impl Pod for SharedState {}\nunsafe impl Zeroable for SharedState {}\n\n// Control messages (Sent via Socket/Pipe, not ShMem)\n// Using rkyv for zero-copy serialization\n#[derive(Debug, Clone, rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]\n#[archive(check_bytes)]\npub enum ControlMessage {\n    Resize { cols: u16, rows: u16 },\n    Input { data: alloc::vec::Vec\u003cu8\u003e },\n    LoadPlugin { path: alloc::string::String },\n    Ping { timestamp: u64 },\n    Disconnect { client_id: u64 },\n\n    // Session management commands\n    SessionCreate { name: alloc::string::String },\n    SessionDelete { id: alloc::string::String },\n    SessionList,\n    SessionAttach { id: alloc::string::String },\n    SessionDetach { id: alloc::string::String },\n    SessionRename { id: alloc::string::String, new_name: alloc::string::String },\n}\n\n// Session response messages\n#[derive(Debug, Clone, rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]\n#[archive(check_bytes)]\npub enum SessionResponse {\n    Created { id: alloc::string::String, name: alloc::string::String },\n    Deleted { id: alloc::string::String },\n    List { sessions: alloc::vec::Vec\u003cSessionInfo\u003e },\n    Attached { id: alloc::string::String },\n    Detached { id: alloc::string::String },\n    Renamed { id: alloc::string::String, new_name: alloc::string::String },\n    Error { message: alloc::string::String },\n}\n\n#[derive(Debug, Clone, rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]\n#[archive(check_bytes)]\npub struct SessionInfo {\n    pub id: alloc::string::String,\n    pub name: alloc::string::String,\n    pub created_at: u64,\n    pub last_attached: u64,\n    pub attached_clients: u32,\n}\n\n// IPC configuration constants\npub const SOCKET_PATH: \u0026str = \"/tmp/scarab-daemon.sock\";\npub const MAX_MESSAGE_SIZE: usize = 8192;\npub const MAX_CLIENTS: usize = 16;\npub const RECONNECT_DELAY_MS: u64 = 100;\npub const MAX_RECONNECT_ATTEMPTS: u32 = 10;\n\nextern crate alloc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","beengud","raibid-labs","scarab","scarab","examples","plugin-template","src","lib.rs"],"content":"//! Example Scarab Plugin Template\n//!\n//! This is a template for creating your own Scarab plugins.\n//! Copy this directory and modify it to create your custom plugin.\n\nuse scarab_plugin_api::{\n    Action, Plugin, PluginContext, PluginMetadata, Result,\n};\nuse async_trait::async_trait;\n\n/// Your custom plugin struct\n///\n/// Add any state your plugin needs here.\npub struct ExamplePlugin {\n    metadata: PluginMetadata,\n    // Add your plugin state here\n    notification_count: u32,\n}\n\nimpl ExamplePlugin {\n    /// Create a new instance of your plugin\n    pub fn new() -\u003e Self {\n        Self {\n            metadata: PluginMetadata::new(\n                \"example-plugin\",\n                \"0.1.0\",\n                \"An example plugin that demonstrates the Scarab plugin API\",\n                \"Your Name \u003cyour.email@example.com\u003e\",\n            )\n            .with_homepage(\"https://github.com/yourusername/scarab-plugin-example\"),\n            notification_count: 0,\n        }\n    }\n}\n\nimpl Default for ExamplePlugin {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl Plugin for ExamplePlugin {\n    fn metadata(\u0026self) -\u003e \u0026PluginMetadata {\n        \u0026self.metadata\n    }\n\n    /// Called when the plugin is loaded\n    async fn on_load(\u0026mut self, ctx: \u0026mut PluginContext) -\u003e Result\u003c()\u003e {\n        ctx.log(\n            scarab_plugin_api::context::LogLevel::Info,\n            \"Example plugin loaded!\",\n        );\n\n        // Initialize plugin state here\n        self.notification_count = 0;\n\n        Ok(())\n    }\n\n    /// Called when the plugin is being unloaded\n    async fn on_unload(\u0026mut self) -\u003e Result\u003c()\u003e {\n        log::info!(\n            \"Example plugin unloaded. Sent {} notifications.\",\n            self.notification_count\n        );\n        Ok(())\n    }\n\n    /// Hook called before output is displayed\n    async fn on_output(\u0026mut self, line: \u0026str, ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n        // Example: Detect error keywords and send notification\n        let error_keywords = [\"ERROR\", \"FAIL\", \"PANIC\", \"FATAL\"];\n\n        if error_keywords.iter().any(|\u0026kw| line.contains(kw)) {\n            ctx.notify(\u0026format!(\"Error detected: {}\", line));\n            self.notification_count += 1;\n\n            // Optionally modify the line to highlight it\n            // For now, we just continue\n            return Ok(Action::Continue);\n        }\n\n        // Pass through unchanged\n        Ok(Action::Continue)\n    }\n\n    /// Hook called after input is received\n    async fn on_input(\u0026mut self, input: \u0026[u8], _ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n        // Example: You could intercept certain key combinations here\n        // For now, just pass through\n        Ok(Action::Continue)\n    }\n\n    /// Hook called before a command is executed\n    async fn on_pre_command(\u0026mut self, command: \u0026str, ctx: \u0026PluginContext) -\u003e Result\u003cAction\u003e {\n        // Example: Log all commands\n        ctx.log(\n            scarab_plugin_api::context::LogLevel::Debug,\n            \u0026format!(\"Executing command: {}\", command),\n        );\n        Ok(Action::Continue)\n    }\n\n    /// Hook called after a command completes\n    async fn on_post_command(\n        \u0026mut self,\n        command: \u0026str,\n        exit_code: i32,\n        ctx: \u0026PluginContext,\n    ) -\u003e Result\u003c()\u003e {\n        // Example: Notify on command failures\n        if exit_code != 0 {\n            ctx.notify(\u0026format!(\"Command '{}' failed with exit code {}\", command, exit_code));\n            self.notification_count += 1;\n        }\n        Ok(())\n    }\n\n    /// Hook called when terminal is resized\n    async fn on_resize(\u0026mut self, cols: u16, rows: u16, ctx: \u0026PluginContext) -\u003e Result\u003c()\u003e {\n        ctx.log(\n            scarab_plugin_api::context::LogLevel::Debug,\n            \u0026format!(\"Terminal resized to {}x{}\", cols, rows),\n        );\n        Ok(())\n    }\n\n    /// Hook called when a client attaches\n    async fn on_attach(\u0026mut self, client_id: u64, ctx: \u0026PluginContext) -\u003e Result\u003c()\u003e {\n        ctx.notify(\u0026format!(\"Client {} attached\", client_id));\n        Ok(())\n    }\n\n    /// Hook called when a client detaches\n    async fn on_detach(\u0026mut self, client_id: u64, ctx: \u0026PluginContext) -\u003e Result\u003c()\u003e {\n        ctx.notify(\u0026format!(\"Client {} detached\", client_id));\n        Ok(())\n    }\n}\n\n// Export the plugin creation function\n#[no_mangle]\npub extern \"C\" fn create_plugin() -\u003e Box\u003cdyn Plugin\u003e {\n    Box::new(ExamplePlugin::new())\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>